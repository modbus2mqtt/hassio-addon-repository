import { ISpecificationTexts, IbaseSpecification, IdentifiedStates, IimageAndDocumentUrl, ImodbusEntity, SpecificationStatus } from '@modbus2mqtt/specification.shared';
import { IClientOptions } from 'mqtt';
export declare enum HttpErrorsEnum {
    OK = 200,
    OkCreated = 201,
    OkAccepted = 202,
    OkNonAuthoritativeInformation = 203,
    OkNoContent = 204,
    ErrBadRequest = 400,
    ErrUnauthorized = 401,
    ErrForbidden = 403,
    ErrNotFound = 404,
    ErrNotAcceptable = 406,
    ErrRequestTimeout = 408,
    ErrInvalidParameter = 422,
    SrvErrInternalServerError = 500
}
export declare enum RoutingNames {
    login = "login",
    register = "register",
    configure = "configure",
    busses = "busses",
    specifications = "specifications",
    slaves = "slaves",
    specification = "specification"
}
export declare enum PollModes {
    intervall = 0,
    trigger = 1,
    intervallAndTrigger = 2,
    noPoll = 3
}
export interface ImqttClient extends IClientOptions {
    mqttserverurl?: string;
    ssl?: boolean;
}
export interface IRTUConnection {
    serialport: string;
    baudrate: number;
    timeout: number;
}
export interface ITCPConnection {
    host: string;
    port: number;
    timeout: number;
}
export type IModbusConnection = IRTUConnection | ITCPConnection;
export interface Iconfiguration {
    password?: string;
    username?: string;
    githubPersonalToken?: string;
    version: string;
    fakeModbus: boolean;
    noAuthentication: boolean;
    mqttbasetopic: string;
    mqttdiscoveryprefix: string;
    mqttdiscoverylanguage: string;
    mqttusehassio?: boolean;
    mqttconnect: ImqttClient;
    mqttcaFile?: string;
    mqttkeyFile?: string;
    mqttcertFile?: string;
    filelocation?: string;
    httpport: number;
    rootUrl?: string;
    supervisor_host?: string;
    debugComponents?: string;
}
export declare enum AuthenticationErrors {
    EnvironmentVariableSecretNotSet = 1,
    HashError = 2,
    InvalidUserPasswordCombination = 3,
    InvalidParameters = 4,
    SignError = 5
}
export interface IUserAuthenticationStatus {
    registered: boolean;
    hassiotoken: boolean;
    hasAuthToken?: boolean;
    noAuthentication: boolean;
    authTokenExpired?: boolean;
    mqttConfigured: boolean;
    preSelectedBusId?: number;
}
export interface IBus {
    busId: number;
    connectionData: IModbusConnection;
    slaves: Islave[];
}
export declare function getConnectionName(connection: IModbusConnection): string;
export interface ImodbusError {
    entityId: number;
    message: string;
}
export interface ImodbusErrorsForSlave {
    errors: ImodbusError[];
    notIdentifiedEntities: number[];
    totalErrorCount: number;
    errorsSinceLastSuccessful: number;
    allEntitiesFailed: boolean;
    lastAllEntitiesFailedTime: number;
    lastAllEntitiesFailedSinceLastSuccessful: number;
    lastErrorTime: number;
    lastSuccessfulIdentifiedTime: number;
    lastIdentifiedSinceLastSuccessful: number;
}
export interface Islave {
    slaveid: number;
    specificationid?: string;
    name?: string;
    pollInterval?: number;
    pollMode?: PollModes;
    specification?: IbaseSpecification;
    durationOfLongestModbusCall?: number;
    modbusTimout?: number;
    evalTimeout?: boolean;
    detectSpec?: boolean;
    qos?: number;
    rootTopic?: string;
    noDiscoverEntities?: number[];
    noDiscovery?: boolean;
    modbusErrorsForSlave?: ImodbusErrorsForSlave;
}
export interface IidentificationSpecification {
    filename: string;
    status: SpecificationStatus;
    entities: ImodbusEntity[];
    files: IimageAndDocumentUrl[];
    i18n: ISpecificationTexts[];
    identified: IdentifiedStates;
    configuredSlave?: Islave;
}
