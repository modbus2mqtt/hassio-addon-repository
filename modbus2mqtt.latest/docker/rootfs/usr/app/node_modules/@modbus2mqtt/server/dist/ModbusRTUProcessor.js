"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModbusRTUProcessor = void 0;
const tslib_1 = require("tslib");
const specification_1 = require("@modbus2mqtt/specification");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const ModbusRTUQueue_1 = require("./ModbusRTUQueue");
const specification_2 = require("@modbus2mqtt/specification");
const debug_1 = tslib_1.__importDefault(require("debug"));
const debug = (0, debug_1.default)('modbusrtuprocessor');
const debugData = (0, debug_1.default)('modbusrtuprocessor.data');
const debugNext = (0, debug_1.default)('modbusrtuprocessor.next');
const debugTime = (0, debug_1.default)('modbusrtuprocessor.time');
const log = new specification_2.Logger('modbusrtuprocessor');
const maxAddressDelta = 10;
const logNoticeMaxWaitTime = 1000 * 60 * 30; // 30 minutes
class ModbusRTUProcessor {
    constructor(queue) {
        this.queue = queue;
    }
    prepare(slaveId, addresses) {
        let preparedAddresses = [];
        let previousAddress = {
            address: -1,
            registerType: specification_shared_1.ModbusRegisterType.IllegalFunctionCode,
        };
        let startAddress = {
            address: -1,
            registerType: specification_shared_1.ModbusRegisterType.IllegalFunctionCode,
        };
        let sortedAddresses = Array.from(addresses.values()).sort(function (a, b) {
            let v = a.registerType - b.registerType;
            if (v)
                return v;
            return a.address - b.address;
        });
        for (let addr of sortedAddresses) {
            if (previousAddress.address == -1)
                previousAddress = addr;
            if (startAddress.address == -1)
                startAddress = addr;
            if (addr.registerType != previousAddress.registerType || addr.address - previousAddress.address > maxAddressDelta) {
                preparedAddresses.push({
                    address: startAddress.address,
                    length: previousAddress.address - startAddress.address + 1,
                    registerType: previousAddress.registerType,
                });
                previousAddress = addr;
                startAddress = addr;
            }
            else
                previousAddress = addr;
        }
        if (startAddress.address >= 0)
            preparedAddresses.push({
                address: startAddress.address,
                length: previousAddress.address - startAddress.address + 1,
                registerType: previousAddress.registerType,
            });
        return preparedAddresses;
    }
    logNotice(msg, options) {
        if (options == undefined || !options.printLogs)
            return;
        // suppress similar duplicate messages
        let repeatMessage = ModbusRTUProcessor.lastNoticeMessageTime != undefined &&
            ModbusRTUProcessor.lastNoticeMessageTime + logNoticeMaxWaitTime < Date.now();
        if (repeatMessage || msg != ModbusRTUProcessor.lastNoticeMessage) {
            ModbusRTUProcessor.lastNoticeMessage = msg;
            ModbusRTUProcessor.lastNoticeMessageTime = Date.now();
            log.log(specification_1.LogLevelEnum.notice, options.task ? options.task + ' ' : '' + msg);
        }
    }
    /**
     * if timeout retry
     * if connection is RTU and any other error: reconnect then continue
     * if CRC error retry
     * if retried and length > 1 => split addresses and requeue
     * store error for
     * @param currentEntry
     * @param error
     * @returns true if the error was handled
     */
    errorHandler(currentEntry, result, options) {
        if (result.error.errno == 'ETIMEDOUT' && currentEntry.errorState != ModbusRTUQueue_1.ModbusErrorStates.timeout) {
            this.logNotice((options && options.task ? options.task : '') +
                ' TIMEOUT: slave:' +
                currentEntry.slaveId +
                ' address: ' +
                currentEntry.address.address +
                ' length:' +
                currentEntry.address.length +
                ' ' +
                (result.error.readDetails ? result.error.readDetails : '') +
                ' retrying ... ', options);
            currentEntry.errorState = ModbusRTUQueue_1.ModbusErrorStates.timeout;
            this.queue.retry(currentEntry);
            return true;
        }
        return false;
    }
    countResults(results) {
        let properties = Object.getOwnPropertyNames(results);
        let size = results.analogInputs.size;
        size += results.coils.size;
        size += results.discreteInputs.size;
        return size + results.holdingRegisters.size;
    }
    countAddresses(addresses) {
        let size = 0;
        addresses.forEach(address => { size += (address.length != undefined ? address.length : 1); });
        return size;
    }
    execute(slaveId, addresses, options) {
        return new Promise((resolve) => {
            let preparedAddresses = this.prepare(slaveId, addresses);
            let addressCount = this.countAddresses(addresses);
            let values = {
                holdingRegisters: new Map(),
                analogInputs: new Map(),
                coils: new Map(),
                discreteInputs: new Map(),
            };
            let resultMaps = new Map();
            resultMaps.set(specification_shared_1.ModbusRegisterType.AnalogInputs, values.analogInputs);
            resultMaps.set(specification_shared_1.ModbusRegisterType.HoldingRegister, values.holdingRegisters);
            resultMaps.set(specification_shared_1.ModbusRegisterType.Coils, values.coils);
            resultMaps.set(specification_shared_1.ModbusRegisterType.DiscreteInputs, values.discreteInputs);
            let resultCount = 0;
            preparedAddresses.forEach((address) => {
                this.queue.enqueue(slaveId, address, (result) => {
                    if (result == undefined || undefined == address.write)
                        throw new Error("Only read results expected for slave: " + slaveId + " function code: " + address.registerType + " address: " + address.address);
                    resultCount++;
                    if (address.length != undefined)
                        for (let idx = 0; idx < address.length; idx++) {
                            let r = {
                                result: { data: [result.result.data[idx]], buffer: Buffer.allocUnsafe(2) },
                            };
                            r.result.buffer.writeUIntBE(result.result.data[idx], 0, 2);
                            resultMaps.get(address.registerType).set(address.address + idx, r);
                        }
                    else
                        resultMaps.get(address.registerType).set(address.address, result);
                    if (this.countResults(values) == addressCount)
                        resolve(values);
                }, (currentEntry, error) => {
                    let r = { error: error };
                    if (!this.errorHandler(currentEntry, r, options))
                        resultCount++;
                    if (address.length != undefined)
                        for (let idx = 0; idx < address.length; idx++)
                            resultMaps.get(address.registerType).set(address.address + idx, r);
                    else
                        resultMaps.get(address.registerType).set(address.address, r);
                    if (this.countResults(values) == addressCount)
                        resolve(values);
                }, options);
            });
        });
    }
}
exports.ModbusRTUProcessor = ModbusRTUProcessor;
//# sourceMappingURL=ModbusRTUProcessor.js.map