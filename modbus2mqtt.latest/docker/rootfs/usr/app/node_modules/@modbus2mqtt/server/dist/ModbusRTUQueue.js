"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModbusRTUQueue = exports.ModbusErrorStates = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("events"));
const EventNewEntry = 'newEntry';
const EventCachedEntry = 'cachedEntry';
var ModbusErrorStates;
(function (ModbusErrorStates) {
    ModbusErrorStates[ModbusErrorStates["timeout"] = 0] = "timeout";
    ModbusErrorStates[ModbusErrorStates["crc"] = 1] = "crc";
    ModbusErrorStates[ModbusErrorStates["other"] = 2] = "other";
})(ModbusErrorStates || (exports.ModbusErrorStates = ModbusErrorStates = {}));
class ModbusRTUQueue {
    constructor() {
        this.eventEmitter = new events_1.default();
        this.list = [];
        this.list = [];
    }
    retry(entry) {
        this.list.push(entry);
        this.eventEmitter.emit('newEntry');
    }
    enqueue(slaveId, address, onResolve, onError, options) {
        let entry = {
            slaveId: slaveId,
            address: address,
            onResolve: onResolve,
            onError: onError,
            options: options,
        };
        if (entry.options && entry.options.useCache)
            this.eventEmitter.emit(EventCachedEntry, entry);
        else
            this.retry(entry);
    }
    dequeue() {
        return this.list.shift();
    }
    addNewEntryListener(listener) {
        this.eventEmitter.addListener(EventNewEntry, listener);
    }
    addCachedEntryListener(listener) {
        this.eventEmitter.addListener(EventCachedEntry, listener);
    }
    clear() {
        this.list = [];
    }
    getEntries() {
        return this.list;
    }
    getLength() {
        return this.list.length;
    }
}
exports.ModbusRTUQueue = ModbusRTUQueue;
//# sourceMappingURL=ModbusRTUQueue.js.map