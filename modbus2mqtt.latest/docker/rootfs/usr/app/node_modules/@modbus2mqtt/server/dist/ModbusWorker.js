"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModbusWorker = void 0;
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
class ModbusWorker {
    constructor(modbusAPI, queue) {
        this.modbusAPI = modbusAPI;
        this.queue = queue;
        this.functionCodeReadMap = new Map();
        this.functionCodeWriteMap = new Map();
        queue.addNewEntryListener(this.run.bind(this));
        queue.addCachedEntryListener(this.getCached.bind(this));
        this.functionCodeReadMap.set(specification_shared_1.ModbusRegisterType.HoldingRegister, this.modbusAPI.readHoldingRegisters);
        this.functionCodeReadMap.set(specification_shared_1.ModbusRegisterType.Coils, this.modbusAPI.readCoils);
        this.functionCodeReadMap.set(specification_shared_1.ModbusRegisterType.DiscreteInputs, this.modbusAPI.readDiscreteInputs);
        this.functionCodeReadMap.set(specification_shared_1.ModbusRegisterType.AnalogInputs, this.modbusAPI.readInputRegisters);
        this.functionCodeWriteMap.set(specification_shared_1.ModbusRegisterType.HoldingRegister, this.modbusAPI.writeHoldingRegisters);
        this.functionCodeWriteMap.set(specification_shared_1.ModbusRegisterType.Coils, this.modbusAPI.writeCoils);
    }
    /**
     * If entry is for readind: searchs for entry in cache. If not found, it forwards entry to queue
     * @param entry: Entry to search in cache
     */
    getCached(entry) {
        if (!entry.address.write) {
            // TODO not implemented
        }
        // not found in cache
        this.queue.retry(entry);
    }
    run() {
        let current = undefined;
        while (undefined != (current = this.queue.dequeue())) {
            if (current.address.write)
                this.functionCodeWriteMap.get(current.address.registerType)(current.slaveId, current.address.address, current.address.write)
                    .then(() => {
                    current.onResolve();
                })
                    .catch((e) => {
                    current.onError(current, e);
                });
            else
                this.functionCodeReadMap.get(current.address.registerType)(current.slaveId, current.address.address, current.address.length == undefined ? 1 : current.address.length)
                    .then((result) => {
                    current.onResolve(result);
                })
                    .catch((e) => {
                    current.onError(current, e);
                });
        }
    }
}
exports.ModbusWorker = ModbusWorker;
//# sourceMappingURL=ModbusWorker.js.map