import { ImodbusSpecification } from '@modbus2mqtt/specification.shared';
import { ImodbusAddress } from './modbuscache';
import { IReadRegisterResultOrError, ImodbusValues } from '@modbus2mqtt/specification';
import { IfileSpecification } from '@modbus2mqtt/specification';
import { ReadRegisterResult } from 'modbus-serial/ModbusRTU';
import { Islave, IModbusConnection, IBus, IidentificationSpecification, ImodbusErrorsForSlave } from '@modbus2mqtt/server.shared';
import { IModbusAPI } from './ModbusRTUWorker';
export interface ReadRegisterResultWithDuration extends IReadRegisterResultOrError {
    duration: number;
}
export declare class Bus implements IModbusAPI {
    private static busses;
    private static allSpecificationsModbusAddresses;
    private modbusErrors;
    static readBussesFromConfig(): void;
    static getBusses(): Bus[];
    static addBus(connection: IModbusConnection): Bus;
    private connectionChanged;
    updateBus(connection: IModbusConnection): Bus;
    static deleteBus(busid: number): void;
    static getBus(busid: number): Bus | undefined;
    static getAllAvailableModusData(): void;
    slaves: Map<number, ImodbusValues>;
    properties: IBus;
    private modbusClient;
    private modbusClientTimedOut;
    private modbusClientMutex;
    private modbusClientMutexAquireCount;
    private modbusClientActionMutex;
    constructor(ibus: IBus);
    getId(): number;
    private connectRTUClient;
    reconnectRTU(task: string): Promise<void>;
    connectRTU(task: string): Promise<void>;
    closeRTU(task: string, callback: Function): void;
    isRTUopen(): boolean;
    setModbusTimout(reject: (e: any) => void, e: any): void;
    clearModbusTimout(): void;
    readHoldingRegisters(slaveid: number, dataaddress: number, length: number): Promise<ReadRegisterResultWithDuration>;
    readInputRegisters(slaveid: number, dataaddress: number, length: number): Promise<ReadRegisterResultWithDuration>;
    readDiscreteInputs(slaveid: number, dataaddress: number, length: number): Promise<ReadRegisterResultWithDuration>;
    readCoils(slaveid: number, dataaddress: number, length: number): Promise<ReadRegisterResultWithDuration>;
    private prepareRead;
    getMaxModbusTimeout(): number;
    writeHoldingRegisters(slaveid: number, dataaddress: number, data: ReadRegisterResult): Promise<void>;
    writeCoils(slaveid: number, dataaddress: number, data: ReadRegisterResult): Promise<void>;
    private setModbusAddressesForSlave;
    getModbusAddressesForSlave(slaveid: number): ImodbusValues | undefined;
    deleteSlave(slaveid: number): void;
    static getModbusAddressesForSpec(spec: IfileSpecification, addresses: Set<ImodbusAddress>): void;
    private static updateAllSpecificationsModbusAddresses;
    private static getModbusAddressesForAllSpecs;
    private readModbusRegisterLogControl;
    readModbusRegister(task: string, slaveid: number, addresses: Set<ImodbusAddress>): Promise<ImodbusValues>;
    updateErrorsForSlaveId(slaveId: number, spec: ImodbusSpecification): void;
    getModbusErrorsForSlaveId(slaveId: number): ImodbusErrorsForSlave | undefined;
    getAvailableSpecs(slaveid: number, showAllPublicSpecs: boolean): Promise<IidentificationSpecification[]>;
    private convert2ImodbusSpecification;
    private convert2ImodbusSpecificationFromSpec;
    writeSlave(slave: Islave): Islave;
    getCachedValues(slaveid: number, addresses: Set<ImodbusAddress>): ImodbusValues | null;
    getSlaves(): Islave[];
    getSlaveBySlaveId(slaveid: number): Islave | undefined;
}
