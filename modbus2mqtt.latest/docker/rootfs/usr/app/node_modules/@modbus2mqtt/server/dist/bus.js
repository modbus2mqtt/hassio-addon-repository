"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bus = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const rxjs_1 = require("rxjs");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const specification_shared_2 = require("@modbus2mqtt/specification.shared");
const async_mutex_1 = require("async-mutex");
const modbuscache_1 = require("./modbuscache");
const specification_1 = require("@modbus2mqtt/specification");
const configbus_1 = require("./configbus");
const fs = tslib_1.__importStar(require("fs"));
const submitRequestMock_1 = require("./submitRequestMock");
const specification_2 = require("@modbus2mqtt/specification");
const modbus_serial_1 = tslib_1.__importDefault(require("modbus-serial"));
const server_shared_1 = require("@modbus2mqtt/server.shared");
const specification_3 = require("@modbus2mqtt/specification");
const config_1 = require("./config");
const debug = (0, debug_1.default)('bus');
const debugMutex = (0, debug_1.default)('bus.mutex');
const log = new specification_2.Logger('bus');
class Bus {
    static { this.busses = undefined; }
    static { this.allSpecificationsModbusAddresses = undefined; }
    static readBussesFromConfig() {
        let ibs = configbus_1.ConfigBus.getBussesProperties();
        if (!Bus.busses)
            Bus.busses = [];
        ibs.forEach((ib) => {
            let bus = Bus.busses.find((bus) => bus.getId() == ib.busId);
            if (bus !== undefined)
                bus.properties = ib;
            else {
                let b = new Bus(ib);
                b.getSlaves().forEach((s) => {
                    s.evalTimeout = true;
                });
                this.busses?.push(b);
            }
        });
        // delete removed busses
        for (let idx = 0; idx < Bus.busses.length; idx++) {
            if (!ibs.find((ib) => ib.busId == Bus.busses[idx].properties.busId))
                Bus.busses.splice(idx, 1);
        }
    }
    static getBusses() {
        if (!Bus.busses || Bus.busses.length != configbus_1.ConfigBus.getBussesProperties().length) {
            Bus.readBussesFromConfig();
        }
        //debug("getBusses Number of busses:" + Bus.busses!.length)
        return Bus.busses;
    }
    static addBus(connection) {
        debug('addBus()');
        let busP = configbus_1.ConfigBus.addBusProperties(connection);
        let b = Bus.getBusses().find((b) => b.getId() == busP.busId);
        return b;
    }
    connectionChanged(connection) {
        let rtu = this.properties.connectionData;
        if (rtu.serialport) {
            let connectionRtu = connection;
            if (!connectionRtu.serialport || connectionRtu.serialport !== rtu.serialport)
                return true;
            if (!connectionRtu.baudrate || connectionRtu.baudrate !== rtu.baudrate)
                return true;
            if (!connectionRtu.timeout || connectionRtu.timeout !== rtu.timeout)
                return true;
            return false;
        }
        else {
            let tcp = this.properties.connectionData;
            let connectionTcp = connection;
            if (!connectionTcp.host || connectionTcp.host !== tcp.host)
                return true;
            if (!connectionTcp.port || connectionTcp.port !== tcp.port)
                return true;
            if (!connectionTcp.timeout || connectionTcp.timeout !== tcp.timeout)
                return true;
            return false;
        }
    }
    updateBus(connection) {
        debug('updateBus()');
        if (this.connectionChanged(connection)) {
            let busP = configbus_1.ConfigBus.updateBusProperties(this.properties, connection);
            let b = Bus.getBusses().find((b) => b.getId() == busP.busId);
            if (b) {
                b.properties = busP;
                // Change of bus properties can influence the modbus data
                // E.g. set of lower timeout can lead to error messages
                b.slaves.clear();
                Bus.getAllAvailableModusData();
            }
            else
                throw new Error('Bus does not exist');
            return b;
        }
        return this;
    }
    static deleteBus(busid) {
        let idx = Bus.getBusses().findIndex((b) => b.properties.busId == busid);
        if (idx >= 0) {
            Bus.getBusses().splice(idx, 1);
            configbus_1.ConfigBus.deleteBusProperties(busid);
        }
    }
    static getBus(busid) {
        // debug("getBus()")
        return Bus.getBusses().find((b) => b.properties.busId == busid);
    }
    //Runs in background only no feedback
    static getAllAvailableModusData() {
        debug('getAllAvailableModusData');
        let subject = new rxjs_1.Subject();
        let busCount = Bus.getBusses().length;
        if (busCount == 0)
            setTimeout(() => {
                subject.next();
            }, 2);
        Bus.getBusses().forEach((bus) => {
            bus.properties.slaves.forEach((slave) => {
                bus
                    .getAvailableSpecs(slave.slaveid, true)
                    .then(() => {
                    debug('Specs for ' + bus.getId() + '/' + slave.slaveid + ' cached');
                })
                    .catch((e) => {
                    log.log(specification_2.LogLevelEnum.error, 'getAllAvailableModusData failed: ' + e.message);
                });
            });
        });
    }
    constructor(ibus) {
        this.modbusErrors = new Map();
        this.slaves = new Map();
        this.modbusClientTimedOut = false;
        this.modbusClientMutex = new async_mutex_1.Mutex();
        this.modbusClientMutexAquireCount = 0;
        this.modbusClientActionMutex = new async_mutex_1.Mutex();
        this.properties = ibus;
    }
    getId() {
        return this.properties.busId;
    }
    connectRTUClient() {
        return new Promise((resolve, reject) => {
            if (this.modbusClient == undefined)
                this.modbusClient = new modbus_serial_1.default();
            if (this.modbusClient.isOpen) {
                resolve();
                return;
            }
            // debug("connectRTUBuffered")
            let port = this.properties.connectionData.serialport;
            let baudrate = this.properties.connectionData.baudrate;
            if (port && baudrate) {
                this.modbusClient.connectRTUBuffered(port, { baudRate: baudrate }).then(resolve).catch(reject);
            }
            else {
                let host = this.properties.connectionData.host;
                let port = this.properties.connectionData.port;
                this.modbusClient.connectTCP(host, { port: port }).then(resolve).catch(reject);
            }
        });
    }
    reconnectRTU(task) {
        debugMutex(task + ' reconnecting ' + (this.modbusClient?.isOpen ? 'opened' : 'closed'));
        let rc = new Promise((resolve, reject) => {
            if (this.modbusClientTimedOut) {
                if (this.modbusClient == undefined || !this.modbusClient.isOpen) {
                    reject(task + ' Last read failed with TIMEOUT and modbusclient is not ready');
                    return;
                }
                else
                    resolve();
            }
            else if (this.modbusClient == undefined || !this.modbusClient.isOpen) {
                this.connectRTUClient()
                    .then(resolve)
                    .catch((e) => {
                    log.log(specification_2.LogLevelEnum.error, task + ' connection failed ' + e);
                    debugMutex(task + ' release ' + this.modbusClientMutexAquireCount--);
                    this.modbusClientMutex.release();
                    reject(e);
                });
            }
            else if (this.modbusClient.isOpen) {
                this.modbusClient.close(() => {
                    debug('closed');
                    if (this.modbusClient.isOpen)
                        setTimeout(() => {
                            if (this.modbusClient.isOpen)
                                reject(new Error('ModbusClient is open after close'));
                            else
                                this.reconnectRTU(task).then(resolve).catch(reject);
                        }, 10);
                    else
                        this.reconnectRTU(task).then(resolve).catch(reject);
                });
            }
            else {
                debugMutex(task + ' release ' + this.modbusClientMutexAquireCount--);
                this.modbusClientMutex.release();
                reject(new Error(task + ' unable to open'));
            }
        });
        return rc;
    }
    connectRTU(task) {
        let rc = new Promise((resolve, reject) => {
            debugMutex(task +
                ' connectRTU modbusClientMutex ' +
                (this.modbusClientMutex.isLocked() ? 'locked' : 'unlocked') +
                ' mutex:' +
                this.modbusClientMutexAquireCount++);
            this.modbusClientMutex.acquire().then(() => {
                this.connectRTUClient()
                    .then(resolve)
                    .catch((e) => {
                    log.log(specification_2.LogLevelEnum.error, task + ' connection failed ' + e);
                    debugMutex(task + ' release ' + this.modbusClientMutexAquireCount--);
                    this.modbusClientMutex.release();
                    reject(e);
                });
            });
        });
        return rc;
    }
    closeRTU(task, callback) {
        debugMutex(task + ' closeRTU');
        if (this.modbusClientTimedOut) {
            debugMutex(task + ' Timeout: release ' + this.modbusClientMutexAquireCount--);
            this.modbusClientMutex.release();
            debug("Workaround: Last calls TIMEDOUT won't close");
            callback();
        }
        else if (this.modbusClient == undefined) {
            debugMutex(task + ' modbusClient undefined: release ' + this.modbusClientMutexAquireCount--);
            this.modbusClientMutex.release();
            log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
        }
        else
            this.modbusClient.close(() => {
                debugMutex(task + ' close: release ' + this.modbusClientMutexAquireCount--);
                this.modbusClientMutex.release();
                // debug("closeRTU: " + (this.modbusClient?.isOpen ? "open" : "closed"))
                callback();
            });
    }
    isRTUopen() {
        if (this.modbusClient == undefined) {
            log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
            return false;
        }
        else
            return this.modbusClient.isOpen;
    }
    setModbusTimout(reject, e) {
        this.modbusClientTimedOut = e.errno && e.errno == 'ETIMEDOUT';
        reject(e);
    }
    clearModbusTimout() {
        this.modbusClientTimedOut = false;
    }
    readHoldingRegisters(slaveid, dataaddress, length) {
        let rc = new Promise((resolve, reject) => {
            if (this.modbusClient == undefined) {
                log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
                reject(new Error('modbusClient is undefined'));
            }
            else {
                this.prepareRead(slaveid);
                this.modbusClientActionMutex.acquire().then(() => {
                    let start = Date.now();
                    this.modbusClient.readHoldingRegisters(dataaddress, length)
                        .then((data) => {
                        this.modbusClientActionMutex.release();
                        this.clearModbusTimout();
                        let rc = {
                            result: data,
                            duration: Date.now() - start,
                        };
                        resolve(rc);
                    })
                        .catch((e) => {
                        this.modbusClientActionMutex.release();
                        e.duration = Date.now() - start;
                        this.setModbusTimout(reject, e);
                    });
                });
            }
        });
        return rc;
    }
    readInputRegisters(slaveid, dataaddress, length) {
        let rc = new Promise((resolve, reject) => {
            if (this.modbusClient == undefined) {
                log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
                return;
            }
            else {
                this.prepareRead(slaveid);
                this.modbusClientActionMutex.acquire().then(() => {
                    let start = Date.now();
                    this.modbusClient.readInputRegisters(dataaddress, length)
                        .then((data) => {
                        this.modbusClientActionMutex.release();
                        this.clearModbusTimout();
                        let rc = {
                            result: data,
                            duration: Date.now() - start,
                        };
                        resolve(rc);
                    })
                        .catch((e) => {
                        this.modbusClientActionMutex.release();
                        this.setModbusTimout(reject, e);
                    });
                });
            }
        });
        return rc;
    }
    readDiscreteInputs(slaveid, dataaddress, length) {
        let rc = new Promise((resolve, reject) => {
            if (this.modbusClient == undefined) {
                log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
                return;
            }
            else {
                this.prepareRead(slaveid);
                this.modbusClientActionMutex.acquire().then(() => {
                    let start = Date.now();
                    this.modbusClient.readDiscreteInputs(dataaddress, length)
                        .then((resolveBoolean) => {
                        this.modbusClientActionMutex.release();
                        this.clearModbusTimout();
                        let readResult = {
                            data: [],
                            buffer: Buffer.allocUnsafe(0),
                        };
                        resolveBoolean.data.forEach((d) => {
                            readResult.data.push(d ? 1 : 0);
                        });
                        let rc = {
                            result: readResult,
                            duration: Date.now() - start,
                        };
                        resolve(rc);
                    })
                        .catch((e) => {
                        this.modbusClientActionMutex.release();
                        this.setModbusTimout(reject, e);
                    });
                });
            }
        });
        return rc;
    }
    readCoils(slaveid, dataaddress, length) {
        let rc = new Promise((resolve, reject) => {
            if (this.modbusClient == undefined) {
                log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
                return;
            }
            else {
                this.prepareRead(slaveid);
                this.modbusClientActionMutex.acquire().then(() => {
                    let start = Date.now();
                    this.modbusClient.readCoils(dataaddress, length)
                        .then((resolveBoolean) => {
                        this.modbusClientActionMutex.release();
                        this.clearModbusTimout();
                        let readResult = {
                            data: [],
                            buffer: Buffer.allocUnsafe(0),
                        };
                        resolveBoolean.data.forEach((d) => {
                            readResult.data.push(d ? 1 : 0);
                        });
                        let rc = {
                            result: readResult,
                            duration: Date.now() - start,
                        };
                        resolve(rc);
                    })
                        .catch((e) => {
                        this.modbusClientActionMutex.release();
                        this.setModbusTimout(reject, e);
                    });
                });
            }
        });
        return rc;
    }
    prepareRead(slaveid) {
        this.modbusClient.setID(slaveid);
        let slave = this.getSlaveBySlaveId(slaveid);
        if (slave) {
            if (slave.modbusTimout == undefined)
                slave.modbusTimout = this.properties.connectionData.timeout;
            this.modbusClient.setTimeout(slave.modbusTimout);
        }
    }
    getMaxModbusTimeout() {
        return this.properties.connectionData.timeout;
    }
    writeHoldingRegisters(slaveid, dataaddress, data) {
        let rc = new Promise((resolve, reject) => {
            if (this.modbusClient == undefined) {
                log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
                return;
            }
            else {
                this.modbusClientActionMutex.acquire().then(() => {
                    this.modbusClient.setID(slaveid);
                    this.modbusClient.setTimeout(this.properties.connectionData.timeout);
                    this.modbusClient.writeRegisters(dataaddress, data.data)
                        .then(() => {
                        this.modbusClientTimedOut = false;
                        this.modbusClientActionMutex.release();
                        resolve();
                    })
                        .catch((e) => {
                        this.modbusClientActionMutex.release();
                        this.setModbusTimout(reject, e);
                    });
                });
            }
        });
        return rc;
    }
    writeCoils(slaveid, dataaddress, data) {
        let rc = new Promise((resolve, reject) => {
            if (this.modbusClient == undefined) {
                log.log(specification_2.LogLevelEnum.error, 'modbusClient is undefined');
                return;
            }
            else {
                this.modbusClientActionMutex.acquire().then(() => {
                    this.modbusClient.setID(slaveid);
                    this.modbusClient.setTimeout(this.properties.connectionData.timeout);
                    let dataB = [];
                    data.data.forEach((d) => {
                        dataB.push(d == 1);
                    });
                    if (dataB.length === 1) {
                        //Using writeCoil for single value in case of situation that device does not support multiple at once like
                        // LC Technology relay/input boards
                        this.modbusClient.writeCoil(dataaddress, dataB[0])
                            .then(() => {
                            this.modbusClientActionMutex.release();
                            this.modbusClientTimedOut = false;
                            resolve();
                        })
                            .catch((e) => {
                            this.modbusClientActionMutex.release();
                            this.setModbusTimout(reject, e);
                        });
                    }
                    else {
                        this.modbusClient.writeCoils(dataaddress, dataB)
                            .then(() => {
                            this.modbusClientActionMutex.release();
                            this.modbusClientTimedOut = false;
                            resolve();
                        })
                            .catch((e) => {
                            this.modbusClientActionMutex.release();
                            this.setModbusTimout(reject, e);
                        });
                    }
                });
            }
        });
        return rc;
    }
    setModbusAddressesForSlave(slaveid, addresses) {
        if (this.slaves)
            this.slaves.set(slaveid, addresses);
    }
    getModbusAddressesForSlave(slaveid) {
        if (this.slaves)
            return this.slaves.get(slaveid);
        return undefined;
    }
    deleteSlave(slaveid) {
        configbus_1.ConfigBus.deleteSlave(this.properties.busId, slaveid);
        if (this.slaves)
            this.slaves.delete(slaveid);
        if (this.modbusErrors.get(slaveid))
            this.modbusErrors.delete(slaveid);
    }
    static getModbusAddressesForSpec(spec, addresses) {
        for (let ent of spec.entities) {
            let converter = specification_1.ConverterMap.getConverter(ent);
            if (ent.modbusAddress != undefined && converter && ent.registerType)
                for (let i = 0; i < converter.getModbusLength(ent); i++) {
                    addresses.add({
                        address: ent.modbusAddress + i,
                        registerType: ent.registerType,
                    });
                }
        }
    }
    static updateAllSpecificationsModbusAddresses(specificationid) {
        let cfg = new config_1.Config();
        // If a used specificationid was deleted, remove it from slaves
        if (specificationid != null) {
            new specification_3.ConfigSpecification().filterAllSpecifications((spec) => {
                if (spec.filename == specificationid)
                    specificationid = null;
            });
            Bus.getBusses().forEach((bus) => {
                bus.getSlaves().forEach((slave) => {
                    debug('updateAllSpecificationsModbusAddresses slaveid: ' + slave.slaveid);
                    if (specificationid == null)
                        slave.specificationid = undefined;
                    else
                        slave.specificationid = specificationid;
                    if (slave.specificationid == specificationid)
                        configbus_1.ConfigBus.writeslave(bus.getId(), slave);
                });
            });
        }
        Bus.allSpecificationsModbusAddresses = new Set();
        new specification_3.ConfigSpecification().filterAllSpecifications((spec) => {
            Bus.getModbusAddressesForSpec(spec, Bus.allSpecificationsModbusAddresses);
        });
    }
    /*
     * returns cached set of all modbusaddresses for all specifications.
     * It will be updated after any change to Config.specifications array
     */
    static getModbusAddressesForAllSpecs() {
        debug('getAllModbusAddresses');
        if (!Bus.allSpecificationsModbusAddresses) {
            Bus.updateAllSpecificationsModbusAddresses(null);
            // Config.getSpecificationsChangedObservable().subscribe(Bus.updateAllSpecificationsModbusAddresses)
        }
        return Bus.allSpecificationsModbusAddresses;
    }
    readModbusRegisterLogControl(task, printLog, slaveid, addresses) {
        return new Promise((resolve, reject) => {
            debug('readModbusRegister slaveid: ' + slaveid + ' addresses: ' + JSON.stringify(Array.from(addresses)));
            if (config_1.Config.getConfiguration().fakeModbus)
                (0, submitRequestMock_1.submitGetHoldingRegisterRequest)({ busid: this.getId(), slaveid: slaveid }, addresses).then(resolve).catch(reject);
            else
                new modbuscache_1.ModbusCache(task + '(' + slaveid + ')', printLog)
                    .submitGetHoldingRegisterRequest({ busid: this.getId(), slaveid: slaveid }, addresses)
                    .then(resolve)
                    .catch(reject);
        });
    }
    readModbusRegister(task, slaveid, addresses) {
        return this.readModbusRegisterLogControl(task, true, slaveid, addresses);
    }
    updateErrorsForSlaveId(slaveId, spec) {
        let slaveErrors = this.modbusErrors.get(slaveId);
        let me = undefined;
        if (!slaveErrors) {
            me = new server_shared_1.ModbusErrorsForSlave(slaveId);
            this.modbusErrors.set(slaveId, (slaveErrors = me.get()));
        }
        else
            me = new server_shared_1.ModbusErrorsForSlave(slaveId, slaveErrors);
        me.setErrors(spec);
    }
    getModbusErrorsForSlaveId(slaveId) {
        return this.modbusErrors.get(slaveId);
    }
    /*
     * getAvailableSpecs uses bus.slaves cache if possible
     */
    getAvailableSpecs(slaveid, showAllPublicSpecs) {
        return new Promise((resolve, reject) => {
            let addresses = Bus.getModbusAddressesForAllSpecs();
            let rcf = (modbusData) => {
                let cfg = new specification_3.ConfigSpecification();
                cfg.filterAllSpecifications((spec) => {
                    let mspec = specification_1.M2mSpecification.fileToModbusSpecification(spec, modbusData);
                    debug('getAvailableSpecs');
                    if (mspec) {
                        // list only identified public specs, but all local specs
                        if ([0 /* SpecificationStatus.published */, 4 /* SpecificationStatus.contributed */].includes(mspec.status) &&
                            (showAllPublicSpecs || mspec.identified == specification_shared_2.IdentifiedStates.identified))
                            iSpecs.push(this.convert2ImodbusSpecification(slaveid, mspec));
                        else if (![0 /* SpecificationStatus.published */, 4 /* SpecificationStatus.contributed */].includes(mspec.status))
                            iSpecs.push(this.convert2ImodbusSpecification(slaveid, mspec));
                    }
                    else if (![0 /* SpecificationStatus.published */, 4 /* SpecificationStatus.contributed */].includes(spec.status))
                        iSpecs.push(this.convert2ImodbusSpecificationFromSpec(slaveid, spec));
                });
                resolve(iSpecs);
            };
            let iSpecs = [];
            // try to find the result in cache
            let values = this.slaves.get(slaveid);
            if (values) {
                let addrs = [];
                let cacheFailed = false;
                addresses.forEach((address) => {
                    if (address.length)
                        for (let a = address.address; a < address.address + address.length; a++)
                            addrs.push(a);
                    else
                        addrs.push(address.address);
                    addrs.forEach((a) => {
                        switch (address.registerType) {
                            case specification_shared_1.ModbusRegisterType.HoldingRegister:
                                if (!values.holdingRegisters.has(address.address))
                                    cacheFailed = true;
                                break;
                            case specification_shared_1.ModbusRegisterType.AnalogInputs:
                                if (!values.analogInputs.has(address.address))
                                    cacheFailed = true;
                                break;
                            case specification_shared_1.ModbusRegisterType.Coils:
                                if (!values.coils.has(address.address))
                                    cacheFailed = true;
                                break;
                            case specification_shared_1.ModbusRegisterType.DiscreteInputs:
                                if (!values.discreteInputs.has(address.address))
                                    cacheFailed = true;
                                break;
                        }
                    });
                });
                if (!cacheFailed) {
                    rcf(values);
                    return;
                }
            }
            // no result in cache, read from modbus
            // will be called once (per slave)
            let usbPort = this.properties.connectionData.serialport;
            if (usbPort && !fs.existsSync(usbPort)) {
                reject(new Error('RTU is configured, but device is not available'));
                return;
            }
            this.readModbusRegisterLogControl('getAvailableSpecs', false, slaveid, addresses)
                .then((values) => {
                // Add not available addresses to the values
                let noData = { error: new Error('No data available') };
                addresses.forEach((address) => {
                    switch (address.registerType) {
                        case specification_shared_1.ModbusRegisterType.HoldingRegister:
                            if (!values.holdingRegisters.has(address.address))
                                values.holdingRegisters.set(address.address, noData);
                            break;
                        case specification_shared_1.ModbusRegisterType.AnalogInputs:
                            if (!values.analogInputs.has(address.address))
                                values.analogInputs.set(address.address, noData);
                            break;
                        case specification_shared_1.ModbusRegisterType.Coils:
                            if (!values.coils.has(address.address))
                                values.coils.set(address.address, noData);
                            break;
                        case specification_shared_1.ModbusRegisterType.DiscreteInputs:
                            if (!values.discreteInputs.has(address.address))
                                values.discreteInputs.set(address.address, noData);
                            break;
                    }
                });
                // Store it for cache
                this.setModbusAddressesForSlave(slaveid, values);
                rcf(values);
            })
                .catch(reject);
        });
    }
    convert2ImodbusSpecification(slaveid, mspec) {
        // for each spec
        let entityIdentifications = [];
        for (let ment of mspec.entities) {
            entityIdentifications.push(ment);
        }
        let configuredslave = this.properties.slaves.find((dev) => dev.specificationid === mspec.filename && dev.slaveid == slaveid);
        return {
            filename: mspec.filename,
            files: mspec.files,
            i18n: mspec.i18n,
            status: mspec.status,
            configuredSlave: configuredslave,
            entities: entityIdentifications,
            identified: mspec.identified,
        };
    }
    convert2ImodbusSpecificationFromSpec(slaveid, spec) {
        // for each spec
        let entityIdentifications = [];
        for (let ent of spec.entities) {
            let em = structuredClone(ent);
            em.modbusValue = [];
            em.mqttValue = '';
            em.identified = specification_shared_2.IdentifiedStates.notIdentified;
            entityIdentifications.push(structuredClone(ent));
        }
        let configuredslave = this.properties.slaves.find((dev) => dev.specificationid === spec.filename && dev.slaveid == slaveid);
        return {
            filename: spec.filename,
            files: spec.files,
            i18n: spec.i18n,
            status: spec.status,
            configuredSlave: configuredslave,
            entities: entityIdentifications,
            identified: specification_shared_2.IdentifiedStates.notIdentified,
        };
    }
    writeSlave(slave) {
        if (slave.slaveid < 0)
            throw new Error('Try to save invalid slave id '); // Make sure slaveid is unique
        let oldIdx = this.properties.slaves.findIndex((dev) => {
            return dev.slaveid === slave.slaveid;
        });
        configbus_1.ConfigBus.writeslave(this.properties.busId, slave);
        if (oldIdx >= 0)
            this.properties.slaves[oldIdx] = slave;
        else
            this.properties.slaves.push(slave);
        return slave;
    }
    getCachedValues(slaveid, addresses) {
        let rc = (0, specification_1.emptyModbusValues)();
        if (this.slaves) {
            let saddresses = this.slaves.get(slaveid);
            if (saddresses)
                for (let address of addresses) {
                    let value = saddresses.holdingRegisters.get(address.address);
                    let m = saddresses.holdingRegisters;
                    let r = rc.holdingRegisters;
                    switch (address.registerType) {
                        case specification_shared_1.ModbusRegisterType.AnalogInputs:
                            m = saddresses.analogInputs;
                            r = rc.analogInputs;
                            break;
                        case specification_shared_1.ModbusRegisterType.Coils:
                            m = saddresses.coils;
                            r = rc.coils;
                            break;
                        case specification_shared_1.ModbusRegisterType.DiscreteInputs:
                            m = saddresses.discreteInputs;
                            r = rc.discreteInputs;
                            break;
                    }
                    value = m.get(address.address);
                    if (value == undefined || value == null)
                        return null;
                    r.set(address.address, value);
                }
        }
        return rc;
    }
    getSlaves() {
        this.properties.slaves.forEach((s) => {
            if (s && s.specificationid) {
                let ispec = specification_3.ConfigSpecification.getSpecificationByFilename(s.specificationid);
                if (ispec)
                    s.specification = ispec;
            }
            s.modbusErrorsForSlave = this.getModbusErrorsForSlaveId(s.slaveid);
        });
        return this.properties.slaves;
    }
    getSlaveBySlaveId(slaveid) {
        let slave = this.properties.slaves.find((dev) => dev.slaveid == slaveid);
        if (slave && slave.specificationid) {
            let ispec = specification_3.ConfigSpecification.getSpecificationByFilename(slave.specificationid);
            if (ispec)
                slave.specification = ispec;
            slave.modbusErrorsForSlave = this.getModbusErrorsForSlaveId(slave.slaveid);
        }
        return slave;
    }
}
exports.Bus = Bus;
//# sourceMappingURL=bus.js.map