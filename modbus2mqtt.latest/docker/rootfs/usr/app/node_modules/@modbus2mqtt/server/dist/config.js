"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = exports.filesUrlPrefix = exports.ConfigListenerEvent = exports.MqttValidationResult = void 0;
exports.getSpecificationImageOrDocumentUrl = getSpecificationImageOrDocumentUrl;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const yaml_1 = require("yaml");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const jsonwebtoken_1 = require("jsonwebtoken");
const bcrypt = tslib_1.__importStar(require("bcryptjs"));
const specification_1 = require("@modbus2mqtt/specification");
const server_shared_1 = require("@modbus2mqtt/server.shared");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const bus_1 = require("./bus");
const CONFIG_VERSION = '0.1';
const DEFAULT_MQTT_CONNECT_TIMEOUT = 60 * 1000;
const HASSIO_TIMEOUT = 3000;
var MqttValidationResult;
(function (MqttValidationResult) {
    MqttValidationResult[MqttValidationResult["OK"] = 0] = "OK";
    MqttValidationResult[MqttValidationResult["tokenExpired"] = 1] = "tokenExpired";
    MqttValidationResult[MqttValidationResult["error"] = 2] = "error";
})(MqttValidationResult || (exports.MqttValidationResult = MqttValidationResult = {}));
var ConfigListenerEvent;
(function (ConfigListenerEvent) {
    ConfigListenerEvent[ConfigListenerEvent["addSlave"] = 0] = "addSlave";
    ConfigListenerEvent[ConfigListenerEvent["deleteSlave"] = 1] = "deleteSlave";
    ConfigListenerEvent[ConfigListenerEvent["updateSlave"] = 2] = "updateSlave";
    ConfigListenerEvent[ConfigListenerEvent["deleteBus"] = 3] = "deleteBus";
})(ConfigListenerEvent || (exports.ConfigListenerEvent = ConfigListenerEvent = {}));
const log = new specification_1.Logger('config');
const secretsLength = 256;
const debug = (0, debug_1.default)('config');
const debugAddon = (0, debug_1.default)('config.addon');
const saltRounds = 8;
const defaultTokenExpiryTime = 1000 * 60 * 60 * 24; // One day
//TODO const defaultTokenExpiryTime = 1000 * 20 // three seconds for testing
exports.filesUrlPrefix = 'specifications/files';
//const baseTopic = 'modbus2mqtt';
//const baseTopicHomeAssistant = 'homeassistant';
class Config {
    static { this.tokenExpiryTime = defaultTokenExpiryTime; }
    static { this.mqttHassioLoginData = undefined; }
    static login(name, password) {
        let rc = new Promise((resolve, reject) => {
            if (Config.config.noAuthentication) {
                log.log(specification_1.LogLevelEnum.error, 'Login called, but noAuthentication is configured');
                reject(server_shared_1.AuthenticationErrors.InvalidParameters);
                return;
            }
            if (Config.config && Config.config.username && Config.config.password) {
                // Login
                if (name === Config.config.username)
                    bcrypt
                        .compare(password, Config.config.password)
                        .then((success) => {
                        if (success) {
                            try {
                                //const iat = Math.floor(Date.now() / 1000)
                                //const exp = iat + Config.config.tokenExpiryTimeInMSec // seconds
                                let s = (0, jsonwebtoken_1.sign)({ password: password }, Config.secret, {
                                    expiresIn: Config.tokenExpiryTime + 'ms',
                                    algorithm: 'HS256',
                                });
                                resolve(s);
                            }
                            catch (err) {
                                log.log(specification_1.LogLevelEnum.error, err);
                                reject(server_shared_1.AuthenticationErrors.SignError);
                            }
                        }
                        else
                            reject(server_shared_1.AuthenticationErrors.InvalidUserPasswordCombination);
                    })
                        .catch((err) => {
                        log.log(specification_1.LogLevelEnum.error, 'login: compare failed: ' + err);
                        reject(server_shared_1.AuthenticationErrors.InvalidParameters);
                    });
                else {
                    log.log(specification_1.LogLevelEnum.error, 'login: Username was not set');
                    reject(server_shared_1.AuthenticationErrors.InvalidParameters);
                }
            }
        });
        return rc;
    }
    static register(name, password, noAuthentication) {
        let rc = new Promise((resolve, reject) => {
            if (noAuthentication == true) {
                Config.config.noAuthentication = true;
                new Config().writeConfiguration(Config.config);
                resolve();
            }
            else if (Config.config && password) {
                // Login
                //No username and password configured.: Register login
                bcrypt
                    .hash(password, saltRounds)
                    .then((enc) => {
                    Config.config.password = enc;
                    Config.config.username = name;
                    new Config().writeConfiguration(Config.config);
                    resolve();
                })
                    .catch((err) => {
                    reject(err);
                });
            }
            else
                reject(server_shared_1.AuthenticationErrors.InvalidParameters);
        });
        return rc;
    }
    static validateUserToken(token) {
        if (this.config.noAuthentication)
            return MqttValidationResult.OK;
        if (token == undefined)
            return MqttValidationResult.error;
        try {
            let v = (0, jsonwebtoken_1.verify)(token, Config.secret, { complete: true });
            v = (0, jsonwebtoken_1.verify)(token, Config.secret, {
                complete: true,
                ignoreExpiration: false,
            });
            if (bcrypt.compareSync(v.payload.password, Config.config.password))
                return MqttValidationResult.OK;
            else
                return MqttValidationResult.error;
        }
        catch (err) {
            if (err.name && err.name == 'TokenExpiredError')
                return MqttValidationResult.tokenExpired;
            log.log(specification_1.LogLevelEnum.error, 'Validate: ' + err);
            return MqttValidationResult.error;
        }
    }
    static getPublicDir() {
        return (0, path_1.join)(Config.yamlDir, 'public');
    }
    static getLocalDir() {
        return (0, path_1.join)(Config.yamlDir, 'local');
    }
    static { this.specificationsChanged = new rxjs_1.Subject(); }
    static { this.newConfig = {
        version: CONFIG_VERSION,
        mqttbasetopic: 'modbus2mqtt',
        mqttdiscoveryprefix: 'homeassistant',
        mqttdiscoverylanguage: 'en',
        mqttconnect: {
            connectTimeout: DEFAULT_MQTT_CONNECT_TIMEOUT,
        },
        httpport: 3000,
        fakeModbus: false,
        noAuthentication: false,
    }; }
    static { this.yamlDir = ''; }
    static { this.sslDir = ''; }
    static getSecret(pathStr) {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        let counter = 0;
        if (fs.existsSync(pathStr))
            return fs.readFileSync(pathStr, { encoding: 'utf8' }).toString();
        debug('getSecret: Create secrets file at' + pathStr);
        while (counter < secretsLength) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
            counter += 1;
        }
        let dir = path.dirname(pathStr);
        debug('Config.getSecret: write Secretfile to ' + pathStr);
        if (dir && !fs.existsSync(dir))
            fs.mkdirSync(dir, { recursive: true });
        fs.writeFileSync(pathStr, result, { encoding: 'utf8' });
        debug('Config.getSecret: write successful');
        return result;
    }
    static getConfiguration() {
        if (Config.secret == undefined) {
            var secretsfile = Config.sslDir.length > 0 ? (0, path_1.join)(Config.sslDir, 'secrets.txt') : 'secrets.txt';
            var sslDir = path.parse(secretsfile).dir;
            if (sslDir.length && !fs.existsSync(sslDir))
                fs.mkdirSync(sslDir, { recursive: true });
            try {
                if (fs.existsSync(secretsfile)) {
                    debug('secretsfile ' + 'secretsfile exists');
                    fs.accessSync(secretsfile, fs.constants.W_OK);
                }
                else
                    fs.accessSync(sslDir, fs.constants.W_OK);
                debug('Config.getConfiguration: secretsfile permissions are OK ' + secretsfile);
                Config.secret = Config.getSecret(secretsfile);
            }
            catch (err) {
                let msg = 'Secrets file ' +
                    secretsfile +
                    ' or parent directory is not writable! No registration possible!(cwd: ' +
                    process.cwd() +
                    ')';
                log.log(specification_1.LogLevelEnum.error, msg);
                debug('secretsfile=' + secretsfile + ' ssldir = ' + Config.sslDir);
                throw new Error(msg);
            }
        }
        if (Config.config) {
            Config.config.version = Config.config.version ? Config.config.version : CONFIG_VERSION;
            Config.config.mqttbasetopic = Config.config.mqttbasetopic ? Config.config.mqttbasetopic : 'modbus2mqtt';
            Config.config.mqttdiscoveryprefix = Config.config.mqttdiscoveryprefix ? Config.config.mqttdiscoveryprefix : 'homeassistant';
            Config.config.mqttdiscoverylanguage = Config.config.mqttdiscoverylanguage ? Config.config.mqttdiscoverylanguage : 'en';
            if (!Config.config.mqttconnect)
                Config.config.mqttconnect = {};
            Config.updateMqttTlsConfig(Config.config);
            Config.config.mqttconnect.connectTimeout = Config.config.mqttconnect.connectTimeout
                ? Config.config.mqttconnect.connectTimeout
                : DEFAULT_MQTT_CONNECT_TIMEOUT;
            Config.config.mqttconnect.clientId = Config.config.mqttconnect.clientId ? Config.config.mqttconnect.clientId : 'modbus2mqtt';
            Config.config.mqttconnect.clean = Config.config.mqttconnect.clean ? Config.config.mqttconnect.clean : false;
            delete Config.config.mqttconnect.will;
            Config.config.httpport = Config.config.httpport ? Config.config.httpport : 3000;
            Config.config.fakeModbus = Config.config.fakeModbus ? Config.config.fakeModbus : false;
            Config.config.noAuthentication = Config.config.noAuthentication ? Config.config.noAuthentication : false;
            Config.config.filelocation = Config.config.filelocation ? Config.config.filelocation : Config.yamlDir;
            process.env.HASSIO_TOKEN && process.env.HASSIO_TOKEN.length ? process.env.HASSIO_TOKEN : undefined;
            Config.config.mqttusehassio =
                Config.config.mqttusehassio && process.env.HASSIO_TOKEN && process.env.HASSIO_TOKEN.length
                    ? Config.config.mqttusehassio
                    : process.env.HASSIO_TOKEN != undefined && process.env.HASSIO_TOKEN.length > 0;
            Config.config.supervisor_host = Config.config.supervisor_host ? Config.config.supervisor_host : 'supervisor';
        }
        else {
            log.log(specification_1.LogLevelEnum.notice, 'No config file found ');
            Config.config = structuredClone(Config.newConfig);
        }
        return structuredClone(Config.config);
    }
    static getAuthStatus() {
        return {
            registered: Config.config.mqttusehassio ||
                Config.config.noAuthentication ||
                (Config.config.username != undefined && Config.config.password != undefined),
            hassiotoken: Config.config.mqttusehassio ? Config.config.mqttusehassio : false,
            noAuthentication: Config.config.noAuthentication ? Config.config.noAuthentication : false,
            mqttConfigured: false,
            preSelectedBusId: bus_1.Bus.getBusses().length == 1 ? bus_1.Bus.getBusses()[0].getId() : undefined,
        };
    }
    async readGetResponse(res) {
        return new Promise((resolve, reject) => {
            let lbuffers = [];
            res.on('data', (chunk) => lbuffers.push(chunk));
            res.on('end', () => {
                try {
                    if (res.statusCode && res.statusCode < 299) {
                        let lbuffer = Buffer.concat(lbuffers);
                        let json = JSON.parse(lbuffer.toString());
                        resolve(json);
                    }
                    else {
                        // http Error
                        reject(lbuffers);
                    }
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
    static executeHassioGetRequest(url, next, reject) {
        // This method can be called before configuration. It can't use config.hassio
        let hassiotoken = process.env.HASSIO_TOKEN;
        if (!hassiotoken || hassiotoken.length == 0)
            throw new Error('ENV: HASSIO_TOKEN not defined');
        const timer = setTimeout(() => {
            clearTimeout(timer);
            reject(new Error('TIMEOUT(' + HASSIO_TIMEOUT + 'ms)'));
        }, HASSIO_TIMEOUT /* ms */);
        try {
            fetch('http://' + Config.getConfiguration().supervisor_host + url, {
                headers: {
                    authorization: 'Bearer ' + hassiotoken,
                    accept: 'application/json',
                },
            })
                .then((res) => {
                clearTimeout(timer);
                if (res)
                    res
                        .json()
                        .then((obj) => {
                        if (obj)
                            if (obj.data)
                                next(obj);
                            else if (obj.result == 'error')
                                reject(new Error('HASSIO: ' + obj.message));
                            else
                                reject(new Error('get' + url + ' expected data root object: ' + JSON.stringify(obj)));
                    })
                        .catch((reason) => {
                        let msg = 'supervisor call ' + url + ' failed ' + JSON.stringify(reason) + ' ' + res.headers.get('content-type');
                        log.log(specification_1.LogLevelEnum.error, msg);
                        reject(new Error(msg));
                    });
            })
                .catch((reason) => {
                clearTimeout(timer);
                log.log(specification_1.LogLevelEnum.error, JSON.stringify(reason));
                reject(reason);
            });
        }
        catch (e) {
            log.log(specification_1.LogLevelEnum.error, e.message);
        }
    }
    validateHassioToken(hassiotoken, next, reject) {
        if (!hassiotoken || hassiotoken.length == 0)
            throw new Error('ENV: HASSIO_TOKEN not defined');
        fetch('http://supervisor/hardware/info', {
            headers: {
                authorization: 'Bearer ' + hassiotoken,
                accept: 'application/json',
            },
        })
            .then((res) => {
            if (res.status >= 200 && res.status < 300)
                next();
            else {
                res.json().then((e) => {
                    log.log(specification_1.LogLevelEnum.error, 'Hassio validation error: ' + JSON.stringify(e));
                    reject();
                });
            }
        })
            .catch((e) => {
            log.log(specification_1.LogLevelEnum.error, e.message);
        });
    }
    static readCertfile(filename) {
        if (filename && Config.sslDir) {
            let fn = (0, path_1.join)(Config.sslDir, filename);
            if (fs.existsSync(fn))
                return fs.readFileSync(fn, { encoding: 'utf8' }).toString();
        }
        return undefined;
    }
    static updateMqttTlsConfig(config) {
        if (config && config.mqttconnect) {
            ;
            config.mqttconnect.key = this.readCertfile(config.mqttkeyFile);
            config.mqttconnect.ca = this.readCertfile(config.mqttcaFile);
            config.mqttconnect.cert = this.readCertfile(config.mqttcertFile);
        }
    }
    async getMqttLoginFromHassio() {
        return new Promise((resolve, reject) => {
            try {
                Config.executeHassioGetRequest('/services/mqtt', (mqtt) => {
                    let config = Config.getConfiguration();
                    config.mqttconnect = mqtt.data;
                    if (config.mqttconnect.mqttserverurl == undefined &&
                        config.mqttconnect.host != undefined &&
                        config.mqttconnect.port != undefined)
                        config.mqttconnect.mqttserverurl =
                            (config.mqttconnect.ssl ? 'mqtts' : 'mqtt') +
                                '://' +
                                config.mqttconnect.host +
                                ':' +
                                config.mqttconnect.port;
                    if (mqtt.data.ssl)
                        Config.updateMqttTlsConfig(config);
                    delete config.mqttconnect.ssl;
                    delete config.mqttconnect.protocol;
                    delete config.mqttconnect.addon;
                    debugAddon('getMqttLoginFromHassio: Read MQTT login data from Hassio');
                    config.mqttconnect.connectTimeout = DEFAULT_MQTT_CONNECT_TIMEOUT;
                    resolve(config.mqttconnect);
                }, reject);
            }
            catch (e) {
                debugAddon('getMqttLoginFromHassio: failed to read MQTT login data from Hassio ' + e.message);
                reject(e);
            }
        });
    }
    async getMqttConnectOptions() {
        return new Promise((resolve, reject) => {
            let config = Config.getConfiguration();
            if (config.mqttusehassio) {
                this.getMqttLoginFromHassio().then((mqttFromHassio) => {
                    resolve(mqttFromHassio);
                }, (reason) => {
                    reject(reason);
                });
            }
            else {
                let config = Config.getConfiguration();
                Config.updateMqttTlsConfig(config);
                if (!Config.config.mqttconnect.mqttserverurl)
                    reject('Configuration problem: no mqttserverurl defined');
                else if (!Config.config.mqttconnect.username)
                    reject('Configuration problem: no mqttuser defined');
                else if (!Config.config.mqttconnect.password)
                    reject('Configuration problem: no mqttpassword defined');
                else
                    resolve(Config.getConfiguration().mqttconnect);
            }
        });
    }
    static isMqttConfigured(mqttClient) {
        return mqttClient != undefined && mqttClient.mqttserverurl != undefined;
    }
    readYamlAsync() {
        return new Promise((resolve, reject) => {
            try {
                debugger;
                if (!Config.yamlDir || Config.yamlDir.length == 0) {
                    log.log(specification_1.LogLevelEnum.error, 'Yamldir not defined in command line');
                }
                if (!fs.existsSync(Config.yamlDir)) {
                    log.log(specification_1.LogLevelEnum.notice, 'configuration directory  not found ' + process.cwd() + '/' + Config.yamlDir);
                    Config.config = structuredClone(Config.newConfig);
                    resolve();
                }
                debug('yamlDir: ' + Config.yamlDir + ' ' + process.argv.length);
                var yamlFile = Config.getConfigPath();
                if (!fs.existsSync(yamlFile)) {
                    log.log(specification_1.LogLevelEnum.notice, 'configuration file  not found ' + yamlFile);
                    Config.config = structuredClone(Config.newConfig);
                }
                else {
                    var secretsFile = Config.yamlDir + '/local/secrets.yaml';
                    var src = fs.readFileSync(yamlFile, { encoding: 'utf8' });
                    if (fs.existsSync(secretsFile)) {
                        var matches;
                        var secrets = (0, yaml_1.parse)(fs.readFileSync(secretsFile, { encoding: 'utf8' }));
                        let srcLines = src.split('\n');
                        src = '';
                        srcLines.forEach((line) => {
                            const r1 = /\"*!secret ([a-zA-Z0-9-_]*)\"*/g;
                            matches = line.matchAll(r1);
                            let skipLine = false;
                            for (const match of matches) {
                                let key = match[1];
                                if (secrets[key] && secrets[key].length) {
                                    line = line.replace(match[0], '"' + secrets[key] + '"');
                                }
                                else {
                                    skipLine = true;
                                    if (!secrets[key])
                                        debug('no entry in secrets file for ' + key + ' line will be ignored');
                                    else
                                        debug('secrets file entry contains !secret for ' + key + ' line will be ignored');
                                }
                            }
                            if (!skipLine)
                                src = src.concat(line, '\n');
                        });
                    }
                    Config.config = (0, yaml_1.parse)(src);
                    if (Config.config.debugComponents && Config.config.debugComponents.length)
                        debug_1.default.enable(Config.config.debugComponents);
                    if (Config.yamlDir.length == 0)
                        log.log(specification_1.LogLevelEnum.error, 'yamlDir not set');
                    else if (Config.config)
                        Config.config.filelocation = Config.yamlDir;
                    else {
                        log.log(specification_1.LogLevelEnum.error, 'config file not parsed "' + src + '"');
                    }
                }
                if (!Config.config || !Config.config.mqttconnect || !Config.isMqttConfigured(Config.config.mqttconnect)) {
                    this.getMqttConnectOptions()
                        .then((mqttLoginData) => {
                        Config.mqttHassioLoginData = mqttLoginData;
                        resolve();
                    })
                        .catch((reason) => {
                        log.log(specification_1.LogLevelEnum.error, 'Unable to connect to mqtt ' + reason);
                        Config.config.mqttusehassio = false;
                        // This should not stop the application
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            }
            catch (error) {
                log.log(specification_1.LogLevelEnum.error, 'readyaml failed: ' + error.message);
                throw error;
                // Expected output: ReferenceError: nonExistentFunction is not defined
                // (Note: the exact output may be browser-dependent)
            }
        });
    }
    // set the base file for relative includes
    readYaml() {
        this.readYamlAsync
            .bind(this)()
            .then(() => { })
            .catch((reason) => {
            log.log(specification_1.LogLevelEnum.error, 'readYaml failed ' + reason);
        });
    }
    writeConfiguration(config) {
        let cpConfig = structuredClone(config);
        Config.config = config;
        if (cpConfig.debugComponents && cpConfig.debugComponents.length)
            debug_1.default.enable(cpConfig.debugComponents);
        let secrets = {};
        if (cpConfig.mqttconnect.password) {
            ;
            secrets['mqttpassword'] = cpConfig.mqttconnect.password;
            cpConfig.mqttconnect.password = '!secret mqttpassword';
        }
        if (cpConfig.mqttconnect.username) {
            ;
            secrets['mqttuser'] = cpConfig.mqttconnect.username;
            cpConfig.mqttconnect.username = '!secret mqttuser';
        }
        if (cpConfig.githubPersonalToken) {
            ;
            secrets['githubPersonalToken'] = cpConfig.githubPersonalToken;
            cpConfig.githubPersonalToken = '!secret githubPersonalToken';
        }
        if (cpConfig.username) {
            ;
            secrets['username'] = cpConfig.username;
            cpConfig.username = '!secret username';
        }
        if (cpConfig.password) {
            ;
            secrets['password'] = cpConfig.password;
            cpConfig.password = '!secret password';
        }
        let filename = Config.getConfigPath();
        let dir = path.dirname(filename);
        if (!fs.existsSync(dir))
            fs.mkdirSync(dir, { recursive: true });
        let s = (0, yaml_1.stringify)(cpConfig);
        fs.writeFileSync(filename, s, { encoding: 'utf8' });
        s = (0, yaml_1.stringify)(secrets);
        fs.writeFileSync(this.getSecretsPath(), s, { encoding: 'utf8' });
    }
    static getConfigPath() {
        return Config.yamlDir + '/local/modbus2mqtt.yaml';
    }
    getSecretsPath() {
        return Config.yamlDir + '/local/secrets.yaml';
    }
    static setFakeModbus(newMode) {
        Config.config.fakeModbus = newMode;
    }
    static getFileNameFromSlaveId(slaveid) {
        return 's' + slaveid;
    }
    static createZipFromLocal(_filename, r) {
        return new Promise((resolve, reject) => {
            let archive = new adm_zip_1.default();
            let dir = Config.getLocalDir();
            let files = fs.readdirSync(Config.getLocalDir(), { recursive: true });
            files.forEach((file) => {
                let p = (0, path_1.join)(dir, file);
                if (fs.statSync(p).isFile() && file.indexOf('secrets.yaml') < 0)
                    archive.addLocalFile(p, path.dirname(file));
            });
            r.write(archive.toBuffer());
            r.end(() => {
                resolve();
            });
        });
    }
}
exports.Config = Config;
function getSpecificationImageOrDocumentUrl(rootUrl, specName, url) {
    let fn = (0, specification_shared_1.getBaseFilename)(url);
    let rc = '';
    if (rootUrl) {
        let append = '/';
        if (rootUrl.endsWith('/'))
            append = '';
        rc = rootUrl + append + (0, path_1.join)(exports.filesUrlPrefix, specName, fn);
    }
    else
        rc = '/' + (0, path_1.join)(exports.filesUrlPrefix, specName, fn);
    return rc;
}
//# sourceMappingURL=config.js.map