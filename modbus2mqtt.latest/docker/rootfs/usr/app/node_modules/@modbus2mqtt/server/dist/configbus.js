"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigBus = void 0;
const tslib_1 = require("tslib");
const server_shared_1 = require("@modbus2mqtt/server.shared");
const specification_1 = require("@modbus2mqtt/specification");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const yaml_1 = require("yaml");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const path_1 = require("path");
const config_1 = require("./config");
const mqttdiscover_1 = require("./mqttdiscover");
const serialport_1 = require("serialport/dist/serialport");
const log = new specification_1.Logger('config');
const debug = (0, debug_1.default)('configbus');
class ConfigBus {
    static { this.listeners = []; }
    static addListener(event, listener) {
        ConfigBus.listeners.push({ event: event, listener: listener });
    }
    static emitSlaveEvent(event, arg) {
        let rc = mqttdiscover_1.MqttDiscover.addSpecificationToSlave(arg);
        ConfigBus.listeners.forEach((eventListener) => {
            if (eventListener.event == event)
                eventListener.listener(rc)
                    .then(() => {
                    debug('Event listener executed');
                })
                    .catch((e) => {
                    log.log(specification_1.LogLevelEnum.error, 'Unable to call event listener: ' + e.message);
                });
        });
    }
    static emitBusEvent(event, arg) {
        ConfigBus.listeners.forEach((eventListener) => {
            if (eventListener.event == event)
                eventListener.listener(arg);
        });
    }
    static getBussesProperties() {
        return ConfigBus.busses;
    }
    static readBusses() {
        ConfigBus.busses = [];
        let busDir = config_1.Config.yamlDir + '/local/busses';
        let oneBusFound = false;
        if (fs.existsSync(busDir)) {
            let busDirs = fs.readdirSync(busDir, {
                withFileTypes: true,
            });
            busDirs.forEach((de) => {
                if (de.isDirectory() && de.name.startsWith('bus.')) {
                    let busid = Number.parseInt(de.name.substring(4));
                    let busYaml = (0, path_1.join)(de.path, de.name, 'bus.yaml');
                    let connectionData;
                    if (fs.existsSync(busYaml)) {
                        var src = fs.readFileSync(busYaml, {
                            encoding: 'utf8',
                        });
                        try {
                            connectionData = (0, yaml_1.parse)(src);
                            ConfigBus.busses.push({
                                busId: busid,
                                connectionData: connectionData,
                                slaves: [],
                            });
                            oneBusFound = true;
                            let devFiles = fs.readdirSync(config_1.Config.yamlDir + '/local/busses/' + de.name);
                            devFiles.forEach(function (file) {
                                if (file.endsWith('.yaml') && file !== 'bus.yaml') {
                                    var src = fs.readFileSync(config_1.Config.yamlDir + '/local/busses/' + de.name + '/' + file, {
                                        encoding: 'utf8',
                                    });
                                    var o = (0, yaml_1.parse)(src);
                                    if (o.specificationid && o.specificationid.length) {
                                        ConfigBus.busses[ConfigBus.busses.length - 1].slaves.push(o);
                                        ConfigBus.emitSlaveEvent(config_1.ConfigListenerEvent.addSlave, new server_shared_1.Slave(busid, o, config_1.Config.getConfiguration().mqttbasetopic));
                                    }
                                }
                            });
                        }
                        catch (e) {
                            log.log(specification_1.LogLevelEnum.error, 'Unable to parse bus os slave file: ' + busYaml + 'error:' + e.message);
                        }
                    }
                }
            });
        }
        if (!oneBusFound) {
            this.listDevices((devices) => {
                if (devices && devices.length) {
                    let usb = devices.find((dev) => dev.toLocaleLowerCase().indexOf('usb') >= 0);
                    if (usb)
                        ConfigBus.addBusProperties({
                            serialport: usb,
                            timeout: specification_shared_1.BUS_TIMEOUT_DEFAULT,
                            baudrate: 9600,
                        });
                    else
                        ConfigBus.addBusProperties({
                            serialport: devices[0],
                            timeout: specification_shared_1.BUS_TIMEOUT_DEFAULT,
                            baudrate: 9600,
                        });
                }
                else
                    ConfigBus.addBusProperties({
                        serialport: '/dev/ttyACM0',
                        timeout: specification_shared_1.BUS_TIMEOUT_DEFAULT,
                        baudrate: 9600,
                    });
            }, () => {
                ConfigBus.addBusProperties({
                    serialport: '/dev/ttyACM0',
                    timeout: specification_shared_1.BUS_TIMEOUT_DEFAULT,
                    baudrate: 9600,
                });
            });
        }
        debug('config: busses.length: ' + ConfigBus.busses.length);
    }
    getInstance() {
        ConfigBus.busses = ConfigBus.busses && ConfigBus.busses.length > 0 ? ConfigBus.busses : [];
        return new ConfigBus();
    }
    static addBusProperties(connection) {
        let maxBusId = -1;
        ConfigBus.busses.forEach((b) => {
            if (b.busId > maxBusId)
                maxBusId = b.busId;
        });
        maxBusId++;
        log.log(specification_1.LogLevelEnum.notice, 'AddBusProperties: ' + maxBusId);
        let busArrayIndex = ConfigBus.busses.push({
            busId: maxBusId,
            connectionData: connection,
            slaves: [],
        }) - 1;
        let busDir = config_1.Config.yamlDir + '/local/busses/bus.' + maxBusId;
        if (!fs.existsSync(busDir)) {
            fs.mkdirSync(busDir, { recursive: true });
            debug('creating slaves path: ' + busDir);
        }
        let src = (0, yaml_1.stringify)(connection);
        fs.writeFileSync((0, path_1.join)(busDir, 'bus.yaml'), src, { encoding: 'utf8' });
        return ConfigBus.busses[busArrayIndex];
    }
    static updateBusProperties(bus, connection) {
        bus.connectionData = connection;
        let busDir = config_1.Config.yamlDir + '/local/busses/bus.' + bus.busId;
        if (!fs.existsSync(busDir)) {
            fs.mkdirSync(busDir, { recursive: true });
            debug('creating slaves path: ' + busDir);
        }
        let src = (0, yaml_1.stringify)(connection);
        fs.writeFileSync((0, path_1.join)(busDir, 'bus.yaml'), src, { encoding: 'utf8' });
        return bus;
    }
    static deleteBusProperties(busid) {
        let idx = ConfigBus.busses.findIndex((b) => b.busId == busid);
        if (idx >= 0) {
            ConfigBus.emitBusEvent(config_1.ConfigListenerEvent.deleteBus, busid);
            let busDir = config_1.Config.yamlDir + '/local/busses/bus.' + busid;
            ConfigBus.busses.splice(idx, 1);
            fs.rmSync(busDir, { recursive: true });
        }
    }
    static async filterAllslaves(busid, specFunction) {
        let addresses = new Set();
        for (let slave of ConfigBus.busses[busid].slaves) {
            for (let addr of specFunction(slave))
                addresses.add(addr);
        }
        return addresses;
    }
    static getslavePath(busid, slave) {
        return config_1.Config.yamlDir + '/local/busses/bus.' + busid + '/s' + slave.slaveid + '.yaml';
    }
    static writeslave(busid, slave) {
        // Make sure slaveid is unique
        let oldFilePath = ConfigBus.getslavePath(busid, slave);
        let filename = config_1.Config.getFileNameFromSlaveId(slave.slaveid);
        let newFilePath = ConfigBus.getslavePath(busid, slave);
        let dir = path.dirname(newFilePath);
        if (!fs.existsSync(dir))
            try {
                fs.mkdirSync(dir, { recursive: true });
            }
            catch (e) {
                debug('Unable to create directory ' + dir + ' + e');
                throw e;
            }
        let o = structuredClone(slave);
        for (var prop in o) {
            if (Object.prototype.hasOwnProperty.call(o, prop)) {
                let deletables = ['specification', 'durationOfLongestModbusCall', 'triggerPollTopic', 'modbusErrorStatistic'];
                if (deletables.includes(prop))
                    delete o[prop];
            }
        }
        if (o.noDiscovery != undefined && o.noDiscovery == false)
            delete o.noDiscovery;
        if (o.noDiscoverEntities != undefined && o.noDiscoverEntities.length == 0)
            delete o.noDiscoverEntities;
        let s = (0, yaml_1.stringify)(o);
        fs.writeFileSync(newFilePath, s, { encoding: 'utf8' });
        if (oldFilePath !== newFilePath && fs.existsSync(oldFilePath))
            fs.unlink(oldFilePath, (err) => {
                debug('writeslave: Unable to delete ' + oldFilePath + ' ' + err);
            });
        if (slave.specificationid) {
            if (slave.specificationid == '_new')
                new specification_1.ConfigSpecification().deleteNewSpecificationFiles();
            else {
                let spec = specification_1.ConfigSpecification.getSpecificationByFilename(slave.specificationid);
                slave.specification = spec;
            }
            ConfigBus.emitSlaveEvent(config_1.ConfigListenerEvent.updateSlave, new server_shared_1.Slave(busid, slave, config_1.Config.getConfiguration().mqttbasetopic));
        }
        else
            debug('No Specification found for slave: ' + filename + ' specification: ' + slave.specificationid);
        return slave;
    }
    static getSlave(busid, slaveid) {
        if (ConfigBus.busses.length <= busid) {
            debug('Config.getslave: unknown bus');
            return undefined;
        }
        let rc = ConfigBus.busses[busid].slaves.find((dev) => {
            return dev.slaveid === slaveid;
        });
        if (!rc)
            debug('slaves.length: ' + ConfigBus.busses[busid].slaves.length);
        for (let dev of ConfigBus.busses[busid].slaves) {
            debug(dev.name);
        }
        return rc;
    }
    static getslaveBySlaveId(busid, slaveId) {
        let rc = ConfigBus.busses[busid].slaves.find((dev) => {
            return dev.slaveid === slaveId;
        });
        return rc;
    }
    static deleteSlave(busid, slaveid) {
        let bus = ConfigBus.busses.find((bus) => bus.busId == busid);
        if (bus != undefined) {
            debug('DELETE /slave slaveid' + busid + '/' + slaveid + ' number of slaves: ' + bus.slaves.length);
            let found = false;
            for (let idx = 0; idx < bus.slaves.length; idx++) {
                let dev = bus.slaves[idx];
                if (dev.slaveid === slaveid) {
                    found = true;
                    if (fs.existsSync(ConfigBus.getslavePath(busid, dev)))
                        fs.unlink(ConfigBus.getslavePath(busid, dev), (err) => {
                            if (err)
                                debug(err);
                        });
                    ConfigBus.emitSlaveEvent(config_1.ConfigListenerEvent.deleteSlave, new server_shared_1.Slave(busid, dev, config_1.Config.getConfiguration().mqttbasetopic));
                    bus.slaves.splice(idx, 1);
                    debug('DELETE /slave finished ' + slaveid + ' number of slaves: ' + bus.slaves.length);
                    return;
                }
            }
            if (!found)
                debug('slave not found for deletion ' + slaveid);
        }
        else {
            let msg = 'Unable to delete slave. Check server log for details';
            log.log(specification_1.LogLevelEnum.error, msg + ' busid ' + busid + ' not found');
            throw new Error(msg);
        }
    }
    static listDevicesUdev(next, reject) {
        serialport_1.SerialPort.list()
            .then((portInfo) => {
            let devices = [];
            portInfo.forEach((port) => {
                devices.push(port.path);
            });
            next(devices);
        })
            .catch((error) => {
            reject(error);
        });
    }
    static grepDevices(bodyObject) {
        var devices = bodyObject.data.devices;
        var rc = [];
        devices.forEach((device) => {
            if (device.subsystem === 'tty')
                try {
                    fs.accessSync(device.dev_path, fs.constants.R_OK);
                    rc.push(device.dev_path);
                }
                catch (error) {
                    log.log(specification_1.LogLevelEnum.error, 'Permission denied for read serial device %s', device.dev_path);
                }
        });
        return rc;
    }
    static listDevicesHassio(next, reject) {
        config_1.Config.executeHassioGetRequest('/hardware/info', (dev) => {
            next(ConfigBus.grepDevices(dev));
        }, reject);
    }
    static listDevices(next, reject) {
        try {
            ConfigBus.listDevicesHassio(next, (_e) => {
                this.listDevicesUdev(next, reject);
            });
        }
        catch (e) {
            try {
                this.listDevicesUdev(next, reject);
            }
            catch (e) {
                next([]);
            }
        }
    }
}
exports.ConfigBus = ConfigBus;
//# sourceMappingURL=configbus.js.map