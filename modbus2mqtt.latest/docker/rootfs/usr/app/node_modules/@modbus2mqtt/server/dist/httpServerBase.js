"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpServerBase = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const express = tslib_1.__importStar(require("express"));
const bodyparser = tslib_1.__importStar(require("body-parser"));
const config_1 = require("./config");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const path_1 = require("path");
const node_html_parser_1 = require("node-html-parser");
const fs = tslib_1.__importStar(require("fs"));
const specification_1 = require("@modbus2mqtt/specification");
const mqttdiscover_1 = require("./mqttdiscover");
const debug = (0, debug_1.default)('HttpServerBase');
const debugUrl = (0, debug_1.default)('HttpServerBaseUrl');
const log = new specification_1.Logger('HttpServerBase');
// import cors from 'cors';
//import { IfileSpecification } from './ispecification';
class HttpServerBase {
    constructor(angulardir = '.') {
        this.angulardir = angulardir;
        this.languages = ['en'];
        this.statics = new Map();
        this.ingressUrl = '/';
        this.app = require('express')();
    }
    returnResult(req, res, code, message, cb, object = undefined) {
        debugUrl('end: ' + req.path);
        if (code >= 299) {
            log.log(specification_1.LogLevelEnum.error, '%s: Http Result: %d %s', req.url, code, message);
        }
        else
            debug(req.url + ' :' + specification_shared_1.HttpErrorsEnum[code]);
        if (object != undefined)
            debug('Info: ' + object);
        try {
            res.statusCode = code;
            res.end(message);
        }
        catch (e) {
            log.log(specification_1.LogLevelEnum.error, e.message);
            JSON.stringify(e);
        }
    }
    listen(listenFunction) {
        this.server = this.app.listen(config_1.Config.getConfiguration().httpport, listenFunction);
    }
    close() {
        if (this.server)
            this.server.close();
    }
    static getAuthTokenFromHeader(req) {
        let authHeader = undefined;
        if (req.header)
            authHeader = req.header('Authorization');
        if (authHeader) {
            let tokenPos = authHeader.indexOf(' ') + 1;
            return authHeader.substring(tokenPos);
        }
        return undefined;
    }
    static getAuthTokenFromUrl(url) {
        let parts = url.split('/');
        let apiIdx = parts.findIndex((part) => ['api', 'download'].includes(part));
        if (apiIdx >= 2) {
            return parts[apiIdx - 1];
        }
        return undefined;
    }
    static validateUserToken(req, token) {
        if (token == undefined) {
            token = HttpServerBase.getAuthTokenFromUrl(req.url);
            if (token == undefined)
                return config_1.MqttValidationResult.error;
            req.url = req.url.replace(token + '/', '');
        }
        return config_1.Config.validateUserToken(token);
    }
    getDirectoryForLanguage(req) {
        let lang = req.acceptsLanguages(['en', 'fr']);
        if (!lang)
            lang = 'en';
        return this.statics.get(lang);
    }
    initStatics() {
        fs.readdirSync(this.angulardir).forEach((langDir) => {
            let lang = langDir.replace(/-.*/g, '');
            let dir = langDir;
            this.statics.set(lang, dir);
        });
        if (this.statics.size > 0)
            this.languages = Array.from(this.statics.keys());
    }
    get(url, func) {
        debugUrl('start get' + url);
        this.app.get(url, (req, response) => {
            debug(req.method + ': ' + req.originalUrl);
            func(req, response);
        });
    }
    post(url, func) {
        debugUrl('start post' + url);
        this.app.post(url, (req, response) => {
            debug(req.method + ': ' + req.originalUrl);
            func(req, response);
        });
    }
    delete(url, func) {
        debugUrl('start delete' + url);
        this.app.delete(url, (req, response) => {
            debug(req.method + ': ' + req.originalUrl);
            func(req, response);
        });
    }
    validate() { }
    authenticate(req, res, next) {
        //  req.header('')
        // All api calls and a user registration when a user is already registered needs authorization
        debugUrl('authenticate' + req.url);
        let config = config_1.Config.getConfiguration();
        let token = HttpServerBase.getAuthTokenFromUrl(req.url);
        if (token != undefined)
            req.url = req.url.replace(token + '/', '');
        else
            token = HttpServerBase.getAuthTokenFromHeader(req);
        let slaveTopicFound = null !=
            mqttdiscover_1.MqttDiscover.getInstance()
                .getSlaveBaseTopics()
                .find((tp) => tp.startsWith(req.url.substring(1)));
        if (req.url.indexOf('/api/') >= 0 ||
            req.url.indexOf('/user/register') >= 0 ||
            req.url.indexOf('/download/') >= 0 ||
            slaveTopicFound) {
            let authStatus = config_1.Config.getAuthStatus();
            if (authStatus.hassiotoken) {
                let address = req.socket.address().address;
                if (!address ||
                    (address.indexOf('172.30.33') < 0 &&
                        address.indexOf('172.30.32') < 0 &&
                        address.indexOf('127.0.0.1') < 0 &&
                        address.indexOf('::1') < 0)) {
                    log.log(specification_1.LogLevelEnum.warn, 'Denied: IP Address is not allowed ' + address);
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrForbidden, 'Unauthorized (See server log)');
                    return;
                }
                debug('Supervisor: validate hassio token');
                next();
                return;
            }
            else {
                if (!config.password || (config.password.length == 0 && req.url.indexOf("/user/register" /* apiUri.userRegister */) >= 0)) {
                    next();
                    return;
                }
                switch (config_1.Config.validateUserToken(token)) {
                    case config_1.MqttValidationResult.OK:
                        next();
                        return;
                    case config_1.MqttValidationResult.tokenExpired:
                        log.log(specification_1.LogLevelEnum.error, 'Token expired');
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrUnauthorized, 'Token expired');
                        return;
                    default:
                        // case MqttValidationResult.error:
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrForbidden, 'Unauthorized (See server log)');
                        return;
                }
            }
            // Check addon access
        }
        // No authentication required
        next();
        return;
    }
    initApp() { }
    init() {
        return new Promise((resolve, reject) => {
            try {
                config_1.Config.executeHassioGetRequest('/addons/self/info', (info) => {
                    //this.ingressUrl = join("/hassio/ingress/", info.data.slug);
                    this.ingressUrl = info.data.ingress_entry;
                    log.log(specification_1.LogLevelEnum.notice, 'Hassio authentication successful url:' + this.ingressUrl);
                    this.initBase();
                    resolve();
                }, (e) => {
                    log.log(specification_1.LogLevelEnum.warn, 'Hassio authentication failed ' + e.message);
                    this.initBase();
                    resolve();
                });
            }
            catch (e) {
                this.initBase();
                resolve();
            }
        });
    }
    compareIngressUrl(req) {
        let h = req.header('X-Ingress-Path');
        if (h && h != this.ingressUrl) {
            log.log(specification_1.LogLevelEnum.error, 'Invalid X-Ingress-Path in header expected: ' + this.ingressUrl + 'got: ' + h);
        }
    }
    sendIndexFile(req, res) {
        this.compareIngressUrl(req);
        let dir = this.getDirectoryForLanguage(req);
        let file = (0, path_1.join)(this.angulardir, dir, 'index.html');
        let content = fs.readFileSync(file).toString();
        let htmlDom = (0, node_html_parser_1.parse)(content.toString());
        if (this.ingressUrl && content && htmlDom) {
            let base = htmlDom.querySelector('base');
            base?.setAttribute('href', (0, path_1.join)('/', this.ingressUrl, '/'));
            content = htmlDom.toString();
            res.status(200).setHeader('Content-Type', 'text/html').send(htmlDom.toString());
        }
        else
            res.status(401).setHeader('Content-Type', 'text/html').send('Invalid index.html file ');
    }
    /*
     * All angular files are language specific.
     * This method checks if the url is available in a language dependant angular directory
     * E.g. "/en-US/index.html". In this case it returns the files
     * If it's the index file, the base href will be replaced
     */
    processStaticAngularFiles(req, res, next) {
        try {
            let dir = this.getDirectoryForLanguage(req);
            if (dir) {
                res.removeHeader('Content-Type');
                let file = (0, path_1.join)(this.angulardir, dir, req.url);
                if (fs.existsSync(file) && !fs.lstatSync(file).isDirectory()) {
                    if (req.url.indexOf('index.html') >= 0) {
                        this.sendIndexFile(req, res);
                        return;
                    }
                    else {
                        res.contentType((0, path_1.basename)(req.url));
                        let content = fs.readFileSync(file);
                        res.setHeader('Content-Length', content.byteLength);
                        res.status(200);
                        res.send(content);
                        return;
                    }
                }
            }
            next();
            return;
        }
        catch (e) {
            res.status(401).setHeader('Content-Type', 'text/html').send('No or invalid index.html file ');
        }
    }
    processAll(req, res, next) {
        this.sendIndexFile(req, res);
    }
    initBase() {
        this.initStatics();
        //this.app.use(cors);
        this.app.use(bodyparser.json());
        this.app.use(bodyparser.urlencoded({ extended: true }));
        this.app.use(express.json());
        //@ts-ignore
        this.app.use(function (_undefined, res, next) {
            //            res.setHeader('charset', 'utf-8')
            debug('Authenticate');
            res.setHeader('Access-Control-Allow-Methods', 'POST, PUT, OPTIONS, DELETE, GET');
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, X-Accel-Buffering, Accept,Connection,Cache-Control,x-access-token');
            res.setHeader('Access-Control-Allow-Credentials', 'true');
            next();
        });
        // angular files have full path including language e.G. /en-US/polyfill.js
        this.app.use(this.authenticate.bind(this));
        this.app.use(express.static(this.angulardir));
        this.app.get('/', (req, res, next) => {
            res.redirect('index.html');
        });
        this.initApp();
        this.app.use(this.processStaticAngularFiles.bind(this));
        this.app.all(/.*/, this.processAll.bind(this));
        this.app.on('connection', function (socket) {
            socket.setTimeout(2 * 60 * 1000);
            // 30 second timeout. Change this as you see fit.
        });
    }
}
exports.HttpServerBase = HttpServerBase;
//# sourceMappingURL=httpServerBase.js.map