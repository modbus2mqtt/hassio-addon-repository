"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpServer = void 0;
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const os_1 = tslib_1.__importDefault(require("os"));
const express = tslib_1.__importStar(require("express"));
const specification_1 = require("@modbus2mqtt/specification");
const config_1 = require("./config");
const modbus_1 = require("./modbus");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const path_1 = tslib_1.__importStar(require("path"));
const multer_1 = tslib_1.__importDefault(require("multer"));
const httpFileUpload_1 = require("./httpFileUpload");
const bus_1 = require("./bus");
const rxjs_1 = require("rxjs");
const fs = tslib_1.__importStar(require("fs"));
const specification_2 = require("@modbus2mqtt/specification");
const translate_1 = require("@google-cloud/translate");
const specification_3 = require("@modbus2mqtt/specification");
const server_shared_1 = require("@modbus2mqtt/server.shared");
const specification_4 = require("@modbus2mqtt/specification");
const httpServerBase_1 = require("./httpServerBase");
const mqttdiscover_1 = require("./mqttdiscover");
const configbus_1 = require("./configbus");
const debug = (0, debug_1.default)('httpserver');
const log = new specification_2.Logger('httpserver');
class HttpServer extends httpServerBase_1.HttpServerBase {
    constructor(angulardir = '.') {
        super(angulardir);
        this.modbusCacheAvailable = false;
    }
    returnResult(req, res, code, message, object = undefined) {
        if (!res.headersSent)
            try {
                res.setHeader('Content-Type', ' application/json');
            }
            catch (e) {
                log.log(specification_2.LogLevelEnum.error, JSON.stringify(e));
            }
        super.returnResult(req, res, code, message, object);
    }
    handleSlaveTopics(req, res, next) {
        let md = mqttdiscover_1.MqttDiscover.getInstance();
        let url = req.url.substring(1);
        let slave = md.getSlave(url);
        if (slave) {
            if (req.method == 'GET' && url.endsWith('/state/')) {
                let md = new modbus_1.Modbus();
                mqttdiscover_1.MqttDiscover.readModbus(slave)?.subscribe((spec) => {
                    let payload = slave.getStatePayload(spec.entities);
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, payload);
                    return;
                });
            }
            else if (req.method == 'GET' && (url.indexOf('/set/') != -1 || url.indexOf('/set/modbus/') != -1)) {
                let idx = url.indexOf('/set/');
                let postLength = 5;
                if (idx == -1) {
                    idx = url.indexOf('/set/modbus/');
                    postLength = 11;
                }
                if (idx == -1)
                    return next(); //should not happen
                md.sendEntityCommandWithPublish(slave, url, url.substring(idx + postLength))
                    .then(() => {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify({ result: 'OK' }));
                })
                    .catch((e) => {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify({ result: e.message }));
                });
            }
            else if (req.method == 'POST' && url.indexOf('/set/') != -1) {
                md.sendCommand(slave, JSON.stringify(req.body))
                    .then(() => {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify({ result: 'OK' }));
                })
                    .catch((e) => {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify({ result: e.message }));
                });
            }
            else
                return next();
        }
        else
            return next();
    }
    setModbusCacheAvailable() {
        this.modbusCacheAvailable = true;
    }
    initApp() {
        let fileLocation = config_1.Config.getConfiguration().filelocation;
        if (fileLocation == undefined)
            log.log(specification_2.LogLevelEnum.error, 'Config Filelocation is not defined');
        else {
            let localdir = (0, path_1.join)(fileLocation, 'local', config_1.filesUrlPrefix);
            let publicdir = (0, path_1.join)(fileLocation, 'public', config_1.filesUrlPrefix);
            this.app.get(/.*/, (req, res, next) => {
                debug(req.url);
                next();
            });
            this.app.use('/' + config_1.filesUrlPrefix, express.static(localdir));
            this.app.use('/' + config_1.filesUrlPrefix, express.static(publicdir));
        }
        this.app.use(this.handleSlaveTopics.bind(this));
        //@ts-ignore
        // app.use(function (err:any, req:any, res:any, next:any) {
        //     res.status(409).json({status: err.status, message: err.message})
        //     next();
        //   });
        this.get("/userAuthenticationStatus" /* apiUri.userAuthenticationStatus */, (req, res) => {
            debug(req.url);
            req.acceptsLanguages();
            let config = config_1.Config.getConfiguration();
            let authHeader = req.header('Authorization');
            let a = config_1.Config.getAuthStatus();
            (a.hasAuthToken = authHeader ? true : false),
                (a.authTokenExpired =
                    authHeader != undefined && HttpServer.validateUserToken(req, undefined) == config_1.MqttValidationResult.tokenExpired);
            if (a.registered && (a.hassiotoken || a.hasAuthToken || a.noAuthentication))
                a.mqttConfigured = config_1.Config.isMqttConfigured(config.mqttconnect);
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(a));
            return;
        });
        this.get("/api/converters" /* apiUri.converters */, (req, res) => {
            debug('(/converters');
            let a = specification_1.ConverterMap.getConverters();
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(a));
            return;
        });
        this.get("/user/login" /* apiUri.userLogin */, (req, res) => {
            debug('(/user/login');
            if (req.query.name && req.query.password) {
                config_1.Config.login(req.query.name, req.query.password)
                    .then((result) => {
                    if (result) {
                        res.statusCode = 200;
                        let a = {
                            result: 'OK',
                            token: result,
                        };
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(a));
                    }
                    else {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrForbidden, '{result: "Forbidden"}');
                    }
                })
                    .catch((err) => {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrForbidden, '{result: "' + err + '"}', err);
                });
            }
            else {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrInvalidParameter, '{result: "Invalid Parameter"}');
            }
        });
        this.post("/user/register" /* apiUri.userRegister */, (req, res) => {
            debug('(/user/register');
            res.statusCode = 200;
            if ((req.body.username && req.body.password) || req.body.noAuthentication) {
                config_1.Config.register(req.body.username, req.body.password, req.body.noAuthentication)
                    .then(() => {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify({ result: 'OK' }));
                })
                    .catch((err) => {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify({ result: err }));
                });
            }
            else {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify({ result: 'Invalid Parameter' }));
            }
        });
        this.get("/api/specsForSlaveId" /* apiUri.specsForSlaveId */, (req, res) => {
            debug(req.url);
            let msg = this.checkBusidSlaveidParameter(req);
            if (msg !== '') {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, msg);
            }
            else {
                let slaveId = Number.parseInt(req.query.slaveid);
                let busid = Number.parseInt(req.query.busid);
                let bus = bus_1.Bus.getBus(busid);
                if (bus) {
                    bus
                        .getAvailableSpecs(slaveId, req.query.showAllPublicSpecs != undefined)
                        .then((result) => {
                        debug('getAvailableSpecs  succeeded');
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(result));
                    })
                        .catch((e) => {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrNotFound, 'specsForSlaveId: ' + e.message);
                    });
                }
            }
        });
        this.get("/api/sslfiles" /* apiUri.sslFiles */, (req, res) => {
            if (config_1.Config.sslDir && config_1.Config.sslDir.length) {
                let result = fs.readdirSync(config_1.Config.sslDir);
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(result));
            }
            else {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrNotFound, 'not found');
            }
        });
        this.get("/api/specification" /* apiUri.specfication */, (req, res) => {
            let spec = req.query.spec;
            if (spec && spec.length > 0) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(specification_4.ConfigSpecification.getSpecificationByFilename(spec)));
            }
            else {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrNotFound, 'not found');
            }
        });
        this.get("/api/nextGithubMergeCheck" /* apiUri.nextCheck */, (req, res) => {
            debug(req.url);
            let nc = specification_3.M2mSpecification.getNextCheck(req.query.spec);
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(nc));
        });
        this.post("/api/nextGithubMergeCheck" /* apiUri.nextCheck */, (req, res) => {
            debug(req.url);
            let nc = specification_3.M2mSpecification.triggerPoll(req.query.spec);
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, 'OK');
        });
        this.get("/api/specifications" /* apiUri.specifications */, (req, res) => {
            debug(req.url);
            let rc = [];
            new specification_4.ConfigSpecification().filterAllSpecifications((spec) => {
                rc.push(specification_3.M2mSpecification.fileToModbusSpecification(spec));
            });
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(rc));
        });
        this.get("/api/specification/fetchpublic" /* apiUri.specificationFetchPublic */, (req, res) => {
            debug(req.url);
            let ghToken = config_1.Config.getConfiguration().githubPersonalToken;
            ghToken = ghToken == undefined ? '' : ghToken;
            new specification_1.M2mGitHub(ghToken, (0, path_1.join)(specification_4.ConfigSpecification.yamlDir, 'public')).fetchPublicFiles();
            new specification_4.ConfigSpecification().readYaml();
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify({ result: 'OK' }));
        });
        this.get("/api/busses" /* apiUri.busses */, (req, res) => {
            debug(req.originalUrl);
            let busses = bus_1.Bus.getBusses();
            let ibs = [];
            busses.forEach((bus) => {
                ibs.push(bus.properties);
            });
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(ibs));
        });
        this.get("/api/bus" /* apiUri.bus */, (req, res) => {
            debug(req.originalUrl);
            res.statusCode = 200;
            if (req.query.busid && req.query.busid.length) {
                let bus = bus_1.Bus.getBus(Number.parseInt(req.query.busid));
                if (bus && bus.properties) {
                    bus.properties;
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(bus.properties));
                    return;
                }
            }
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'invalid Parameter');
        });
        this.get("/api/slaves" /* apiUri.slaves */, (req, res) => {
            debug('listDevices');
            let invParam = () => {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrInvalidParameter, 'Invalid parameter');
                return;
            };
            if (req.query.busid !== undefined) {
                let busid = Number.parseInt(req.query.busid);
                let bus = bus_1.Bus.getBus(busid);
                if (bus) {
                    let slaves = bus.getSlaves();
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(slaves));
                    return;
                }
                else
                    invParam();
            }
            else
                invParam();
        });
        this.get("/api/slave" /* apiUri.slave */, (req, res) => {
            debug('listDevice');
            if (req.query.busid !== undefined && req.query.slaveid !== undefined) {
                let busid = Number.parseInt(req.query.busid);
                let slaveid = Number.parseInt(req.query.slaveid);
                let slave = bus_1.Bus.getBus(busid)?.getSlaveBySlaveId(slaveid);
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(slave));
            }
            else {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrInvalidParameter, 'Invalid parameter');
            }
        });
        this.get("/api/configuration" /* apiUri.configuration */, (req, res) => {
            debug('configuration');
            try {
                let config = config_1.Config.getConfiguration();
                if (config_1.Config.getAuthStatus().hassiotoken)
                    config.rootUrl = 'http://' + os_1.default.hostname() + ':' + config.httpport + '/';
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(config));
            }
            catch (e) {
                log.log(specification_2.LogLevelEnum.error, 'Error getConfiguration: ' + JSON.stringify(e));
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.SrvErrInternalServerError, JSON.stringify(e));
            }
        });
        this.get("/api/modbus/specification" /* apiUri.modbusSpecification */, (req, res) => {
            debug(req.url);
            debug('get specification with modbus data for slave ' + req.query.slaveid);
            let msg = this.checkBusidSlaveidParameter(req);
            if (msg !== '') {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, msg);
                return;
            }
            let bus = bus_1.Bus.getBus(Number.parseInt(req.query.busid));
            if (bus === undefined) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'Bus not found. Id: ' + req.query.busid);
                return;
            }
            let slaveid = Number.parseInt(req.query.slaveid);
            modbus_1.Modbus.getModbusSpecification('http', bus, slaveid, req.query.spec, (e) => {
                log.log(specification_2.LogLevelEnum.error, 'http: get /specification ' + e.message);
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.SrvErrInternalServerError, JSON.stringify('read specification ' + e.message));
            }).subscribe((result) => {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(result));
            });
        });
        this.get("/download/:what" /* apiUri.download */, (req, res) => {
            debug(req.url);
            var downloadMethod;
            var filename = 'local.zip';
            if (req.params.what == 'local')
                downloadMethod = config_1.Config.createZipFromLocal;
            else {
                filename = req.params.what + '.zip';
                downloadMethod = (file, r) => {
                    return new Promise((resolve, reject) => {
                        try {
                            specification_4.ConfigSpecification.createZipFromSpecification(file, r);
                            resolve();
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                };
            }
            res.setHeader('Content-Type', 'application/zip');
            res.setHeader('Content-disposition', 'attachment; filename=' + filename);
            // Tell the browser that this is a zip file.
            downloadMethod(req.params.what, res)
                .then(() => {
                super.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, undefined);
            })
                .catch((e) => {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.SrvErrInternalServerError, JSON.stringify('download Zip ' + req.params.what + e.message));
            });
        });
        this.post("/api/specification/contribute" /* apiUri.specficationContribute */, (req, res) => {
            if (!req.query.spec) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrInvalidParameter, 'specification name not passed');
                return;
            }
            let spec = specification_4.ConfigSpecification.getSpecificationByFilename(req.query.spec);
            let client = new specification_3.M2mSpecification(spec);
            if (spec && spec.status && ![4 /* SpecificationStatus.contributed */, 0 /* SpecificationStatus.published */].includes(spec.status)) {
                client
                    .contribute(req.body.note)
                    .then((response) => {
                    // poll status updates of pull request
                    specification_3.M2mSpecification.startPolling(spec.filename, (e) => {
                        log.log(specification_2.LogLevelEnum.error, e.message);
                    })?.subscribe((pullRequest) => {
                        if (pullRequest.merged)
                            log.log(specification_2.LogLevelEnum.notice, 'Merged ' + pullRequest.pullNumber);
                        else if (pullRequest.closed)
                            log.log(specification_2.LogLevelEnum.notice, 'Closed ' + pullRequest.pullNumber);
                        else
                            debug('Polled pullrequest ' + pullRequest.pullNumber);
                        if (pullRequest.merged || pullRequest.closed)
                            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(response));
                    });
                })
                    .catch((err) => {
                    res.statusCode = specification_shared_1.HttpErrorsEnum.ErrNotAcceptable;
                    if (err.message)
                        res.end(JSON.stringify(err.message));
                    else
                        res.end(JSON.stringify(err));
                    log.log(specification_2.LogLevelEnum.error, JSON.stringify(err));
                });
            }
            else if (spec && spec.status && spec.status == 4 /* SpecificationStatus.contributed */) {
                specification_3.M2mSpecification.startPolling(spec.filename, (e) => {
                    log.log(specification_2.LogLevelEnum.error, e.message);
                });
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrNotAcceptable, 'Specification is already contributed');
            }
        });
        this.post("/api/translate" /* apiUri.translate */, (req, res) => {
            let client = new translate_1.TranslationServiceClient();
            client
                .translateText(req.body)
                .then((response) => {
                let rc = [];
                if (response[0].translations) {
                    response[0].translations.forEach((translation) => {
                        if (translation.translatedText)
                            rc.push(translation.translatedText);
                    });
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(rc));
                }
            })
                .catch((err) => {
                res.statusCode = specification_shared_1.HttpErrorsEnum.ErrNotAcceptable;
                res.end(JSON.stringify(err.message));
                log.log(specification_2.LogLevelEnum.error, JSON.stringify(err.message));
            });
        });
        this.post("/api/validate/mqtt" /* apiUri.validateMqtt */, (req, res) => {
            debug(req.url);
            let config = req.body;
            config_1.Config.updateMqttTlsConfig(config);
            try {
                if (config.mqttconnect == undefined) {
                    this.validateMqttConnectionResult(req, res, false, 'No parameters configured');
                    return;
                }
                let mqttdiscover = mqttdiscover_1.MqttDiscover.getInstance();
                let client = req.body.mqttconnect.mqttserverurl ? req.body.mqttconnect : undefined;
                mqttdiscover.validateConnection(client, (valid, message) => {
                    this.validateMqttConnectionResult(req, res, valid, message);
                });
            }
            catch (err) {
                log.log(specification_2.LogLevelEnum.error, err);
            }
        });
        this.post("/api/configuration" /* apiUri.configuration */, (req, res) => {
            debug('POST: ' + req.url);
            let config = config_1.Config.getConfiguration();
            new config_1.Config().writeConfiguration(req.body);
            config = config_1.Config.getConfiguration();
            specification_4.ConfigSpecification.setMqttdiscoverylanguage(config.mqttdiscoverylanguage, config.githubPersonalToken);
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkNoContent, JSON.stringify(config));
        });
        this.post("/api/bus" /* apiUri.bus */, (req, res) => {
            debug('POST: ' + req.url);
            let busid = Number.parseInt(req.query.busid);
            if (req.query.busid != undefined) {
                let bus = bus_1.Bus.getBus(busid);
                if (bus)
                    bus.updateBus(req.body);
                else {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.SrvErrInternalServerError, 'Bus not found in busses');
                    return;
                }
            }
            else
                busid = bus_1.Bus.addBus(req.body).properties.busId;
            let rc1 = { busid: busid };
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(rc1));
        });
        this.post("/api/modbus/entity" /* apiUri.modbusEntity */, (req, res) => {
            debug(req.url);
            let msg = this.checkBusidSlaveidParameter(req);
            if (msg !== '') {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, msg);
                return;
            }
            else {
                let bus = bus_1.Bus.getBus(Number.parseInt(req.query.busid));
                let entityid = req.query.entityid ? parseInt(req.query.entityid) : undefined;
                let sub = new rxjs_1.Subject();
                let subscription = sub.subscribe((result) => {
                    subscription.unsubscribe();
                    let ent = result.entities.find((e) => e.id == entityid);
                    if (ent) {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(ent));
                        return;
                    }
                    else {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.SrvErrInternalServerError, 'No entity found in specfication');
                        return;
                    }
                });
                modbus_1.Modbus.getModbusSpecificationFromData('http', bus, Number.parseInt(req.query.slaveid), req.body, sub);
            }
        });
        this.post("/api/modbus/write/entity" /* apiUri.writeEntity */, (req, res) => {
            debug(req.url);
            let msg = this.checkBusidSlaveidParameter(req);
            if (msg !== '') {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, msg);
                return;
            }
            else {
                let bus = bus_1.Bus.getBus(Number.parseInt(req.query.busid));
                let mqttValue = req.query.mqttValue;
                let entityid = req.query.entityid ? parseInt(req.query.entityid) : undefined;
                if (entityid && mqttValue)
                    modbus_1.Modbus.writeEntityMqtt(bus, Number.parseInt(req.query.slaveid), req.body, entityid, mqttValue)
                        .then(() => {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, '');
                    })
                        .catch((e) => {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.SrvErrInternalServerError, e);
                    });
                else
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.SrvErrInternalServerError, 'No entity found in specfication');
            }
        });
        this.get("/api/serial/devices" /* apiUri.serialDevices */, (req, res) => {
            debug(req.url);
            configbus_1.ConfigBus.listDevices((devices) => {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(devices));
            }, (error) => {
                // Log the error, but return empty array
                log.log(specification_2.LogLevelEnum.notice, 'listDevices: ' + error.message);
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify([]), error);
            });
        });
        this.post("/api/specification" /* apiUri.specfication */, (req, res) => {
            debug('POST /specification: ' + req.query.busid + '/' + req.query.slaveid);
            let rd = new specification_4.ConfigSpecification();
            let msg = this.checkBusidSlaveidParameter(req);
            if (msg !== '') {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, "{message: '" + msg + "'}");
                return;
            }
            let bus = bus_1.Bus.getBus(Number.parseInt(req.query.busid));
            let slave = bus ? bus.getSlaveBySlaveId(Number.parseInt(req.query.slaveid)) : undefined;
            let originalFilename = req.query.originalFilename ? req.query.originalFilename : null;
            var rc = rd.writeSpecification(req.body, (filename) => {
                if (bus != undefined && slave != undefined) {
                    slave.specificationid = filename;
                    configbus_1.ConfigBus.writeslave(bus.getId(), slave);
                }
            }, originalFilename);
            bus
                ?.getAvailableSpecs(Number.parseInt(req.query.slaveid), false)
                .then(() => {
                debug('Cache updated');
            })
                .catch((e) => {
                debug('getAvailableModbusData failed:' + e.message);
            });
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(rc));
        });
        this.post("/api/specification/validate" /* apiUri.specificationValidate */, (req, res) => {
            if (!req.query.language || req.query.language.length == 0) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify('pass language '));
                return;
            }
            let spec = new specification_3.M2mSpecification(req.body);
            let messages = spec.validate(req.query.language);
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(messages));
        });
        this.get("/api/specification/validate" /* apiUri.specificationValidate */, (req, res) => {
            if (!req.query.language || req.query.language.length == 0) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify('pass language '));
                return;
            }
            if (!req.query.spec || req.query.spec.length == 0) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify('pass specification '));
                return;
            }
            let fspec = specification_4.ConfigSpecification.getSpecificationByFilename(req.query.spec);
            if (!fspec) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, JSON.stringify('specification not found ' + req.query.spec));
                return;
            }
            let spec = new specification_3.M2mSpecification(fspec);
            let messages = spec.validate(req.query.language);
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(messages));
        });
        this.post("/api/slave" /* apiUri.slave */, (req, res) => {
            debug('POST /slave: ' + JSON.stringify(req.body));
            let bus = bus_1.Bus.getBus(Number.parseInt(req.query.busid));
            if (!req.query.busid || !bus) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'Bus not found. Id: ' + req.query.busid);
                return;
            }
            if (req.body.slaveid == undefined) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'Bus Id: ' + req.query.busid + ' Slave Id is not defined');
                return;
            }
            res.setHeader('charset', 'utf-8');
            res.setHeader('Access-Control-Allow-Methods', 'POST, PUT, OPTIONS, DELETE, GET');
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, x-access-token');
            res.setHeader('Access-Control-Allow-Credentials', 'true');
            res.setHeader('Content-Type', 'application/json');
            let rc = bus.writeSlave(req.body);
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(rc));
        });
        this.post("/api/addFilesUrl" /* apiUri.addFilesUrl */, (req, res) => {
            try {
                if (req.query.specification) {
                    if (req.body) {
                        // req.body.documents
                        let config = new specification_4.ConfigSpecification();
                        config.appendSpecificationUrls(req.query.specification, [req.body]).then((files) => {
                            if (files)
                                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(files));
                            else
                                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, ' specification not found');
                        });
                    }
                    else {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, ' specification not found');
                    }
                }
                else {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, ' specification no passed');
                }
            }
            catch (e) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'Adding URL failed: ' + e.message, e);
            }
        });
        var upload = (0, multer_1.default)({ storage: httpFileUpload_1.fileStorage });
        this.app.post("/api/upload" /* apiUri.upload */, upload.array('documents'), (req, res) => {
            try {
                if (!req.query.usage) {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'No Usage passed');
                    return;
                }
                let msg = this.checkBusidSlaveidParameter(req);
                if (msg !== '') {
                    this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, msg);
                    return;
                }
                else {
                    debug('Files uploaded');
                    if (req.files) {
                        // req.body.documents
                        let config = new specification_4.ConfigSpecification();
                        let f = [];
                        req.files.forEach((f0) => {
                            f.push(f0.originalname);
                        });
                        config.appendSpecificationFiles(req.query.specification, f, req.query.usage).then((files) => {
                            if (files)
                                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(files));
                            else
                                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkNoContent, ' specification not found or no files passed');
                        });
                    }
                    else {
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkNoContent, ' specification not found or no files passed');
                    }
                }
            }
            catch (e) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'Upload failed: ' + e.message, e);
            }
        });
        this.app.post("/api/uploadspec" /* apiUri.uploadSpec */, (0, multer_1.default)({ storage: httpFileUpload_1.zipStorage }).array('zips'), (req, res) => {
            if (req.files) {
                // req.body.documents
                ;
                req.files.forEach((f) => {
                    try {
                        let zipfilename = (0, path_1.join)(f.destination, f.filename);
                        let errors = specification_4.ConfigSpecification.importSpecificationZip(zipfilename);
                        fs.rmdirSync(path_1.default.dirname(zipfilename), { recursive: true });
                        if (errors.errors.length > 0)
                            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'Import failed: ' + errors.errors, errors);
                        else
                            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OkCreated, JSON.stringify(errors));
                    }
                    catch (e) {
                        let errors = { errors: 'Import error: ' + e.message, warnings: '' };
                        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrNotAcceptable, errors.errors, errors);
                    }
                });
            }
            else {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrNotAcceptable, 'No or incorrect files passed');
            }
        });
        this.delete("/api/upload" /* apiUri.upload */, (req, res) => {
            if (req.query.specification && req.query.url && req.query.usage) {
                let files = specification_4.ConfigSpecification.deleteSpecificationFile(req.query.specification, req.query.url, req.query.usage);
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(files));
            }
            else {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'Invalid Usage');
            }
        });
        this.delete("/api/newSpecificationfiles" /* apiUri.newSpecificationfiles */, (req, res) => {
            try {
                new specification_4.ConfigSpecification().deleteNewSpecificationFiles();
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify('OK'));
            }
            catch (err) {
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.ErrBadRequest, 'deletion failed: ' + err.message, err);
            }
        });
        // app.post('/specification',  ( req:express.TypedRequestBody<IfileSpecification>) =>{
        //         debug( req.body.name);
        //    });
        this.delete("/api/specification" /* apiUri.specfication */, (req, res) => {
            debug('DELETE /specification: ' + req.query.spec);
            let rd = new specification_4.ConfigSpecification();
            var rc = rd.deleteSpecification(req.query.spec);
            bus_1.Bus.getBusses().forEach((bus) => {
                bus.getSlaves().forEach((slave) => {
                    if (slave.specificationid == req.query.spec) {
                        delete slave.specificationid;
                        if (slave.pollMode == undefined)
                            slave.pollMode = server_shared_1.PollModes.intervall;
                        bus.writeSlave(slave);
                    }
                });
            });
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(rc));
        });
        this.delete("/api/bus" /* apiUri.bus */, (req, res) => {
            debug('DELETE /busses: ' + req.query.busid);
            bus_1.Bus.deleteBus(Number.parseInt(req.query.busid));
            this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, '');
        });
        this.delete("/api/slave" /* apiUri.slave */, (req, res) => {
            debug('Delete /slave: ' + req.query.slaveid);
            if (req.query.slaveid.length > 0 && req.query.busid.length > 0) {
                let bus = bus_1.Bus.getBus(Number.parseInt(req.query.busid));
                if (bus)
                    bus.deleteSlave(Number.parseInt(req.query.slaveid));
                this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, '');
            }
        });
    }
    checkBusidSlaveidParameter(req) {
        if (req.query.busid === '')
            return req.originalUrl + ': busid was not passed';
        if (req.query.slaveid === '')
            return req.originalUrl + ': slaveid was not passed';
        return '';
    }
    validateMqttConnectionResult(req, res, valid, message) {
        let rc = {
            valid: valid,
            message: message,
        };
        this.returnResult(req, res, specification_shared_1.HttpErrorsEnum.OK, JSON.stringify(rc));
    }
}
exports.HttpServer = HttpServer;
//# sourceMappingURL=httpserver.js.map