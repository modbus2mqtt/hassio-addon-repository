"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModbusForTest = exports.Modbus = void 0;
const specification_1 = require("@modbus2mqtt/specification");
const config_1 = require("./config");
const modbuscache_1 = require("./modbuscache");
const rxjs_1 = require("rxjs");
const bus_1 = require("./bus");
const submitRequestMock_1 = require("./submitRequestMock");
const specification_2 = require("@modbus2mqtt/specification");
const debug = require('debug')('modbus');
const debugAction = require('debug')('actions');
const log = new specification_2.Logger('modbus');
class Modbus {
    constructor() { }
    static writeEntityModbus(bus, slaveid, entity, modbusValue) {
        // this.modbusClient.setID(device.slaveid);
        if (config_1.Config.getConfiguration().fakeModbus) {
            return new Promise((resolve) => {
                debug('Fake ModbusWrite');
                resolve();
            });
        }
        else if (entity.modbusAddress && entity.registerType) {
            return new modbuscache_1.ModbusCache('write', true).writeRegisters({ busid: bus.getId(), slaveid: slaveid }, entity.modbusAddress, entity.registerType, modbusValue);
        }
        throw new Error('No modbusaddress or registerType passed');
    }
    static writeEntityMqtt(bus, slaveid, spec, entityid, mqttValue) {
        // this.modbusClient.setID(device.slaveid);
        let entity = spec.entities.find((ent) => ent.id == entityid);
        if (config_1.Config.getConfiguration().fakeModbus) {
            return new Promise((resolve) => {
                debug('Fake ModbusWrite');
                resolve();
            });
        }
        else if (entity) {
            let converter = specification_1.ConverterMap.getConverter(entity);
            if (entity.modbusAddress !== undefined && entity.registerType && converter) {
                let modbusValue = converter?.mqtt2modbus(spec, entityid, mqttValue);
                if (modbusValue && modbusValue.data.length > 0) {
                    return new modbuscache_1.ModbusCache('write', true).writeRegisters({ busid: bus.getId(), slaveid: slaveid }, entity.modbusAddress, entity.registerType, modbusValue);
                }
                else
                    throw new Error('No modbus address or function code or converter not found for entity ' + entityid + ' ');
            }
            else
                throw new Error('No modbus address or function code for entity ' + entityid + ' ');
        }
        else
            throw new Error('Entity not found in Specification entityid: ' + entityid + JSON.stringify(spec));
    }
    readEntityFromModbus(bus, slaveid, spec, entityId) {
        return new Promise((resolve, reject) => {
            let entity = spec.entities.find((ent) => ent.id == entityId);
            if (entity && entity.modbusAddress && entity.registerType) {
                let converter = specification_1.ConverterMap.getConverter(entity);
                if (converter) {
                    let addresses = new Set();
                    for (let i = entity.modbusAddress; i < entity.modbusAddress + converter.getModbusLength(entity); i++)
                        addresses.add({ address: i, registerType: entity.registerType });
                    let rcf = (results) => {
                        let em = specification_1.M2mSpecification.copyModbusDataToEntity(spec, entity.id, results);
                        if (em)
                            resolve(em);
                        else
                            reject(new Error('Unable to copy ModbusData to Entity'));
                    };
                    if (config_1.Config.getConfiguration().fakeModbus)
                        (0, submitRequestMock_1.submitGetHoldingRegisterRequest)({ busid: bus.getId(), slaveid: slaveid }, addresses).then(rcf).catch(reject);
                    else
                        bus.readModbusRegister('readEntity', slaveid, addresses).then(rcf).catch(reject);
                }
            }
            else {
                let msg = 'Bus ' + bus.properties.busId + ' has no configured Specification';
                log.log(specification_2.LogLevelEnum.notice, msg);
                reject(new Error(msg));
            }
        });
    }
    /*
     * iterates over slave ids starting at slaveid = 1. If one of the holding registers 0,1,2 or 3 returns a value, the slave id is considered to have an attached device.
     * Now, the method tries to find specifications which are supported by the device.
     * So, even if a device was not recognized, but the modbus registers of all identifying entities are available, the slaveId will be considered to hava an attached device.
     * The result, contains an array of all slaveids with an attached device.
     * Additionally it contains an array of public specifications matching the modbus registers of the device plus all local specifications.
     */
    static populateEntitiesForSpecification(specification, values, sub) {
        let mspec = specification_1.M2mSpecification.fileToModbusSpecification(specification, values);
        if (mspec)
            sub.next(mspec);
    }
    static getModbusSpecificationFromData(task, bus, slaveid, specification, sub) {
        let addresses = new Set();
        specification_1.ConfigSpecification.clearModbusData(specification);
        let info = '(' + bus.getId() + ',' + slaveid + ')';
        bus_1.Bus.getModbusAddressesForSpec(specification, addresses);
        debugAction('getModbusSpecificationFromData start read from modbus');
        bus
            .readModbusRegister(task, slaveid, addresses)
            .then((values) => {
            debugAction('getModbusSpecificationFromData end read from modbus');
            Modbus.populateEntitiesForSpecification(specification, values, sub);
        })
            .catch((e) => {
            // read modbus data failed.
            log.log(specification_2.LogLevelEnum.error, 'Modbus Read ' + info + ' failed: ' + e.message);
            Modbus.populateEntitiesForSpecification(specification, (0, specification_1.emptyModbusValues)(), sub);
        });
    }
    static getModbusSpecification(task, bus, slaveid, specificationFilename, failedFunction) {
        debugAction('getModbusSpecification starts (' + bus.getId() + ',' + slaveid + ')');
        let rc = new rxjs_1.Subject();
        if (!specificationFilename || specificationFilename.length == 0) {
            let slave = bus.getSlaveBySlaveId(slaveid);
            if (slave && slave.specificationid && slave.specificationid.length > 0)
                specificationFilename = slave.specificationid;
        }
        if (specificationFilename) {
            let spec = specification_1.ConfigSpecification.getSpecificationByFilename(specificationFilename);
            if (spec) {
                Modbus.getModbusSpecificationFromData(task, bus, slaveid, spec, rc);
            }
            else {
                let msg = 'No specification passed  ' + specificationFilename;
                failedFunction(new Error(msg));
            }
        }
        else {
            let msg = 'No specification passed to  getModbusSpecification';
            debug(msg);
            failedFunction(new Error(msg));
        }
        return rc;
    }
}
exports.Modbus = Modbus;
class ModbusForTest extends Modbus {
    modbusDataToSpecForTest(spec) {
        return specification_1.M2mSpecification.fileToModbusSpecification(spec);
    }
}
exports.ModbusForTest = ModbusForTest;
//# sourceMappingURL=modbus.js.map