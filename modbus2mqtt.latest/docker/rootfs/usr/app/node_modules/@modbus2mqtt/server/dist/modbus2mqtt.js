"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Modbus2Mqtt = void 0;
const tslib_1 = require("tslib");
const config_1 = require("./config");
const httpserver_1 = require("./httpserver");
const bus_1 = require("./bus");
const commander_1 = require("commander");
const ts_node_1 = require("ts-node");
const specification_1 = require("@modbus2mqtt/specification");
const os = tslib_1.__importStar(require("os"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const mqttdiscover_js_1 = require("./mqttdiscover.js");
const specification_2 = require("@modbus2mqtt/specification");
const path_1 = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs"));
const configbus_1 = require("./configbus");
const { argv } = require('node:process');
let httpServer = undefined;
process.on('unhandledRejection', (reason, p) => {
    log.log(specification_1.LogLevelEnum.error, 'Unhandled Rejection at: Promise', p, 'reason:', JSON.stringify(reason));
});
process.on('SIGINT', () => {
    if (httpServer)
        httpServer.close();
    process.exit(1);
});
const debug = (0, debug_1.default)('modbus2mqtt');
const debugAction = (0, debug_1.default)('actions');
//var modbusConfiguration;
let readConfig;
const log = new specification_1.Logger('modbus2mqtt');
class Modbus2Mqtt {
    pollTasks() {
        debugAction('readBussesFromConfig starts');
        bus_1.Bus.readBussesFromConfig();
        if (config_1.Config.getConfiguration().githubPersonalToken)
            new specification_2.ConfigSpecification().filterAllSpecifications((spec) => {
                if (spec.status == 4 /* SpecificationStatus.contributed */ && spec.pullNumber != undefined) {
                    specification_1.M2mSpecification.startPolling(spec.filename, (e) => {
                        log.log(specification_1.LogLevelEnum.error, 'Github:' + e.message);
                    });
                }
            });
    }
    init() {
        let cli = new commander_1.Command();
        cli.version(ts_node_1.VERSION);
        cli.usage('[--ssl <ssl-dir>][--yaml <yaml-dir>][ --port <TCP port>] --term <exit code for SIGTERM>');
        cli.option('-s, --ssl <ssl-dir>', 'set directory for certificates');
        cli.option('-y, --yaml <yaml-dir>', 'set directory for add on configuration');
        cli.option('--term <exit code for SIGTERM>', 'sets exit code in case of SIGTERM');
        cli.parse(process.argv);
        let options = cli.opts();
        if (options['yaml']) {
            config_1.Config.yamlDir = options['yaml'];
            specification_2.ConfigSpecification.yamlDir = options['yaml'];
        }
        else {
            config_1.Config.yamlDir = '.';
            specification_2.ConfigSpecification.yamlDir = '.';
        }
        if (options['term'])
            process.on('SIGTERM', () => {
                process.exit(options['term']);
            });
        if (options['ssl'])
            config_1.Config.sslDir = options['ssl'];
        else
            config_1.Config.sslDir = '.';
        readConfig = new config_1.Config();
        readConfig.readYamlAsync
            .bind(readConfig)()
            .then(() => {
            specification_2.ConfigSpecification.setMqttdiscoverylanguage(config_1.Config.getConfiguration().mqttdiscoverylanguage, config_1.Config.getConfiguration().githubPersonalToken);
            debug(config_1.Config.getConfiguration().mqttconnect.mqttserverurl);
            let angulardir = undefined;
            // hard coded workaround
            // let angulardir = require.resolve('@modbus2mqtt/angular')
            // Did not work in github workflow for testing
            let dir = (0, path_1.dirname)(argv[1]);
            while (dir.length > 0 && (!angulardir || !fs.existsSync(angulardir))) {
                angulardir = (0, path_1.join)(dir, 'angular/dist/browser');
                if (!fs.existsSync(angulardir))
                    angulardir = (0, path_1.join)(dir, 'node_modules/@modbus2mqtt/angular/dist/browser');
                dir = (0, path_1.dirname)(dir);
            }
            if (!angulardir || !fs.existsSync(angulardir)) {
                log.log(specification_1.LogLevelEnum.error, 'Unable to find angular start file ' + angulardir);
                process.exit(2);
            }
            else
                log.log(specification_1.LogLevelEnum.notice, 'angulardir is ' + angulardir);
            let angulardirLang = path_1.default.parse(angulardir).dir;
            debug('http root : ' + angulardir);
            let gh = new specification_1.M2mGitHub(config_1.Config.getConfiguration().githubPersonalToken ? config_1.Config.getConfiguration().githubPersonalToken : null, (0, path_1.join)(specification_2.ConfigSpecification.yamlDir, 'public'));
            let startServer = () => {
                let md = mqttdiscover_js_1.MqttDiscover.getInstance();
                configbus_1.ConfigBus.readBusses();
                this.pollTasks();
                debugAction('readBussesFromConfig done');
                debug('Inititialize busses done');
                //execute every 30 minutes
                setInterval(() => {
                    this.pollTasks();
                }, 30 * 1000 * 60);
                if (httpServer)
                    httpServer
                        .init()
                        .then(() => {
                        httpServer.listen(() => {
                            log.log(specification_1.LogLevelEnum.notice, `modbus2mqtt listening on  ${os.hostname()}: ${config_1.Config.getConfiguration().httpport}`);
                            new specification_2.ConfigSpecification().deleteNewSpecificationFiles();
                            bus_1.Bus.getAllAvailableModusData();
                            if (process.env.MODBUS_NOPOLL == undefined) {
                                md.startPolling();
                            }
                            else {
                                log.log(specification_1.LogLevelEnum.notice, 'Poll disabled by environment variable MODBUS_POLL');
                            }
                        });
                    })
                        .catch((e) => {
                        log.log(specification_1.LogLevelEnum.error, 'Start polling Contributions: ' + e.message);
                    });
            };
            httpServer = new httpserver_1.HttpServer(angulardir);
            debugAction('readBussesFromConfig starts');
            gh.init()
                .then(startServer)
                .catch((e) => {
                startServer();
            });
        });
    }
}
exports.Modbus2Mqtt = Modbus2Mqtt;
let m = new Modbus2Mqtt();
m.init();
//module.exports = {connectMqtt, init}
//# sourceMappingURL=modbus2mqtt.js.map