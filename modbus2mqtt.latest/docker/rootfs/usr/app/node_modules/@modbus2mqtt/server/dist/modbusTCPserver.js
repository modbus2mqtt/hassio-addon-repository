"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModbusServer = exports.Eastronslaveid = exports.Dimplexslaveid = exports.XYslaveid = void 0;
exports.clearRegisterValues = clearRegisterValues;
exports.addRegisterValue = addRegisterValue;
exports.logValues = logValues;
exports.runModbusServer = runModbusServer;
exports.stopModbusTCPServer = stopModbusTCPServer;
exports.startModbusTCPserver = startModbusTCPserver;
const tslib_1 = require("tslib");
const modbus_serial_1 = require("modbus-serial");
const debug_1 = tslib_1.__importDefault(require("debug"));
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const specification_1 = require("@modbus2mqtt/specification");
const fs = tslib_1.__importStar(require("fs"));
const path_1 = require("path");
const yaml_1 = require("yaml");
exports.XYslaveid = 1;
exports.Dimplexslaveid = 2;
exports.Eastronslaveid = 3;
const log = new specification_1.Logger('modbusTCP');
const debug = (0, debug_1.default)('modbusTCP');
const dimplexHolding = [
    [1, 200],
    [1, 200],
    [174, 450],
    [11, 208],
    [3, 480],
    [46, 209],
    [47, 30],
];
const values = {
    //XY-MD02
    inputRegisters: [
        { slaveid: exports.XYslaveid, address: 1, value: 195 },
        { slaveid: exports.XYslaveid, address: 2, value: 500 },
    ],
    holdingRegisters: [
        { slaveid: exports.XYslaveid, address: 0x0101, value: 1 },
        { slaveid: exports.XYslaveid, address: 0x0102, value: 1 },
    ],
    coils: [
        { slaveid: exports.XYslaveid, address: 1, value: true },
        { slaveid: exports.XYslaveid, address: 2, value: true },
        { slaveid: exports.Dimplexslaveid, address: 1, value: false },
        { slaveid: exports.Dimplexslaveid, address: 3, value: false },
    ],
};
function getCoil(addr, unitID) {
    return new Promise((resolve, reject) => {
        let v = values.coils.find((v) => v.slaveid == unitID && v.address == addr);
        if (v) {
            debug('getCoil: slave: ' + unitID + 'address: ' + addr + 'v: ' + v.value);
            resolve(v.value);
        }
        else {
            debug('getCoil: failed slave: ' + unitID + 'address: ' + addr);
            reject({ modbusErrorCode: 2, msg: '' });
        }
    });
}
const vector = {
    getInputRegister: function (addr, unitID) {
        return new Promise((resolve, reject) => {
            let v = values.inputRegisters.find((v) => v.slaveid == unitID && v.address == addr);
            if (v) {
                debug('getInputRegister slave:' + addr + 'unit' + unitID + 'v: ' + v.value);
                resolve(v.value);
            }
            else {
                debug('getInputRegister slave:' + addr + 'unit' + unitID);
                reject({ modbusErrorCode: 2, msg: '' });
            }
        });
    },
    getHoldingRegister: function (addr, unitID) {
        return new Promise((resolve, reject) => {
            let v = values.holdingRegisters.find((v) => v.slaveid == unitID && v.address == addr);
            if (v) {
                debug('getHoldingRegister addr:' + addr + ' slave: ' + unitID + 'v: ' + v.value);
                resolve(v.value);
            }
            else {
                debug('getHoldingRegister not found addr:' + addr + ' slave: ' + unitID);
                reject({ modbusErrorCode: 2, msg: '' });
            }
        });
    },
    getMultipleInputRegisters: (addr, length, unitID, cb) => {
        let rc = [];
        for (let idx = 0; idx < length; idx++) {
            let v = values.inputRegisters.find((v) => v.slaveid == unitID && v.address == addr + idx);
            if (v)
                rc.push(v.value);
            else {
                debug('getMultipleInputRegisters not found addr:' + addr + ' slave: ' + unitID);
                cb({ modbusErrorCode: 2 }, []);
                return;
            }
        }
        debug('getMultipleInputRegisters addr:' + addr + ' slave: ' + unitID + 'rc: ' + JSON.stringify(rc));
        cb(null, rc);
    },
    getMultipleHoldingRegisters: (addr, length, unitID, cb) => {
        let rc = [];
        for (let idx = 0; idx < length; idx++) {
            let v = values.holdingRegisters.find((v) => v.slaveid == unitID && v.address == addr + idx);
            if (v)
                rc.push(v.value);
            else {
                log.log(specification_1.LogLevelEnum.notice, 'Invalid holding reg s:' + unitID + ' a: ' + addr + idx);
                cb({ modbusErrorCode: 2 }, []);
                return;
            }
        }
        debug('getMultipleHoldingRegisters ' + JSON.stringify(rc));
        cb(null, rc);
    },
    getDiscreteInput: getCoil,
    getCoil: getCoil,
    setRegister: (addr, value, unitID) => {
        return new Promise((resolve, reject) => {
            let v = values.holdingRegisters.find((v) => v.slaveid == unitID && v.address == addr);
            if (v) {
                v.value = value;
                resolve();
            }
            else
                reject({ modbusErrorCode: 2, msg: '' });
        });
    },
    setCoil: (addr, value, unitID, cb) => {
        let v = values.coils.find((v) => v.slaveid == unitID && v.address == addr);
        if (v) {
            v.value = value;
            cb(null, value ? 1 : 0);
        }
        else {
            cb({ modbusErrorCode: 2 }, 0);
            return;
        }
    },
};
class ModbusServer {
    startServerForTest(port) {
        dimplexHolding.forEach((nv) => {
            values.holdingRegisters.push({
                slaveid: exports.Dimplexslaveid,
                address: nv[0],
                value: nv[1],
            });
        });
    }
    async startServer(port) {
        let rc = new Promise((resolve, reject) => {
            this.serverTCP = new modbus_serial_1.ServerTCP(vector, {
                host: '0.0.0.0',
                port: port,
                debug: true,
            });
            this.serverTCP.on('socketError', function (err) {
                // Handle socket error if needed, can be ignored
                reject(err);
            });
            this.serverTCP.on('serverError', function (err) {
                // Handle socket error if needed, can be ignored
                reject(err);
            });
            this.serverTCP.on('error', function (err) {
                // Handle socket error if needed, can be ignored
                reject(err);
            });
            this.serverTCP.on('initialized', () => {
                log.log(specification_1.LogLevelEnum.notice, 'ModbusTCP listening on modbus://0.0.0.0:' + port);
                resolve(this.serverTCP);
            });
        });
        return rc;
    }
    stopServer(cb) {
        if (this.serverTCP)
            this.serverTCP.close(() => {
                if (cb)
                    cb();
            });
    }
}
exports.ModbusServer = ModbusServer;
function clearRegisterValues() {
    values.holdingRegisters = [];
    values.inputRegisters = [];
    values.coils = [];
}
function addRegisterValue(slaveid, address, fc, value) {
    switch (fc) {
        case specification_shared_1.ModbusRegisterType.HoldingRegister:
            values.holdingRegisters.push({
                slaveid: slaveid,
                address: address,
                value: value,
            });
            break;
        case specification_shared_1.ModbusRegisterType.Coils:
            values.coils.push({
                slaveid: slaveid,
                address: address,
                value: value != 0,
            });
            break;
        case specification_shared_1.ModbusRegisterType.AnalogInputs:
            values.inputRegisters.push({
                slaveid: slaveid,
                address: address,
                value: value,
            });
            break;
        default:
            log.log(specification_1.LogLevelEnum.notice, 'Invalid function code ' + fc);
    }
}
function logValues() {
    log.log(specification_1.LogLevelEnum.notice, 'coils');
    values.coils.forEach((c) => {
        log.log(specification_1.LogLevelEnum.notice, 's: ' + c.slaveid + ' a: ' + c.address + ' v: ' + c.value);
    });
    log.log(specification_1.LogLevelEnum.notice, 'holding');
    values.holdingRegisters.forEach((c) => {
        log.log(specification_1.LogLevelEnum.notice, 's: ' + c.slaveid + ' a: ' + c.address + ' v: ' + c.value);
    });
    log.log(specification_1.LogLevelEnum.notice, 'input');
    values.inputRegisters.forEach((c) => {
        log.log(specification_1.LogLevelEnum.notice, 's: ' + c.slaveid + ' a: ' + c.address + ' v: ' + c.value);
    });
}
let server = undefined;
function runModbusServer(port = 8502) {
    server = new ModbusServer();
    server
        .startServer(port)
        .then(() => {
        log.log(specification_1.LogLevelEnum.notice, 'listening');
    })
        .catch((e) => {
        log.log(specification_1.LogLevelEnum.error, 'Unable to start ' + e.message);
        process.exit(1);
    });
}
process.on('SIGINT', () => {
    stopModbusTCPServer();
});
function stopModbusTCPServer() {
    if (server)
        server.stopServer();
}
function startModbusTCPserver(yamlDir, busId) {
    debug('starting');
    if (process.pid)
        log.log(specification_1.LogLevelEnum.notice, 'PROCESSID=' + process.pid);
    let gh = new specification_1.M2mGitHub(null, (0, path_1.join)(yamlDir, 'public'));
    gh.init()
        .then(() => {
        let port = 502;
        clearRegisterValues();
        let directoryBus = (0, path_1.join)(yamlDir, 'local/busses/bus.' + busId);
        let directoryPublicSpecs = (0, path_1.join)(yamlDir, 'public/specifications');
        let directoryLocalSpecs = (0, path_1.join)(yamlDir, 'local/specifications');
        if (!fs.existsSync(directoryBus)) {
            log.log(specification_1.LogLevelEnum.error, 'Unable to start TCP server: Bus directory not found ' + directoryBus);
            return;
        }
        console.log('read bus' + directoryBus);
        let files = fs.readdirSync(directoryBus);
        files.forEach((slaveFileName) => {
            if (slaveFileName == 'bus.yaml') {
                let content = fs.readFileSync((0, path_1.join)(directoryBus, slaveFileName), {
                    encoding: 'utf8',
                });
                let connection = (0, yaml_1.parse)(content.toString());
                port = connection.port;
            }
            if (slaveFileName.startsWith('s'))
                try {
                    console.log('read slave' + slaveFileName);
                    let content = fs.readFileSync((0, path_1.join)(directoryBus, slaveFileName), {
                        encoding: 'utf8',
                    });
                    let slave = (0, yaml_1.parse)(content.toString());
                    let slaveid = slave.slaveid;
                    let specFilename = slave.specificationid;
                    if (specFilename) {
                        let fn = (0, path_1.join)(directoryLocalSpecs, specFilename + '.yaml');
                        if (!fs.existsSync(fn))
                            fn = (0, path_1.join)(directoryPublicSpecs, specFilename + '.yaml');
                        if (!fs.existsSync(fn))
                            console.log('TCP Server: Spec file not found: ' + fn);
                        else {
                            content = fs.readFileSync(fn, { encoding: 'utf8' });
                            let spec = (0, yaml_1.parse)(content.toString());
                            spec = new specification_1.Migrator().migrate(spec);
                            if (spec.testdata) {
                                let testdata = spec.testdata;
                                if (spec.testdata.analogInputs)
                                    spec.testdata.analogInputs.forEach((avp) => {
                                        let a = avp.address;
                                        if (avp.value != undefined)
                                            addRegisterValue(slaveid, a, specification_shared_1.ModbusRegisterType.AnalogInputs, avp.value);
                                    });
                                if (spec.testdata.holdingRegisters)
                                    spec.testdata.holdingRegisters.forEach((avp) => {
                                        let a = avp.address;
                                        if (avp.value != undefined)
                                            addRegisterValue(slaveid, a, specification_shared_1.ModbusRegisterType.HoldingRegister, avp.value);
                                    });
                                if (spec.testdata.coils)
                                    spec.testdata.coils.forEach((avp) => {
                                        let a = avp.address;
                                        if (avp.value != undefined)
                                            addRegisterValue(slaveid, a, specification_shared_1.ModbusRegisterType.Coils, avp.value);
                                    });
                            }
                        }
                    }
                    //  logValues()
                }
                catch (e) {
                    console.error('Unable to read  directory for ' + e);
                }
        });
        runModbusServer(port);
    })
        .catch((e) => {
        log.log(specification_1.LogLevelEnum.error, 'Failed to init github: ' + e.message);
    });
}
// set the server to answer for modbus requests
//# sourceMappingURL=modbusTCPserver.js.map