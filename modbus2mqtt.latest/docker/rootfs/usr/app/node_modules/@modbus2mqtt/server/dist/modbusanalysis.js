"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const modbus_serial_1 = tslib_1.__importDefault(require("modbus-serial"));
const debug_1 = tslib_1.__importDefault(require("debug"));
let baudrate = 4800;
const debug = (0, debug_1.default)('modbusanalysis');
process.env['DEBUG'] = 'modbusanalysis';
debug_1.default.enable('modbusanalysis');
let slave = 1;
let client = new modbus_serial_1.default();
connect();
// open connection to a serial port
function destroy() {
    debug('close');
    client.close(connect);
}
function connect() {
    debug('connect ' + baudrate);
    client = new modbus_serial_1.default();
    client
        .connectRTUBuffered('/dev/ttyUSB0', { baudRate: baudrate })
        .then(read)
        .catch((e) => {
        debug('connect ' + JSON.stringify(e));
        console.log(e);
        process.exit(0);
    });
}
function read() {
    debug('read: ' + Math.floor(slave / 2));
    client.setID(Math.floor(slave++ / 2));
    client.setTimeout(500);
    client
        .readHoldingRegisters(1, 1)
        .then(() => {
        debug('SUCCESS==================');
        destroy();
    })
        .catch((e) => {
        if (e.errno && e.errno == 'ETIMEDOUT') {
            debug('timeout');
            if (slave < 512)
                read();
        }
        else {
            debug('read failure: ' + JSON.stringify(e));
            destroy();
        }
    });
}
//# sourceMappingURL=modbusanalysis.js.map