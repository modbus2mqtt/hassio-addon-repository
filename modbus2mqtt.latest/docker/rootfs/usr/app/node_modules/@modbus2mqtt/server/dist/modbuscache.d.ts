import { Mutex } from 'async-mutex';
import { ImodbusValues } from '@modbus2mqtt/specification';
import { ReadRegisterResult } from 'modbus-serial/ModbusRTU';
import { ModbusRegisterType } from '@modbus2mqtt/specification.shared';
export declare enum ModbusStates {
    Initial = "Initial",
    RequestLoaded = "RequestLoaded",
    Prepared = "Prepared",
    Connected = "Connected",
    ConnectedFailed = "ConnectedFailed",
    Processing = "Processing",
    ProcessFailed = "ProcessFailed",
    Result = "Result",
    Finished = "Finished"
}
export declare enum SlaveStates {
    connected = 1,
    disconnected = 0,
    error = -1
}
export interface ImodbusAddress {
    address: number;
    registerType: ModbusRegisterType;
    length?: number;
}
export declare class ImodbusAddresses {
    private data;
    private getSuperSet;
    add(newData: ImodbusAddress): void;
    [Symbol.iterator](): {
        next: () => {
            value: ImodbusAddress;
            done: boolean;
        };
    };
}
export interface IslaveId {
    busid: number;
    slaveid: number;
}
export declare class ModbusStateMachine {
    private task;
    private printLogs;
    private slaveId;
    private addresses;
    private returnAction;
    private failedAction;
    private static maxPid;
    private static slaveStates;
    private state;
    private static lastNoticeMessage;
    private static lastNoticeMessageTime;
    private pid;
    private result;
    private isSplitted;
    private preparedAddresses;
    private preparedAddressesIndex;
    private retryCount;
    private timeoutCount;
    private data;
    private write;
    private retryConnectCount;
    constructor(task: string, printLogs: boolean, slaveId: IslaveId, addresses: Set<ImodbusAddress>, returnAction: (results: ImodbusValues) => void, failedAction: (e: any) => void);
    private logNotice;
    next(newState: ModbusStates, action: () => void, actionName?: string): Promise<void>;
    loadAction(): void;
    prepareWriteAction(startaddress: number, registerType: ModbusRegisterType, data: ReadRegisterResult): void;
    prepareAddressesAction(): void;
    connectAction(): void;
    retryConnectAction(_module: string, e: any): void;
    processAction(): void;
    private processReadFromModbus;
    private processWriteToModbus;
    private endProcessAction;
    private doClose;
    closeAction(e?: any): void;
    private splitAddresses;
    private reopenAndContinue;
    retryProcessAction(module: string, e: any): void;
    processResultAction(): void;
    static getStatus(slaveId: number): SlaveStates;
}
export declare class ModbusCache {
    private task;
    private printLogs;
    static readMutex: Mutex;
    constructor(task: string, printLogs: boolean);
    writeRegisters(slaveId: IslaveId, startaddress: number, registerType: ModbusRegisterType, data: ReadRegisterResult): Promise<void>;
    submitGetHoldingRegisterRequest(slaveId: IslaveId, addresses: Set<ImodbusAddress>): Promise<ImodbusValues>;
    static getStatus(slaveId: number): SlaveStates;
}
export declare const exportedForTesting: {
    ModbusStateMachine: typeof ModbusStateMachine;
};
