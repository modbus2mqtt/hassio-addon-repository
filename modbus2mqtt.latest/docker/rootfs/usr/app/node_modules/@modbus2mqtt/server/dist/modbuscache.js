"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportedForTesting = exports.ModbusCache = exports.ModbusStateMachine = exports.ImodbusAddresses = exports.SlaveStates = exports.ModbusStates = void 0;
const tslib_1 = require("tslib");
//
// ModbusCache manages bulk reading of modbus registers.
// requesters register a set of address number and provide a result function
// Modbus checks the buffered results. If all requested data is available, it calls the result function
// Otherwise, it reads the data from modbus
// The requested addresses will be cumulated until a requester calls clearData for a given slave;
const debug_1 = tslib_1.__importDefault(require("debug"));
const async_mutex_1 = require("async-mutex");
const specification_1 = require("@modbus2mqtt/specification");
const bus_1 = require("./bus");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const minTimeout = 100;
const maxTimeouts = 1;
const maxAddressDelta = 10;
const maxRetries = 1;
const debug = (0, debug_1.default)('modbuscache');
const debugData = (0, debug_1.default)('modbuscache.data');
const debugNext = (0, debug_1.default)('modbuscache.next');
const debugTime = (0, debug_1.default)('modbuscache.time');
const log = new specification_1.Logger('modbuscache');
var ModbusStates;
(function (ModbusStates) {
    ModbusStates["Initial"] = "Initial";
    ModbusStates["RequestLoaded"] = "RequestLoaded";
    ModbusStates["Prepared"] = "Prepared";
    ModbusStates["Connected"] = "Connected";
    ModbusStates["ConnectedFailed"] = "ConnectedFailed";
    ModbusStates["Processing"] = "Processing";
    ModbusStates["ProcessFailed"] = "ProcessFailed";
    ModbusStates["Result"] = "Result";
    ModbusStates["Finished"] = "Finished";
})(ModbusStates || (exports.ModbusStates = ModbusStates = {}));
var SlaveStates;
(function (SlaveStates) {
    SlaveStates[SlaveStates["connected"] = 1] = "connected";
    SlaveStates[SlaveStates["disconnected"] = 0] = "disconnected";
    SlaveStates[SlaveStates["error"] = -1] = "error";
})(SlaveStates || (exports.SlaveStates = SlaveStates = {}));
class ImodbusAddresses {
    getSuperSet(value, newData) {
        let valueLength = value.length ? value.length : 1;
        let newDataLength = newData.length ? newData.length : 1;
        // new Data.address is in the value address range
        if (value.address <= newData.address && newData.address < value.address + valueLength)
            if (newData.address + newDataLength > value.address + valueLength) {
                value.length = newData.address + newDataLength - value.address;
                return value;
            }
        return null;
    }
    add(newData) {
        let needsAdding = true;
        this.data.forEach((value) => {
            if (value.registerType == newData.registerType) {
                let superValue = this.getSuperSet(value, newData);
                if (superValue == null)
                    superValue = this.getSuperSet(newData, value);
                if (superValue != null) {
                    value = superValue;
                    needsAdding = false;
                }
            }
        });
        if (needsAdding)
            this.data.push(newData);
    }
    [Symbol.iterator]() {
        var index = -1;
        var data = this.data;
        return {
            next: () => ({ value: data[++index], done: !(index in data) }),
        };
    }
}
exports.ImodbusAddresses = ImodbusAddresses;
const logNoticeMaxWaitTime = 1000 * 60 * 30; // 30 minutes
class ModbusStateMachine {
    static { this.maxPid = 0; }
    static { this.slaveStates = new Map(); }
    static { this.lastNoticeMessage = ''; }
    constructor(task, printLogs, slaveId, addresses, returnAction, failedAction) {
        this.task = task;
        this.printLogs = printLogs;
        this.slaveId = slaveId;
        this.addresses = addresses;
        this.returnAction = returnAction;
        this.failedAction = failedAction;
        this.state = ModbusStates.Initial;
        this.result = (0, specification_1.emptyModbusValues)();
        this.isSplitted = false;
        this.preparedAddresses = [];
        this.preparedAddressesIndex = 0;
        this.retryCount = 0;
        this.timeoutCount = 0;
        this.data = {
            data: [],
            buffer: Buffer.from(''),
        };
        this.write = false;
        this.retryConnectCount = 0;
        this.pid = ++ModbusStateMachine.maxPid;
    }
    logNotice(msg) {
        if (!this.printLogs)
            return;
        // suppress similar duplicate messages
        let repeatMessage = ModbusStateMachine.lastNoticeMessageTime != undefined &&
            ModbusStateMachine.lastNoticeMessageTime + logNoticeMaxWaitTime < Date.now();
        if (repeatMessage || msg != ModbusStateMachine.lastNoticeMessage) {
            ModbusStateMachine.lastNoticeMessage = msg;
            ModbusStateMachine.lastNoticeMessageTime = Date.now();
            log.log(specification_1.LogLevelEnum.notice, this.task + ' ' + msg);
        }
    }
    async next(newState, action, actionName) {
        if (action.name != '')
            debugNext('next(' + this.pid + '): ' + this.state + '-> ' + action.name + '->' + newState);
        else if (actionName)
            debugNext('next(' + this.pid + '): ' + this.state + '-> ' + actionName + '->' + newState);
        else
            debugNext('next(' + this.pid + '): ' + this.state + '-> unnamed Action->' + newState);
        this.state = newState;
        if (!action.name.startsWith('bound'))
            action.bind(this)();
        else
            action();
    }
    loadAction() {
        if (this.addresses.size <= 0) {
            debugNext('ModbusCache:submitGetHoldingRegisterRequest no registers to read');
            this.next(ModbusStates.Result, this.processResultAction);
        }
        else
            debugNext('loadAction(' +
                this.pid +
                '): reading slaveid: ' +
                this.slaveId.slaveid +
                ' addresses: ' +
                JSON.stringify(Array.from(this.addresses)));
        // The first process will wait for 1ms all others wait for 100ms
        // So, the first process has a chance to fill the results cache.
        // modbusMutex must be released before waiting otherwise the first process can't fill the cache
        this.next(ModbusStates.RequestLoaded, this.prepareAddressesAction);
    }
    prepareWriteAction(startaddress, registerType, data) {
        this.preparedAddresses.push({
            address: startaddress,
            registerType: registerType,
            length: data.data.length,
        });
        this.data = data;
        this.preparedAddressesIndex = 0;
        this.write = true;
        this.next(ModbusStates.Prepared, this.connectAction);
    }
    prepareAddressesAction() {
        debugNext('ModbusStateMachine:prepareAddressesAction(' +
            this.slaveId.slaveid +
            '): addresses:' +
            JSON.stringify(Array.from(this.addresses.values()).sort()));
        let previousAddress = {
            address: -1,
            registerType: specification_shared_1.ModbusRegisterType.IllegalFunctionCode,
        };
        let startAddress = {
            address: -1,
            registerType: specification_shared_1.ModbusRegisterType.IllegalFunctionCode,
        };
        let sortedAddresses = Array.from(this.addresses.values()).sort(function (a, b) {
            let v = a.registerType - b.registerType;
            if (v)
                return v;
            return a.address - b.address;
        });
        for (let addr of sortedAddresses) {
            if (previousAddress.address == -1)
                previousAddress = addr;
            if (startAddress.address == -1)
                startAddress = addr;
            if (addr.registerType != previousAddress.registerType || addr.address - previousAddress.address > maxAddressDelta) {
                this.preparedAddresses.push({
                    address: startAddress.address,
                    length: previousAddress.address - startAddress.address + 1,
                    registerType: previousAddress.registerType,
                });
                previousAddress = addr;
                startAddress = addr;
            }
            else
                previousAddress = addr;
        }
        if (startAddress.address >= 0)
            this.preparedAddresses.push({
                address: startAddress.address,
                length: previousAddress.address - startAddress.address + 1,
                registerType: previousAddress.registerType,
            });
        debugData('prepareAddressesAction(' + this.slaveId.slaveid + '): ' + JSON.stringify(this.preparedAddresses));
        this.preparedAddressesIndex = 0;
        this.next(ModbusStates.Prepared, this.connectAction);
    }
    connectAction() {
        let bus = bus_1.Bus.getBus(this.slaveId.busid);
        if (bus) {
            bus
                .connectRTU(this.task)
                .then(() => {
                this.next(ModbusStates.Connected, this.processAction);
                // this.onConnectRTUread(slaveId, addresses, resultFunction)
            })
                .catch((e) => {
                this.next(ModbusStates.ConnectedFailed, () => {
                    this.retryConnectAction('connectAction', e);
                }, '(retry)connectAction');
            });
        }
    }
    retryConnectAction(_module, e) {
        this.logNotice('Retry Connect: ' + (e && e.message ? 'module : ' + e.message : '') + ' ' + (e && e.stack ? e.stack : ''));
        if (this.retryConnectCount++ < maxRetries) {
            let bus = bus_1.Bus.getBus(this.slaveId.busid);
            bus
                ?.reconnectRTU(this.task)
                .then(() => {
                this.next(ModbusStates.Connected, this.processAction);
            })
                .catch((e) => {
                this.next(ModbusStates.ConnectedFailed, () => {
                    this.retryConnectAction('connectAction', e);
                }, '(retry)connectAction');
            });
        }
        else
            this.next(this.state, () => {
                this.failedAction(e);
            }, this.failedAction.name);
    }
    processAction() {
        if (this.preparedAddressesIndex >= this.preparedAddresses.length) {
            this.next(ModbusStates.Result, this.closeAction);
            return;
        }
        let bus = bus_1.Bus.getBus(this.slaveId.busid);
        if (bus) {
            if (!bus.isRTUopen()) {
                this.next(this.state, this.connectAction);
                return;
            }
            let startAddress = this.preparedAddresses[this.preparedAddressesIndex].address;
            let length = this.preparedAddresses[this.preparedAddressesIndex].length;
            let registerType = this.preparedAddresses[this.preparedAddressesIndex].registerType;
            let start = Date.now();
            let tbl = new Map([
                [
                    specification_shared_1.ModbusRegisterType.HoldingRegister,
                    {
                        resultTable: this.result.holdingRegisters,
                        readFunc: bus.readHoldingRegisters,
                        writeFunc: bus.writeHoldingRegisters,
                    },
                ],
                [
                    specification_shared_1.ModbusRegisterType.AnalogInputs,
                    {
                        resultTable: this.result.analogInputs,
                        readFunc: bus.readInputRegisters,
                    },
                ],
                [
                    specification_shared_1.ModbusRegisterType.Coils,
                    {
                        resultTable: this.result.coils,
                        readFunc: bus.readCoils,
                        writeFunc: bus.writeCoils,
                    },
                ],
                [
                    specification_shared_1.ModbusRegisterType.DiscreteInputs,
                    {
                        resultTable: this.result.discreteInputs,
                        readFunc: bus.readDiscreteInputs,
                    },
                ],
            ]);
            if (this.write) {
                this.processWriteToModbus(startAddress, this.data, bus, tbl.get(registerType));
            }
            else if (length)
                this.processReadFromModbus(startAddress, startAddress, bus, start, length, registerType, tbl.get(registerType), false);
        }
    }
    // optimizes the timeout for slaves
    processReadFromModbus(startAddress, readAddress, bus, start, length, registerType, process, afterTimeout) {
        let msg = '(' +
            this.pid +
            '):processAction: slaveid: ' +
            this.slaveId.slaveid +
            ' startaddr: ' +
            startAddress +
            ' l:' +
            length +
            ' FC:' +
            registerType;
        let slave = bus?.getSlaveBySlaveId(this.slaveId.slaveid);
        process.readFunc
            .bind(bus)(this.slaveId.slaveid, readAddress, length)
            .then((value) => {
            if (afterTimeout)
                log.log(specification_1.LogLevelEnum.notice, 'Retry successfully executed: slave:' + slave?.slaveid + ' address: ' + startAddress + ' length:' + length);
            debugTime('read success (' + this.slaveId.slaveid + ',' + readAddress + ',' + length + ') duration: ' + value.duration);
            this.retryCount = 0;
            this.timeoutCount = 0;
            // If this is the longest running read and the timeout is higher, reduce the timeout
            if (slave &&
                slave.modbusTimout &&
                (slave.durationOfLongestModbusCall == undefined || slave.durationOfLongestModbusCall < value.duration)) {
                slave.durationOfLongestModbusCall = value.duration;
                debugData(process.readFunc.name + ': set durationOfLongestModbusCall for slaveid: ' + slave.slaveid + 'to: ' + value.duration);
                if (slave.modbusTimout > slave.durationOfLongestModbusCall * 2 && slave.modbusTimout > minTimeout) {
                    // slave.modbusTimout = slave.durationOfLongestModbusCall * 2
                    debugData(process.readFunc.name + ': set modbusTimout for slaveid: ' + slave.slaveid + 'to: ' + slave.modbusTimout);
                }
            }
            if (value.result) {
                debugData(process.readFunc.name +
                    ': ' +
                    msg +
                    ', data: ' +
                    value.result.data +
                    'buffer: ' +
                    JSON.stringify(value.result.buffer) +
                    ' duration: ' +
                    value.duration);
                for (let idx = 0; idx < value.result.data.length; idx++) {
                    let buf = Buffer.allocUnsafe(2);
                    if (value.result.buffer.length >= idx * 2 + 2)
                        value.result.buffer.copy(buf, 0, idx * 2, idx * 2 + 2);
                    let r = {
                        result: {
                            data: [value.result.data[idx]],
                            buffer: buf,
                        },
                    };
                    process.resultTable.set(startAddress + idx, r);
                }
            }
            if (value.error) {
                debugData(process.readFunc.name + ': ' + msg + ', error: ' + value.error.message + ' duration: ' + value.duration);
                for (let idx = 0; idx < length; idx++) {
                    let r = {
                        error: value.error,
                    };
                    process.resultTable.set(startAddress + idx, r);
                }
            }
            this.preparedAddressesIndex++;
            this.endProcessAction(this.processAction);
            // there are more items to process
        })
            .catch((e) => {
            if (e.duration)
                debugTime('read fail duration: ' + e.duration);
            else
                debugTime('read fail Total duration: ' + (Date.now() - start));
            if (e.errno == 'ETIMEDOUT' && this.timeoutCount++ < maxTimeouts) {
                this.logNotice(process.readFunc.name +
                    ' TIMEOUT: slave:' +
                    slave?.slaveid +
                    ' address: ' +
                    startAddress +
                    ' length:' +
                    length +
                    ' ' +
                    (e.readDetails ? e.readDetails : '') +
                    ' retrying ... ');
                this.processReadFromModbus(startAddress, readAddress, bus, start, length, registerType, process, true);
                return;
            }
            debugData(process.readFunc.name + ':' + msg + ' failed: ' + e.message);
            e.readDetails = ' slave: ' + this.slaveId.slaveid + ' startAddress: ' + startAddress + ' length: ' + length + '';
            this.endProcessAction(this.retryProcessAction.bind(this, process.readFunc.name, e), ModbusStates.ProcessFailed, this.retryProcessAction.name);
        });
    }
    processWriteToModbus(startAddress, data, bus, process) {
        if (!process.writeFunc) {
            debugData('processAction:' + 'No write function defined');
            this.endProcessAction(this.processAction);
            return;
        }
        process.writeFunc
            .bind(bus)(this.slaveId.slaveid, startAddress, data)
            .then(() => {
            this.preparedAddressesIndex++;
            this.next(ModbusStates.Result, this.closeAction);
        })
            .catch((e) => {
            this.endProcessAction(this.retryProcessAction.bind(this, 'writeRegisters', e), ModbusStates.ProcessFailed, this.retryProcessAction.name);
        });
    }
    endProcessAction(action, state = undefined, actionName) {
        debugNext('endProcessAction');
        if (!state)
            this.next(this.state, action, actionName);
        else
            this.next(state, action, actionName);
    }
    doClose(e) {
        if (e)
            this.next(ModbusStates.ProcessFailed, () => {
                this.failedAction(e);
            }, this.failedAction.name);
        else if (this.write)
            this.returnAction(this.result);
        else
            this.next(ModbusStates.Result, this.processResultAction);
    }
    closeAction(e) {
        // close the client
        let bus = bus_1.Bus.getBus(this.slaveId.busid);
        if (bus) {
            if (bus.isRTUopen()) {
                bus.closeRTU(this.task, this.doClose.bind(this, e));
            }
            else
                this.doClose(e);
        }
    }
    splitAddresses(module, e) {
        debug('Split addresses');
        if (this.isSplitted)
            return false;
        this.isSplitted = true;
        // split request into single parts to avoid invalid address errors as often as possible
        if (this.preparedAddresses[this.preparedAddressesIndex].length > 1) {
            let startAddress = this.preparedAddresses[this.preparedAddressesIndex].address;
            let registerType = this.preparedAddresses[this.preparedAddressesIndex].registerType;
            let length = this.preparedAddresses[this.preparedAddressesIndex].length;
            this.preparedAddresses[this.preparedAddressesIndex].length = 1;
            for (let l = 1; l < length; l++) {
                this.preparedAddresses.push({
                    address: startAddress + l,
                    registerType: registerType,
                    length: 1,
                });
            }
        }
        else {
            debug(module +
                ' splitting: ' +
                (e.message ? e.message : 'error') +
                ': (bus: ' +
                this.slaveId.busid +
                ', slave: ' +
                this.slaveId.slaveid +
                ', address: ' +
                this.preparedAddresses[this.preparedAddressesIndex].address +
                ' length: ' +
                this.preparedAddresses[this.preparedAddressesIndex].length +
                ')');
            this.preparedAddressesIndex++;
        }
        return true;
    }
    reopenAndContinue() {
        let bus = bus_1.Bus.getBus(this.slaveId.busid);
        if (bus)
            bus
                .reconnectRTU(this.task)
                .then((_rc) => {
                this.next(ModbusStates.Processing, this.processAction);
            })
                .catch((e) => {
                log.log(specification_1.LogLevelEnum.error, e.message);
                if (bus.isRTUopen())
                    this.next(ModbusStates.Processing, this.processAction);
                else
                    this.next(this.state, () => {
                        this.closeAction(e);
                    }, this.closeAction.name);
            });
    }
    retryProcessAction(module, e) {
        if (e.stack)
            debug(e.stack);
        // store the error
        // This can be overridden, if next try succeeds.
        let address = this.preparedAddresses[this.preparedAddressesIndex].address;
        let length = this.preparedAddresses[this.preparedAddressesIndex].length;
        length = length ? length : 1;
        for (let a = address; a < address + length; a++)
            switch (this.preparedAddresses[this.preparedAddressesIndex].registerType) {
                case specification_shared_1.ModbusRegisterType.AnalogInputs:
                    this.result.analogInputs.set(a, { error: e });
                    break;
                case specification_shared_1.ModbusRegisterType.HoldingRegister:
                    this.result.holdingRegisters.set(a, { error: e });
                    break;
                case specification_shared_1.ModbusRegisterType.Coils:
                    this.result.coils.set(a, { error: e });
                    break;
                case specification_shared_1.ModbusRegisterType.DiscreteInputs:
                    this.result.discreteInputs.set(a, { error: e });
                    break;
            }
        if (e.errno == 'ETIMEDOUT') {
            let bus = bus_1.Bus.getBus(this.slaveId.busid);
            let slave = bus?.getSlaveBySlaveId(this.slaveId.slaveid);
            if (slave)
                debug(' Timeout. continue with next data task: ' +
                    this.task +
                    ' slave: ' +
                    this.slaveId.slaveid +
                    ' timeout: ' +
                    slave.modbusTimout +
                    (e.readDetails ? e.readDetails : ''));
            else
                debug(' Timeout. continue with next data');
            let success = this.splitAddresses(module, e);
            if (!success)
                this.preparedAddressesIndex++;
            this.next(ModbusStates.Processing, this.processAction);
        }
        else if (e.modbusCode) {
            switch (e.modbusCode) {
                case 1: //Illegal Function Code
                    // reopen RTU and start with next addresses
                    this.preparedAddressesIndex++;
                    this.reopenAndContinue();
                    break;
                case 2: // Illegal Address
                    debug('retryProcessAction: ' + e.message);
                    // split request into single parts to avoid invalid address errors as often as possible
                    let success = this.splitAddresses(module, e);
                    // Need to reopen the RTU connection, because of it's errourous state after this error
                    // then continue with next addresses
                    if (success)
                        this.reopenAndContinue();
                    else {
                        this.preparedAddressesIndex++;
                        this.reopenAndContinue();
                    }
                    break;
                default:
                    log.log(specification_1.LogLevelEnum.error, 'Modbus Error: ' + e.modbusCode);
                    if (e.readDetails)
                        debug('Modbus Error: ' + e.modbusCode + ' ' + e.readDetails);
                    this.next(this.state, () => {
                        this.closeAction(e);
                    }, this.closeAction.name);
            }
        }
        else {
            let readDetails = '';
            if (e.readDetails)
                readDetails = e.readDetails;
            this.logNotice(module + readDetails + ': ' + e.message);
            if (this.preparedAddressesIndex < this.preparedAddresses.length)
                if (this.preparedAddresses[this.preparedAddressesIndex].length > 1) {
                    this.splitAddresses(module, e);
                    debug(' Error. splitting task: ' +
                        this.task +
                        ' slave: ' +
                        this.slaveId.slaveid +
                        ' error: ' +
                        e.message +
                        'addresses: ' +
                        JSON.stringify(this.preparedAddresses[this.preparedAddressesIndex]));
                    this.next(ModbusStates.Processing, this.processAction);
                }
                else if (this.retryCount++ < 2) {
                    debug('Retrying ' + readDetails);
                    // Give the device some time to get ready after error
                    setTimeout(() => {
                        this.next(ModbusStates.Processing, this.processAction);
                    }, 20);
                }
                else
                    this.next(this.state, () => {
                        this.closeAction(e);
                    }, this.closeAction.name);
            else
                this.next(this.state, () => {
                    this.closeAction(e);
                }, this.closeAction.name);
        }
    }
    processResultAction() {
        debugNext('result: slave: ' + this.slaveId.busid + '/' + this.slaveId.slaveid + ' address/value');
        for (let key of this.result.holdingRegisters.keys()) {
            debug('holdingRegisters(' + this.pid + '): (' + key + '/' + JSON.stringify(this.result.holdingRegisters.get(key)) + ')');
        }
        for (let key of this.result.analogInputs.keys()) {
            debug('analogInputs(' + this.pid + '): (' + key + '/' + JSON.stringify(this.result.analogInputs.get(key)) + ')');
        }
        for (let key of this.result.coils.keys()) {
            debug('coils(' + this.pid + '): (' + key + '/' + JSON.stringify(this.result.coils.get(key)) + ')');
        }
        for (let key of this.result.discreteInputs.keys()) {
            debug('discreteInputs(' + this.pid + '): (' + key + '/' + JSON.stringify(this.result.discreteInputs.get(key)) + ')');
        }
        this.returnAction(this.result);
    }
    static getStatus(slaveId) {
        if (ModbusStateMachine.slaveStates.get(slaveId))
            return ModbusStateMachine.slaveStates.get(slaveId);
        else
            return SlaveStates.disconnected;
    }
}
exports.ModbusStateMachine = ModbusStateMachine;
class ModbusCache {
    static { this.readMutex = new async_mutex_1.Mutex(); }
    constructor(task, printLogs) {
        this.task = task;
        this.printLogs = printLogs;
    }
    //static resultMutex:Mutex
    writeRegisters(slaveId, startaddress, registerType, data) {
        return new Promise((resolve, reject) => {
            new ModbusStateMachine('write', this.printLogs, slaveId, new Set(), (data) => {
                resolve();
            }, reject).prepareWriteAction(startaddress, registerType, data);
        });
    }
    submitGetHoldingRegisterRequest(slaveId, addresses) {
        return new Promise((resolve, reject) => {
            debug('submitGetHoldingRegisterRequest bus:' + slaveId.busid + 'slave: ' + slaveId.slaveid);
            if (slaveId.slaveid == -1) {
                reject(new Error('no slaveId passed to submitGetHoldingRegisterRequest'));
            }
            else {
                new ModbusStateMachine(this.task, this.printLogs, slaveId, addresses, resolve, reject).loadAction();
            }
        });
    }
    static getStatus(slaveId) {
        return ModbusStateMachine.getStatus(slaveId);
    }
}
exports.ModbusCache = ModbusCache;
exports.exportedForTesting = {
    ModbusStateMachine,
};
//# sourceMappingURL=modbuscache.js.map