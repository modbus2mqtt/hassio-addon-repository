"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MqttDiscover = void 0;
const tslib_1 = require("tslib");
const config_1 = require("./config");
const specification_1 = require("@modbus2mqtt/specification");
const util_1 = require("util");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const specification_shared_2 = require("@modbus2mqtt/specification.shared");
const mqtt_1 = require("mqtt");
const modbus_1 = require("./modbus");
const bus_1 = require("./bus");
const configbus_1 = require("./configbus");
const debug_1 = tslib_1.__importDefault(require("debug"));
const specification_2 = require("@modbus2mqtt/specification");
const server_shared_1 = require("@modbus2mqtt/server.shared");
const async_mutex_1 = require("async-mutex");
const debug = (0, debug_1.default)('mqttdiscover');
const debugAction = (0, debug_1.default)('actions');
const debugMqttClient = (0, debug_1.default)('mqttclient');
const log = new specification_2.Logger('mqttdiscover');
const defaultPollCount = 50; // 5 seconds
const retain = { retain: true, qos: 1 };
const modbusValues = 'modbusValues';
class BusSlave {
    constructor(busid, slaveid) {
        this.busid = busid;
        this.slaveid = slaveid;
    }
    get key() {
        return `${this.busid}${config_1.Config.getFileNameFromSlaveId(this.slaveid)}`;
    }
}
class MqttDiscover {
    static { this.lastMessage = ''; }
    validate(_discover) {
        // currently no meaningful checks
    }
    onDestroy() {
        if (this.client)
            this.client.end();
    }
    static getInstance() {
        if (MqttDiscover.instance)
            return MqttDiscover.instance;
        MqttDiscover.instance = new MqttDiscover();
        return MqttDiscover.instance;
    }
    static addSpecificationToSlave(slave) {
        let rc = slave.clone();
        let specificationId = rc.getSpecificationId();
        if (specificationId) {
            let spec = specification_1.ConfigSpecification.getSpecificationByFilename(specificationId);
            rc.setSpecification(spec);
        }
        return rc;
    }
    constructor() {
        this.subscribedSlaves = [];
        this.isPolling = false;
        this.pollMutex = new async_mutex_1.Mutex();
        this.pollCounts = new Map();
        this.triggers = [];
        this.mqttClientMutex = new async_mutex_1.Mutex();
        this.onConnectCallbacks = [];
        const reg = new FinalizationRegistry(this.onDestroy.bind(this));
        this.isSubscribed = false;
        reg.register(this, 0);
        configbus_1.ConfigBus.addListener(config_1.ConfigListenerEvent.addSlave, this.onUpdateSlave.bind(this));
        configbus_1.ConfigBus.addListener(config_1.ConfigListenerEvent.deleteSlave, this.onDeleteSlave.bind(this));
        configbus_1.ConfigBus.addListener(config_1.ConfigListenerEvent.updateSlave, this.onUpdateSlave.bind(this));
        configbus_1.ConfigBus.addListener(config_1.ConfigListenerEvent.deleteBus, this.onDeleteBus.bind(this));
    }
    // bus/slave name:entity id:payload
    getSlaveBaseTopics() {
        return this.subscribedSlaves.map((value) => value.getBaseTopic());
    }
    getSlave(topic) {
        return this.subscribedSlaves.find((value) => topic.startsWith(value.getBaseTopic()));
    }
    generateEntityConfigurationTopic(slave, ent) {
        let haType = 'sensor';
        if (ent.readonly)
            switch (ent.converter.name) {
                case 'binary':
                    haType = 'binary_sensor';
                    break;
            }
        else
            switch (ent.converter.name) {
                case 'binary':
                    haType = 'switch';
                    break;
                default:
                    haType = ent.converter.name;
            }
        return (config_1.Config.getConfiguration().mqttdiscoveryprefix +
            '/' +
            haType +
            '/' +
            slave.getBusId() +
            's' +
            slave.getSlaveId() +
            '/e' +
            ent.id +
            '/config');
    }
    generateDiscoveryPayloads(slave, spec) {
        let payloads = [];
        // instantiate the converters
        try {
            let language = config_1.Config.getConfiguration().mqttdiscoverylanguage;
            if (language)
                for (let e of spec.entities) {
                    // !slave.suppressedEntities.includes(e.id)
                    if (e.id >= 0 && !e.variableConfiguration) {
                        let converter = specification_1.ConverterMap.getConverter(e);
                        let ent = e;
                        if (converter) {
                            var obj = new Object();
                            obj.device = new Object();
                            let slaveName = slave.getName();
                            if (!obj.device.name)
                                if (slaveName)
                                    obj.device.name = slaveName;
                                else {
                                    let name = (0, specification_shared_1.getSpecificationI18nName)(spec, language, false);
                                    if (name)
                                        obj.device.name = name;
                                }
                            if (!obj.device.manufacturer && spec.manufacturer)
                                obj.device.manufacturer = spec.manufacturer;
                            if (!obj.device.model && spec.model)
                                obj.device.model = spec.model;
                            obj.device.identifiers = ['m2m' + slave.getBusId() + 's' + slave.getSlaveId()];
                            spec.entities.forEach((ent1) => {
                                if (ent1.variableConfiguration) {
                                    switch (ent1.variableConfiguration.targetParameter) {
                                        case specification_shared_2.VariableTargetParameters.deviceSerialNumber:
                                            let sn = ent1.mqttValue;
                                            if (sn)
                                                obj.device.serial_number = sn;
                                            break;
                                        case specification_shared_2.VariableTargetParameters.deviceSWversion:
                                            let sv = ent1.mqttValue;
                                            if (sv)
                                                obj.device.sw_version = sv;
                                            break;
                                        // case VariableTargetParameters.deviceIdentifiers:
                                        //   let o = (ent1 as ImodbusEntity).mqttValue
                                        //   if (o) obj.device.identifiers.push(o)
                                        //   break
                                        case specification_shared_2.VariableTargetParameters.entityUom:
                                            if (e.id == ent1.variableConfiguration.entityId && converter.getParameterType(e) === 'Inumber') {
                                                obj.unit_of_measurement = ent1.mqttValue;
                                            }
                                            break;
                                        // Add additionial device attributes here
                                        // obj.device.<???> = (ent1 as ImodbusEntity).mqttValue;
                                    }
                                }
                            });
                            if (e.forceUpdate)
                                obj.force_update = true;
                            if (e.entityCategory && e.entityCategory.length)
                                obj.entity_category = e.entityCategory;
                            if (e.icon)
                                obj.icon = e.icon;
                            if (!e.variableConfiguration) {
                                let name = (0, specification_shared_2.getSpecificationI18nEntityName)(spec, language, e.id);
                                let filename = config_1.Config.getFileNameFromSlaveId(slave.getSlaveId());
                                if (!obj.name && name)
                                    obj.name = name;
                                if (!obj.object_id && e.mqttname)
                                    obj.object_id = e.mqttname;
                                if (!obj.unique_id)
                                    obj.unique_id = 'M2M' + slave.getBusId() + filename + e.mqttname;
                                if (!obj.value_template)
                                    obj.value_template = e.value_template ? e.value_template : '{{ value_json.' + obj.object_id + ' }}';
                                if (!obj.state_topic)
                                    obj.state_topic = slave.getStateTopic();
                                if (!obj.availability && !obj.availability_topic)
                                    obj.availability_topic = slave.getAvailabilityTopic();
                                let cmdTopic = slave.getEntityCommandTopic(ent);
                                if (!obj.command_topic && !e.readonly)
                                    obj.command_topic = cmdTopic ? cmdTopic.commandTopic : undefined;
                                switch (converter.getParameterType(e)) {
                                    case 'Iselect':
                                        if (!e.readonly) {
                                            let ns = e.converterParameters;
                                            if (e.converter.name === 'select' && ns && ns.optionModbusValues && ns.optionModbusValues.length) {
                                                obj.options = [];
                                                for (let modbusValue of ns.optionModbusValues)
                                                    obj.options.push((0, specification_shared_1.getSpecificationI18nEntityOptionName)(spec, language, e.id, modbusValue));
                                                if (obj.options == undefined || obj.options.length == 0)
                                                    log.log(specification_2.LogLevelEnum.warn, 'generateDiscoveryPayloads: No options specified for ' + obj.name);
                                                else
                                                    obj.options.forEach((o) => {
                                                        if (!o)
                                                            log.log(specification_2.LogLevelEnum.warn, 'generateDiscoveryPayloads: option with no text for ' + e.id);
                                                    });
                                            }
                                            obj.device_class = 'enum';
                                            if (e.converter.name === 'binary' && ns.device_class)
                                                obj.device_class = ns.device_class;
                                        }
                                        break;
                                    case 'Inumber':
                                        let nn = e.converterParameters;
                                        if (!obj.unit_of_measurement && nn && nn.uom)
                                            obj.unit_of_measurement = nn.uom;
                                        if (nn && nn.device_class && nn.device_class.toLowerCase() != 'none')
                                            obj.device_class = nn.device_class;
                                        if (nn && nn.state_class && nn.state_class)
                                            obj.state_class = MqttDiscover.getStateClass(nn.state_class);
                                        if (e.converter.name === 'number' && !e.readonly) {
                                            if (nn.step)
                                                obj.step = nn.step;
                                            if (nn.identification) {
                                                if (nn.identification.min != undefined)
                                                    obj.min = nn.identification.min;
                                                if (nn.identification.max != undefined)
                                                    obj.max = nn.identification.max;
                                            }
                                        }
                                        if (nn.decimals != undefined)
                                            obj.suggested_display_precision = nn.decimals;
                                        break;
                                    case 'Itext':
                                        if (!e.readonly) {
                                            let nt = e.converterParameters;
                                            if (nt.stringlength > 0)
                                                obj.max = nt.stringlength;
                                            if (nt.identification && nt.identification.length)
                                                obj.pattern = nt.identification;
                                        }
                                        break;
                                }
                                payloads.push({
                                    topic: this.generateEntityConfigurationTopic(slave, e),
                                    payload: JSON.stringify(obj),
                                    entityid: e.id,
                                });
                            }
                        }
                    }
                }
            else {
                log.log(specification_2.LogLevelEnum.error, 'generateDiscoveryPayloads: specification or language is undefined');
            }
        }
        catch (e) {
            debug('Exception ' + e.message);
            log.log(specification_2.LogLevelEnum.error, e.message);
        }
        return payloads;
    }
    static getStateClass(state_class) {
        switch (state_class) {
            case specification_shared_1.EnumStateClasses.measurement:
                return 'measurement';
            case specification_shared_1.EnumStateClasses.total:
                return 'total';
            case specification_shared_1.EnumStateClasses.total_increasing:
                return 'total_increasing';
            default:
                return '';
        }
    }
    getSubscribedSlaveFromDiscoveryTopic(topic) {
        let pathes = topic.split('/');
        if (pathes[2].match(/^[0-9]*s[0-9]*$/g) == null || pathes[3].match(/^e[0-9]*$/g) == null)
            return {};
        let busSlave = pathes[2].split('s');
        let busId = parseInt(busSlave[0]);
        let slaveId = parseInt(busSlave[1]);
        let entityId = parseInt(pathes[3].substring(1));
        return {
            slave: this.subscribedSlaves.find((s) => s.getBusId() == busId && s.getSlaveId() == slaveId),
            entityId: entityId,
        };
    }
    static getBusAndSlaveFromTopic(topic) {
        let parts = topic.split('/');
        let msg = '';
        if (parts.length > 2) {
            let busid = Number.parseInt(parts[2].substring(0, 1));
            let slaveid = Number.parseInt(parts[2].substring(2));
            let bus = bus_1.Bus.getBus(busid);
            if (!bus) {
                log.log(specification_2.LogLevelEnum.error, 'getBusAndSlaveFromTopic: invalid busid ' + busid);
                throw new Error('getBusAndSlaveFromTopic' + busid);
            }
            const device = bus.getSlaveBySlaveId(slaveid);
            if (device)
                return {
                    bus: bus,
                    slave: device,
                };
            else
                throw new Error('device ' + slaveid + 'not found for Bus' + busid);
        }
        throw new Error('Invalid topic. No bus and slave information: ' + topic);
    }
    onMqttCommandMessage(topic, payload) {
        try {
            let busAndSlave = MqttDiscover.getBusAndSlaveFromTopic(topic);
            if (undefined == busAndSlave.slave.specificationid)
                throw new Error('No specification Id for slave available');
            const spec = specification_1.ConfigSpecification.getSpecificationByFilename(busAndSlave.slave.specificationid);
            let parts = topic.split('/');
            if (spec && parts.length >= 4) {
                const entity = spec.entities.find((ent) => {
                    return 'e' + ent.id == parts[3];
                });
                if (entity) {
                    const cnv = specification_1.ConverterMap.getConverter(entity);
                    if (cnv) {
                        let promise;
                        let modbus = parts.length == 5 && parts[4] == modbusValues;
                        if (!config_1.Config.getConfiguration().fakeModbus) {
                            if (modbus)
                                promise = modbus_1.Modbus.writeEntityModbus(busAndSlave.bus, busAndSlave.slave.slaveid, entity, {
                                    data: JSON.parse(payload.toString()),
                                    buffer: Buffer.allocUnsafe(0),
                                });
                            else
                                promise = modbus_1.Modbus.writeEntityMqtt(busAndSlave.bus, busAndSlave.slave.slaveid, spec, entity.id, payload.toString());
                        } // for Testing
                        else
                            return (modbus ? 'Modbus ' : 'MQTT ') + payload.toString();
                    }
                }
                else
                    throw new Error('Entity not found topic ' + topic);
            }
            else
                throw new Error('No entity passed to command topic ' + topic);
        }
        catch (e) {
            return e.message;
        }
        return 'unknown issue';
    }
    sendCommandModbus(slave, entity, modbus, payload) {
        const cnv = specification_1.ConverterMap.getConverter(entity);
        if (cnv) {
            if (modbus)
                return modbus_1.Modbus.writeEntityModbus(bus_1.Bus.getBus(slave.getBusId()), slave.getSlaveId(), entity, {
                    data: [Number.parseInt(payload)],
                    buffer: Buffer.allocUnsafe(0),
                });
            else {
                let spec = slave.getSpecification();
                if (spec)
                    return modbus_1.Modbus.writeEntityMqtt(bus_1.Bus.getBus(slave.getBusId()), slave.getSlaveId(), spec, entity.id, payload.toString());
            }
        }
        return new Promise((_resolve, reject) => {
            reject(new Error('No Converter or spec found for spec/entity ' + slave.getSpecificationId() + '/' + entity.mqttname));
        });
    }
    // returns a promise for testing
    onMqttMessage(topic, payload) {
        if (topic) {
            debug('onMqttMessage: ' + topic);
            let s = this.subscribedSlaves.find((s) => topic.startsWith(s.getBaseTopic()));
            if (s) {
                if (s.getTriggerPollTopic() == topic) {
                    debug('Triggering Poll');
                    return this.readModbusAndPublishState(s);
                }
                else if (payload != undefined && payload != null) {
                    if (topic == s.getCommandTopic())
                        return this.sendCommand(s, payload.toString('utf-8'));
                    else if (topic.startsWith(s.getBaseTopic()) && topic.indexOf('/set/') != -1) {
                        return this.sendEntityCommandWithPublish(s, topic, payload.toString('utf-8'));
                    }
                }
            }
        }
        return new Promise((resolve) => {
            resolve();
        });
    }
    sendEntityCommandWithPublish(slave, topic, payload) {
        let entity = slave.getEntityFromCommandTopic(topic);
        if (entity && !entity.readonly)
            return new Promise((resolve, reject) => {
                this.sendEntityCommand(slave, topic, payload.toString())
                    .then(() => {
                    this.readModbusAndPublishState(slave).then(resolve).catch(reject);
                })
                    .catch(reject);
            });
        log.log(specification_2.LogLevelEnum.error, 'No writable entity found for topic ' + topic);
        return new Promise((_resolve, reject) => {
            reject(new Error('No writable entity found for topic ' + topic));
        });
    }
    sendEntityCommand(slave, topic, payload) {
        let entity = slave.getEntityFromCommandTopic(topic);
        if (entity && !entity.readonly)
            return this.sendCommandModbus(slave, entity, topic.endsWith('/set/modbus/'), payload.toString());
        log.log(specification_2.LogLevelEnum.error, 'No writable entity found for topic ' + topic);
        return new Promise((_resolve, reject) => {
            reject(new Error('No writable entity found for topic ' + topic));
        });
    }
    sendCommand(slave, payload) {
        return new Promise((resolve, reject) => {
            let p = JSON.parse(payload);
            let promisses = [];
            if (typeof p != 'object') {
                reject(new Error('Send Command failed: payload is an object ' + payload));
                return;
            }
            if (p.modbusValues) {
                Object.getOwnPropertyNames(p.modbusValues).forEach((propName) => {
                    let entity = slave.getSpecification()?.entities.find((e) => e.mqttname == propName);
                    if (entity && !entity.readonly)
                        promisses.push(this.sendCommandModbus(slave, entity, true, p.modbusValues[propName].toString()));
                });
            }
            Object.getOwnPropertyNames(p).forEach((propName) => {
                let value = p[propName].toString();
                let entity = slave.getSpecification()?.entities.find((e) => e.mqttname == propName);
                if (entity && !entity.readonly && (p.modbusValues == undefined || p.modbusValues[propName] == undefined))
                    promisses.push(this.sendCommandModbus(slave, entity, false, value));
            });
            if (promisses.length > 0)
                Promise.all(promisses).then(() => {
                    this.readModbusAndPublishState(slave).then(resolve).catch(reject);
                });
            else
                reject(new Error('No writable entity found in payload ' + payload));
        });
    }
    containsTopic(tp, tps) {
        let t = tps.findIndex((t) => tp.topic === t.topic);
        return -1 != t;
    }
    generateDiscoveryEntities(slave, deleteAllEntities = false) {
        let tAndPs = [];
        let subscribedSlave = this.subscribedSlaves.find((s) => 0 == server_shared_1.Slave.compareSlaves(s, slave));
        let newSpec = slave.getSpecification();
        let oldSpec = subscribedSlave ? subscribedSlave?.getSpecification() : undefined;
        if (oldSpec && oldSpec.entities) {
            oldSpec.entities.forEach((oldEnt) => {
                let newEnt = newSpec?.entities.find((newE) => newE.id == oldEnt.id);
                let newTopic = newEnt ? this.generateEntityConfigurationTopic(slave, newEnt) : undefined;
                let oldTopic = oldEnt ? this.generateEntityConfigurationTopic(slave, oldEnt) : undefined;
                if (oldTopic)
                    if (!newSpec ||
                        deleteAllEntities ||
                        slave.getNoDiscovery() ||
                        slave.getNoDiscoverEntities().includes(oldEnt.id) ||
                        !newEnt ||
                        newTopic != oldTopic) {
                        if (oldEnt)
                            debug('delete entity ' + slave.getBusId() + 's' + slave.getSlaveId() + '/e' + oldEnt.id);
                        else
                            debug('delete Bus/slave ');
                        tAndPs.push({ topic: oldTopic, payload: Buffer.alloc(0), entityid: 0 }); // delete entity
                    }
            });
        }
        if (!deleteAllEntities && newSpec && newSpec.entities) {
            this.generateDiscoveryPayloads(slave, newSpec).forEach((tp) => {
                if (!slave.getNoDiscoverEntities().includes(tp.entityid) && !slave.getNoDiscovery()) {
                    tAndPs.push({ topic: tp.topic, payload: tp.payload, entityid: 0 }); // write entity
                }
            });
        }
        return tAndPs;
    }
    error(msg) {
        let message = "MQTT: Can't connect to " + config_1.Config.getConfiguration().mqttconnect.mqttserverurl + ' ' + msg.toString();
        if (message !== MqttDiscover.lastMessage)
            log.log(specification_2.LogLevelEnum.error, message);
        MqttDiscover.lastMessage = message;
    }
    executeActions(mqttClient) {
        let callback = this.onConnectCallbacks.shift();
        while (mqttClient && mqttClient.connected && callback) {
            callback(mqttClient);
            callback = this.onConnectCallbacks.shift();
        }
    }
    handleErrors(e) {
        log.log(specification_2.LogLevelEnum.error, 'MQTT error: ' + e.message);
    }
    onConnect(mqttClient) {
        debug('reconnecting MQTT');
        this.resubscribe(this.client);
        this.executeActions(this.client);
    }
    connectMqtt(connectionData) {
        let mqttConnect = config_1.Config.getConfiguration().mqttconnect;
        if (config_1.Config.getConfiguration().mqttusehassio && config_1.Config.mqttHassioLoginData)
            mqttConnect = config_1.Config.mqttHassioLoginData;
        let conn = () => {
            if (!connectionData)
                connectionData = mqttConnect;
            if (!connectionData) {
                this.handleErrors(new Error('No mqtt connection configured.'));
                return;
            }
            if (connectionData.mqttserverurl) {
                let opts = connectionData;
                // connect need IClientOptions which has some additional properties in the type
                let iopts = connectionData;
                iopts.log = (...args) => {
                    let message = args.shift();
                    debugMqttClient((0, util_1.format)(message, args));
                };
                iopts.clean = false;
                iopts.reconnectPeriod = 1000;
                iopts.keepalive = 50000;
                iopts.clientId = config_1.Config.getConfiguration().mqttbasetopic;
                if (iopts.ca == undefined)
                    delete iopts.ca;
                if (iopts.key == undefined)
                    delete iopts.key;
                if (iopts.cert == undefined)
                    delete iopts.cert;
                if (this.client)
                    this.client.reconnect(opts);
                else
                    this.client = (0, mqtt_1.connect)(connectionData.mqttserverurl, opts);
                this.client.removeAllListeners('error');
                this.client.removeAllListeners('message');
                this.client.removeAllListeners('connect');
                this.client.removeAllListeners('connect');
                this.client.on('error', this.handleErrors.bind(this));
                this.client.on('message', this.onMqttMessage.bind(this));
                this.client.on('connect', this.onConnect.bind(this, this.client));
                this.client.on('reconnect', this.onConnect.bind(this, this.client));
            }
            else {
                this.handleErrors(new Error('mqtt server url is not defined'));
            }
        };
        if (this.client != undefined) {
            if (this.equalConnectionData(this.client, mqttConnect)) {
                if (!this.client.connected)
                    conn();
                else
                    this.executeActions(this.client);
            }
            else {
                // reconnect with new connection date
                this.client.end(() => {
                    this.client = undefined;
                    conn();
                });
            }
        }
        else
            conn();
    }
    validateConnection(connectionData, callback) {
        if (connectionData && connectionData.mqttserverurl != undefined) {
            let client = (0, mqtt_1.connect)(connectionData.mqttserverurl, connectionData);
            client.on('error', (e) => {
                client.end(() => { });
                callback(false, e.toString());
            });
            client.on('connect', () => {
                callback(true, 'OK');
                if (client)
                    client.end(() => { });
            });
        }
        else
            callback(false, 'no mqttserverlurl passes');
    }
    equalConnectionData(client, clientConfiguration) {
        return (client.options.protocol + '://' + client.options.host + ':' + client.options.port == clientConfiguration.mqttserverurl &&
            client.options.username == clientConfiguration.username &&
            client.options.password == clientConfiguration.password);
    }
    getMqttClient(onConnectCallback) {
        this.onConnectCallbacks.push(onConnectCallback);
        this.connectMqtt(undefined);
    }
    resubscribe(mqttClient) {
        this.subscribedSlaves.forEach((slave) => {
            let options = { qos: this.generateQos(slave, slave.getSpecification()) };
            mqttClient.subscribe(slave.getTriggerPollTopic(), options);
            let cmdTopic = slave.getCommandTopic();
            if (cmdTopic) {
                mqttClient.subscribe(cmdTopic, options);
                mqttClient.subscribe(slave.getEntityCommandTopicFilter(), options);
            }
        });
    }
    publish() { }
    unsubscribe() { }
    // Discovery update when
    // Bus changed
    // Bus deleted
    // Slave changed: subscribeSlave
    // Slave deleted: unsubscribeSlave
    // Specification changed
    // Specification deleted
    // Bus changed: Iterate all slaves of bus PublishDiscovery and State
    // Bus deleted: nothing to do, but delete discovery
    // Slave changed:  PublishDiscovery and State of changed Slave, delete outdated discoveries
    // Slave deleted: nothing to do, but delete outdated discoveries
    // Specification changed: Iterate all Busses/Slaves update Discovery and State delete outdated discoveries
    // Specification deleted: Find previously assigned slaves and publish Discovery and State delete outdated discoveries
    onUpdateSlave(slave) {
        return new Promise((resolve, reject) => {
            let newSlave = false;
            let idx = this.subscribedSlaves.findIndex((s) => 0 == server_shared_1.Slave.compareSlaves(s, slave));
            if (idx < 0) {
                debug('Adding to subscribedSlaves: ' + slave.getName());
                this.subscribedSlaves.push(slave);
                newSlave = true;
            }
            let busId = slave.getBusId();
            let bus = busId != undefined ? bus_1.Bus.getBus(busId) : undefined;
            if (bus) {
                let tAndPs = this.generateDiscoveryEntities(slave);
                if (tAndPs.length == 0) {
                    let message = 'No entities found for discovery slave: ' + slave.getSlaveId();
                    log.log(specification_2.LogLevelEnum.error, message);
                    reject(new Error(message));
                    return;
                }
                if (idx >= 0)
                    // delete after generateDiscoveryEntities, because entity deletions need to be recognized
                    this.subscribedSlaves[idx] = slave;
                this.getMqttClient((mqttClient) => {
                    log.log(specification_2.LogLevelEnum.notice, 'Publish Discovery: length:' + tAndPs.length);
                    tAndPs.forEach((tAndP) => {
                        mqttClient.publish(tAndP.topic, tAndP.payload, retain);
                    });
                    if (newSlave)
                        this.resubscribe(mqttClient);
                });
                // Wait for discovery
                setTimeout(() => {
                    this.readModbusAndPublishState(slave)
                        .then(() => {
                        resolve();
                    })
                        .catch(reject);
                }, 500);
            }
        });
    }
    onDeleteBus(busid) {
        return new Promise((resolve, reject) => {
            let slaves = new Set();
            let deletions = [];
            let tAndPs = [];
            this.subscribedSlaves.forEach((ss, idx, object) => {
                let sbusId = ss.getBusId();
                if (sbusId == busid) {
                    tAndPs.concat(this.generateDiscoveryEntities(ss, true));
                    object.splice(idx, 1);
                }
            });
            this.getMqttClient((mqttClient) => {
                tAndPs.forEach((tAndP) => {
                    mqttClient.publish(tAndP.topic, tAndP.payload, retain);
                });
                resolve();
            });
        });
    }
    readModbusAndPublishState(slave) {
        return new Promise((resolve, reject) => {
            let obs = MqttDiscover.readModbus(slave);
            if (obs)
                obs.subscribe((spec) => {
                    this.publishState(slave, spec)
                        .then(() => {
                        resolve(spec);
                    })
                        .catch(reject);
                });
        });
    }
    static readModbus(slave) {
        let bus = bus_1.Bus.getBus(slave.getBusId());
        if (bus)
            return modbus_1.Modbus.getModbusSpecification('poll', bus, slave.getSlaveId(), slave.getSpecificationId(), (e) => {
                log.log(specification_2.LogLevelEnum.error, 'reading spec failed' + e.message);
                //Ignore this error continue with next
            });
        return undefined;
    }
    generateQos(slave, spec) {
        let qos = slave.getQos();
        if ((qos == undefined || qos == -1) && spec != undefined)
            if (spec.entities.find((e) => e.readonly == false) != undefined)
                return 1;
            else
                return 0;
        return qos ? qos : 1;
    }
    publishState(slave, spec) {
        return new Promise((resolve) => {
            debug('publish State aquire mqttClient');
            this.getMqttClient((mqttClient) => {
                debug('publish State executing');
                let topic = slave.getStateTopic();
                let bus = bus_1.Bus.getBus(slave.getBusId());
                if (this.client && bus && spec) {
                    try {
                        debug('PublishState');
                        mqttClient.publish(topic, slave.getStatePayload(spec.entities), { qos: this.generateQos(slave, spec) });
                        mqttClient.publish(slave.getAvailabilityTopic(), 'online', { qos: this.generateQos(slave, spec) });
                        resolve();
                    }
                    catch (e) {
                        try {
                            mqttClient.publish(slave.getAvailabilityTopic(), 'offline', { qos: this.generateQos(slave, spec) });
                        }
                        catch (e) {
                            // ignore the error
                            debug('Error ' + e.message);
                        }
                    }
                }
                else {
                    if (!this.client)
                        log.log(specification_2.LogLevelEnum.error, 'No MQTT Client available');
                    if (!bus)
                        log.log(specification_2.LogLevelEnum.error, 'No Bus available');
                    if (!spec)
                        log.log(specification_2.LogLevelEnum.error, 'No Spec available');
                }
            });
        });
    }
    // poll gets triggered every 0.1 second
    // Depending on the pollinterval of the slaves it triggers publication of the current state of the slave
    poll() {
        return new Promise((resolve, error) => {
            if (this.isPolling) {
                resolve();
            }
            this.isPolling = true;
            let needPolls = [];
            bus_1.Bus.getBusses().forEach((bus) => {
                bus.getSlaves().forEach((slave) => {
                    if (slave.pollMode != server_shared_1.PollModes.noPoll) {
                        let sl = new server_shared_1.Slave(bus.getId(), slave, config_1.Config.getConfiguration().mqttbasetopic);
                        let pc = this.pollCounts.get(sl.getKey());
                        let trigger = this.triggers.find((k) => 0 == server_shared_1.Slave.compareSlaves(k.slave, sl));
                        if (pc == undefined || pc > (slave.pollInterval != undefined ? slave.pollInterval / 100 : defaultPollCount))
                            pc = 0;
                        if (pc == 0 || trigger != undefined) {
                            let s = MqttDiscover.addSpecificationToSlave(new server_shared_1.Slave(bus.getId(), slave, config_1.Config.getConfiguration().mqttbasetopic));
                            if (slave.specification) {
                                needPolls.push({ slave: s, pollMode: trigger == undefined ? server_shared_1.PollModes.intervall : server_shared_1.PollModes.trigger });
                            }
                            else {
                                if (slave.specificationid)
                                    log.log(specification_2.LogLevelEnum.error, 'No specification found for slave ' + s.getSlaveId() + ' specid: ' + s.getSpecificationId());
                            }
                        }
                        this.pollCounts.set(sl.getKey(), ++pc);
                    }
                });
            });
            if (needPolls.length > 0) {
                let tAndP = [];
                let pollDeviceCount = 0;
                needPolls.forEach((bs) => {
                    // Trigger state only if it's configured to do so
                    let spMode = bs.slave.getPollMode();
                    let idx = this.triggers.findIndex((k) => 0 == server_shared_1.Slave.compareSlaves(k.slave, bs.slave));
                    if (spMode == undefined ||
                        [server_shared_1.PollModes.intervall, server_shared_1.PollModes.intervallAndTrigger].includes(spMode) ||
                        bs.pollMode == server_shared_1.PollModes.trigger ||
                        (idx >= 0 && this.triggers[idx].force)) {
                        let bus = bus_1.Bus.getBus(bs.slave.getBusId());
                        if (bus)
                            modbus_1.Modbus.getModbusSpecification('poll', bus, bs.slave.getSlaveId(), bs.slave.getSpecificationId(), (e) => {
                                log.log(specification_2.LogLevelEnum.error, 'reading spec failed' + e.message);
                            }).subscribe((spec) => {
                                tAndP.push({ topic: bs.slave.getStateTopic(), payload: bs.slave.getStatePayload(spec.entities), entityid: 0 });
                                tAndP.push({ topic: bs.slave.getAvailabilityTopic(), payload: 'online', entityid: 0 });
                                bus.updateErrorsForSlaveId(bs.slave.getSlaveId(), spec);
                                pollDeviceCount++;
                                if (pollDeviceCount == needPolls.length)
                                    this.getMqttClient((mqttClient) => {
                                        debug('poll: publishing');
                                        tAndP.forEach((tAndP) => {
                                            mqttClient.publish(tAndP.topic, tAndP.payload);
                                        });
                                        resolve();
                                    });
                            });
                    }
                    // Remove trigger
                    if (idx >= 0)
                        this.triggers.splice(idx, 1);
                });
            }
        });
    }
    onDeleteSlave(slave) {
        return new Promise((resolve, reject) => {
            let idx = this.subscribedSlaves.findIndex((s) => s.getBaseTopic() == slave.getBaseTopic());
            if (idx >= 0)
                this.getMqttClient((mqttClient) => {
                    let tAndPs = this.generateDiscoveryEntities(slave, true);
                    this.subscribedSlaves.splice(idx, 1);
                    tAndPs.forEach((tAndP) => {
                        mqttClient.publish(tAndP.topic, tAndP.payload, retain);
                    });
                    mqttClient.unsubscribe(slave.getTriggerPollTopic());
                    let cmdTopic = slave.getCommandTopic();
                    if (cmdTopic) {
                        mqttClient.unsubscribe(cmdTopic);
                        mqttClient.unsubscribe(slave.getEntityCommandTopicFilter());
                    }
                    resolve();
                });
        });
    }
    startPolling() {
        if (this.interval == undefined) {
            this.interval = setInterval(() => {
                this.poll()
                    .then(() => { })
                    .catch(this.error);
            }, 100);
        }
    }
}
exports.MqttDiscover = MqttDiscover;
//# sourceMappingURL=mqttdiscover.js.map