"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigSpecification = exports.filesUrlPrefix = void 0;
exports.getSpecificationImageOrDocumentUrl = getSpecificationImageOrDocumentUrl;
const tslib_1 = require("tslib");
const yaml_1 = require("yaml");
const fs = tslib_1.__importStar(require("fs"));
const path = tslib_1.__importStar(require("path"));
const path_1 = require("path");
const log_1 = require("./log");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const specification_shared_2 = require("@modbus2mqtt/specification.shared");
const convertermap_1 = require("./convertermap");
const m2mspecification_1 = require("./m2mspecification");
const migrator_1 = require("./migrator");
const debug_1 = tslib_1.__importDefault(require("debug"));
const m2mgithub_1 = require("./m2mgithub");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const async_mutex_1 = require("async-mutex");
const log = new log_1.Logger('specification');
exports.filesUrlPrefix = 'specifications/files';
const debug = (0, debug_1.default)('configSpec');
//const baseTopic = 'modbus2mqtt';
//const baseTopicHomeAssistant = 'homeassistant';
class ConfigSpecification {
    static setMqttdiscoverylanguage(lang, ghToken) {
        ConfigSpecification.mqttdiscoverylanguage = lang;
        ConfigSpecification.githubPersonalToken = ghToken;
    }
    static { this.filesMutex = new async_mutex_1.Mutex(); }
    static getPublicDir() {
        return (0, path_1.join)(ConfigSpecification.yamlDir, 'public');
    }
    static getLocalDir() {
        return (0, path_1.join)(ConfigSpecification.yamlDir, 'local');
    }
    constructor() { }
    static getPublicSpecificationPath(spec) {
        return ConfigSpecification.yamlDir + '/public/specifications/' + spec.filename + '.yaml';
    }
    static getContributedSpecificationPath(spec) {
        return ConfigSpecification.yamlDir + '/contributed/specifications/' + spec.filename + '.yaml';
    }
    static getSpecificationPath(spec) {
        return ConfigSpecification.yamlDir + '/local/specifications/' + spec.filename + '.yaml';
    }
    static getLocalFilesPath(specfilename) {
        return (0, path_1.join)(ConfigSpecification.yamlDir, getSpecificationImageOrDocumentUrl('local', specfilename, ''));
    }
    static getPublicFilesPath(specfilename) {
        return (0, path_1.join)(ConfigSpecification.yamlDir, getSpecificationImageOrDocumentUrl('public', specfilename, ''));
    }
    static getContributedFilesPath(specfilename) {
        return (0, path_1.join)(ConfigSpecification.yamlDir, getSpecificationImageOrDocumentUrl('contributed', specfilename, ''));
    }
    appendSpecificationUrls(specfilename, urls) {
        let filesPath = ConfigSpecification.getLocalFilesPath(specfilename);
        if (filesPath && !fs.existsSync(filesPath))
            fs.mkdirSync(filesPath, { recursive: true });
        let files = { version: specification_shared_1.SPECIFICATION_FILES_VERSION, files: [] };
        let filesName = (0, path_1.join)(filesPath, 'files.yaml');
        return ConfigSpecification.filesMutex.runExclusive(() => {
            if (fs.existsSync(filesPath)) {
                try {
                    let content = fs.readFileSync(filesName, { encoding: 'utf8' });
                    files = (0, yaml_1.parse)(content.toString());
                    files = new migrator_1.Migrator().migrateFiles(files);
                }
                catch (e) {
                    debug('Unable to read Files directory for ' + filesName + '\n' + JSON.stringify(e));
                }
            }
            else {
                log.log(log_1.LogLevelEnum.notice, 'files path does not exist ' + filesPath);
            }
            log.log(log_1.LogLevelEnum.notice, JSON.stringify(files.files));
            log.log(log_1.LogLevelEnum.notice, JSON.stringify(urls));
            urls.forEach((url) => {
                if (files.files.find((uf) => uf.url == url.url && uf.usage == url.usage) == null) {
                    files.files.push(url);
                }
            });
            fs.writeFileSync(filesName, (0, yaml_1.stringify)(files), {
                encoding: 'utf8',
                flag: 'w',
            });
            let spec = ConfigSpecification.specifications.find((spec) => spec.filename == specfilename);
            if (spec)
                spec.files = files.files;
            return files && files.files ? files.files : undefined;
        });
    }
    appendSpecificationFiles(specfilename, filenames, usage) {
        let iurls = [];
        filenames.forEach((filename) => {
            if (!usage)
                usage = m2mspecification_1.M2mSpecification.getFileUsage(filename);
            let url = getSpecificationImageOrDocumentUrl(undefined, specfilename, filename);
            let iurl = { url: url, fileLocation: specification_shared_1.FileLocation.Local, usage: usage };
            iurls.push(iurl);
        });
        return this.appendSpecificationUrls(specfilename, iurls);
    }
    static { this.specifications = []; }
    static { this.yamlDir = ''; }
    readFilesYaml(directory, spec) {
        let fp = (0, path_1.join)(directory, 'files', spec.filename, 'files.yaml');
        if (fs.existsSync(fp)) {
            let src = fs.readFileSync(fp, { encoding: 'utf8' });
            let f = (0, yaml_1.parse)(src);
            f = new migrator_1.Migrator().migrateFiles(f);
            spec.files = f.files;
        }
        else {
            //log.log(LogLevelEnum.notice, 'File not found: ' + fp)
            spec.files = [];
        }
        spec.files.forEach((file) => {
            if (file.fileLocation == specification_shared_1.FileLocation.Local) {
                let url = getSpecificationImageOrDocumentUrl(undefined, spec.filename, file.url);
                file.url = url;
            }
        });
    }
    readspecifications(directory) {
        var rc = [];
        if (!fs.existsSync(directory)) {
            //log.log(LogLevelEnum.notice, 'specifications directory not found ' + directory)
            return rc;
        }
        var files = fs.readdirSync(directory);
        files.forEach((file) => {
            try {
                if (file.endsWith('.yaml')) {
                    let newfn = file.replace('.yaml', '');
                    var src = fs.readFileSync(directory + '/' + file, {
                        encoding: 'utf8',
                    });
                    var o = (0, yaml_1.parse)(src);
                    if (o.version != specification_shared_1.SPECIFICATION_VERSION) {
                        o = new migrator_1.Migrator().migrate(o);
                    }
                    o.filename = newfn;
                    this.readFilesYaml(directory, o);
                    o.entities.forEach((entity) => {
                        let cv = convertermap_1.ConverterMap.getIConverter(entity);
                        if (cv) {
                            entity.converter = cv;
                            let inumber = entity.converterParameters;
                            if (inumber.multiplier != undefined && inumber.numberFormat == undefined) {
                                inumber.numberFormat = specification_shared_1.EnumNumberFormat.default;
                            }
                        }
                        if (!o.nextEntityId || entity.id > o.nextEntityId + 1)
                            o.nextEntityId = entity.id + 1;
                    });
                    if (o.pullNumber)
                        o.pullUrl = m2mgithub_1.M2mGitHub.getPullRequestUrl(o.pullNumber);
                    //debug("specifications: " + getSpecificationI18nName(o, "en") + " filename:" + o.filename + " new: " + newfn);
                    if (!o.files)
                        o.files = [];
                    rc.push(o);
                }
            }
            catch (e) {
                log.log(log_1.LogLevelEnum.error, 'Unable to load spec ' + file + ' continuing ' + e.message);
            }
        });
        return rc;
    }
    // set the base file for relative includes
    readYaml() {
        debugger;
        try {
            var publishedSpecifications = this.readspecifications(ConfigSpecification.yamlDir + '/public/specifications');
            var contributedSpecifications = this.readspecifications(ConfigSpecification.yamlDir + '/contributed/specifications');
            ConfigSpecification.specifications = this.readspecifications(ConfigSpecification.yamlDir + '/local/specifications');
            // Iterate over local files
            ConfigSpecification.specifications.forEach((specification) => {
                let published = publishedSpecifications.find((obj) => {
                    return obj.filename === specification.filename;
                });
                if (!published)
                    specification.status = 2 /* SpecificationStatus.added */; // local only
                else {
                    specification.status = 1 /* SpecificationStatus.cloned */; // contributed expect no local
                    specification.publicSpecification = published;
                    // copy specification files.yaml if local list is empty
                    if (specification.files.length == 0 && published.files.length > 0)
                        specification.files = structuredClone(published.files);
                }
            });
            // Iterate over contributed files
            contributedSpecifications.forEach((specification) => {
                if (-1 ==
                    ConfigSpecification.specifications.findIndex((obj) => {
                        return ([1 /* SpecificationStatus.cloned */, 2 /* SpecificationStatus.added */].includes(obj.status) &&
                            obj.filename === specification.filename);
                    })) {
                    let published = publishedSpecifications.find((obj) => {
                        return obj.filename === specification.filename;
                    });
                    if (published)
                        specification.publicSpecification = published;
                    specification.status = 4 /* SpecificationStatus.contributed */;
                    if (specification.pullNumber == undefined)
                        log.log(log_1.LogLevelEnum.error, 'Contributed Specification w/o pull request number: ' + specification.filename);
                    ConfigSpecification.specifications.push(specification);
                }
                else {
                    log.log(log_1.LogLevelEnum.error, 'Specification is local and contributed this is not supported: ' + specification.filename);
                }
            });
            publishedSpecifications.forEach((specification) => {
                if (-1 ==
                    ConfigSpecification.specifications.findIndex((obj) => {
                        return obj.filename === specification.filename;
                    })) {
                    specification.status = 0 /* SpecificationStatus.published */;
                    ConfigSpecification.specifications.push(specification);
                }
            });
            //debug("Number of specifications: " + ConfigSpecification.specifications.length);
        }
        catch (error) {
            log.log(log_1.LogLevelEnum.error, 'readyaml failed: ' + error.message);
            throw error;
            // Expected output: ReferenceError: nonExistentFunction is not defined
            // (Note: the exact output may be browser-dependent)
        }
    }
    filterAllSpecifications(specFunction) {
        for (let spec of ConfigSpecification.specifications) {
            specFunction(spec);
        }
    }
    static { this.emptyTestData = { holdingRegisters: [], coils: [], analogInputs: [], discreteInputs: [] }; }
    // removes non configuration data
    // Adds  testData array from Modbus values. They can be used to test specification
    static toFileSpecification(modbusSpec) {
        let fileSpec = structuredClone({
            ...modbusSpec,
            version: specification_shared_1.SPECIFICATION_VERSION,
            testdata: structuredClone(this.emptyTestData),
        });
        delete fileSpec['identification'];
        // delete (fileSpec as any)['status'];
        modbusSpec.entities.forEach((entity) => {
            if (entity.modbusValue)
                for (let idx = 0; idx < entity.modbusValue.length; idx++) {
                    switch (entity.registerType) {
                        case specification_shared_1.ModbusRegisterType.AnalogInputs:
                            fileSpec.testdata.analogInputs?.push({
                                address: entity.modbusAddress + idx,
                                value: entity.modbusValue[idx],
                                error: entity.modbusError,
                            });
                            break;
                        case specification_shared_1.ModbusRegisterType.HoldingRegister:
                            fileSpec.testdata.holdingRegisters?.push({
                                address: entity.modbusAddress + idx,
                                value: entity.modbusValue[idx],
                                error: entity.modbusError,
                            });
                            break;
                        case specification_shared_1.ModbusRegisterType.Coils:
                            fileSpec.testdata.coils?.push({
                                address: entity.modbusAddress + idx,
                                value: entity.modbusValue[idx],
                                error: entity.modbusError,
                            });
                            break;
                        case specification_shared_1.ModbusRegisterType.DiscreteInputs:
                            fileSpec.testdata.discreteInputs?.push({
                                address: entity.modbusAddress + idx,
                                value: entity.modbusValue[idx],
                                error: entity.modbusError,
                            });
                            break;
                    }
                    entity.converter.registerTypes = [];
                }
        });
        if (fileSpec.testdata.analogInputs?.length == 0)
            delete fileSpec.testdata.analogInputs;
        if (fileSpec.testdata.holdingRegisters?.length == 0)
            delete fileSpec.testdata.holdingRegisters;
        if (fileSpec.testdata.coils?.length == 0)
            delete fileSpec.testdata.coils;
        if (fileSpec.testdata.discreteInputs?.length == 0)
            delete fileSpec.testdata.discreteInputs;
        fileSpec.entities.forEach((entity) => {
            delete entity['modbusValue'];
            delete entity['mqttValue'];
            delete entity['identified'];
        });
        return fileSpec;
    }
    static deleteSpecificationFile(specfilename, url, usage) {
        let fname = (0, specification_shared_2.getBaseFilename)(url);
        let decodedUrl = decodeURIComponent(url).replaceAll('+', ' ');
        let deleteFlag = true;
        let yamlFile = getSpecificationImageOrDocumentUrl((0, path_1.join)(ConfigSpecification.yamlDir, 'local'), specfilename, 'files.yaml');
        let files = { version: specification_shared_1.SPECIFICATION_FILES_VERSION, files: [] };
        if (fs.existsSync(yamlFile)) {
            try {
                let content = fs.readFileSync(yamlFile, { encoding: 'utf8' });
                files = (0, yaml_1.parse)(content.toString());
                files = new migrator_1.Migrator().migrateFiles(files);
                let imgFileIdx = files.files.findIndex((f) => decodeURIComponent(f.url).replaceAll('+', ' ') == decodedUrl && f.usage == "img" /* SpecificationFileUsage.img */);
                let docFileIdx = files.files.findIndex((f) => decodeURIComponent(f.url).replaceAll('+', ' ') == decodedUrl && f.usage == "doc" /* SpecificationFileUsage.documentation */);
                if (imgFileIdx >= 0 && docFileIdx >= 0)
                    deleteFlag = false;
                let idx = usage == "img" /* SpecificationFileUsage.img */ ? imgFileIdx : docFileIdx;
                if (idx >= 0) {
                    files.files.splice(idx, 1);
                    fs.writeFileSync(yamlFile, (0, yaml_1.stringify)(files), {
                        encoding: 'utf8',
                        flag: 'w',
                    });
                    let spec = ConfigSpecification.specifications.find((spec) => spec.filename == specfilename);
                    if (spec)
                        spec.files = files.files;
                }
            }
            catch (e) {
                log.log(log_1.LogLevelEnum.error, 'Unable to read Files directory for ' + specfilename);
            }
        }
        specfilename = getSpecificationImageOrDocumentUrl((0, path_1.join)(ConfigSpecification.yamlDir, 'local'), specfilename, fname);
        if (fs.existsSync(specfilename) && deleteFlag)
            fs.unlinkSync(specfilename);
        return files.files;
    }
    renameFilesPath(spec, oldfilename, newDirectory) {
        let oldDirectory = 'local';
        if (spec.status == 4 /* SpecificationStatus.contributed */)
            oldDirectory = 'contributed';
        let specsDir = (0, path_1.join)(ConfigSpecification.yamlDir, newDirectory, 'specifications');
        let oldPath = getSpecificationImageOrDocumentUrl((0, path_1.join)(ConfigSpecification.yamlDir, oldDirectory), oldfilename, '');
        let newPath = getSpecificationImageOrDocumentUrl((0, path_1.join)(ConfigSpecification.yamlDir, newDirectory), spec.filename, '');
        let newParentDir = path.dirname(newPath);
        if (!fs.existsSync(newParentDir))
            fs.mkdirSync(newParentDir, { recursive: true });
        if (fs.existsSync(newPath))
            fs.rmSync(newPath, { recursive: true });
        if (fs.existsSync(oldPath))
            fs.renameSync(oldPath, newPath);
        this.readFilesYaml(specsDir, spec);
    }
    cleanSpecForWriting(spec) {
        spec.entities.forEach((e) => {
            if (!e.icon || e.icon.length == 0)
                delete e.icon;
            if (e.identified != undefined)
                delete e.identified;
            if (e.mqttValue != undefined)
                delete e.mqttValue;
            if (e.modbusValue != undefined)
                delete e.modbusValue;
            if (e.commandTopicModbus)
                delete e.commandTopicModbus;
            if (e.commandTopic)
                delete e.commandTopic;
            if (e.converter && e.converter.registerTypes)
                delete e.converter.registerTypes;
        });
        if (!spec.manufacturer || spec.manufacturer.length == 0)
            delete spec.manufacturer;
        if (!spec.model || spec.model.length == 0)
            delete spec.model;
        if (spec.status != 4 /* SpecificationStatus.contributed */)
            delete spec.pullNumber;
        if (spec.stateTopic)
            delete spec.stateTopic;
        if (spec.statePayload)
            delete spec.statePayload;
        if (spec.triggerPollTopic)
            delete spec.triggerPollTopic;
        if (spec.commandTopicModbus)
            delete spec.commandTopicModbus;
        delete spec.publicSpecification;
        delete spec.identified;
        delete spec.status;
    }
    changeContributionStatus(filename, newStatus, pullNumber) {
        // moves Specification files to contribution directory
        let spec = ConfigSpecification.specifications.find((f) => f.filename == filename);
        if (!spec)
            throw new Error('Specification ' + filename + ' not found');
        if (newStatus && newStatus == spec.status)
            return;
        let newPath = ConfigSpecification.getContributedSpecificationPath(spec);
        let oldPath = ConfigSpecification.getSpecificationPath(spec);
        let newDirectory = 'contributed';
        switch (newStatus) {
            case 0 /* SpecificationStatus.published */:
                oldPath = ConfigSpecification.getContributedSpecificationPath(spec);
                newPath = ConfigSpecification.getPublicSpecificationPath(spec);
                newDirectory = 'public';
                break;
            case 1 /* SpecificationStatus.cloned */:
            case 2 /* SpecificationStatus.added */:
                if (spec.status == 4 /* SpecificationStatus.contributed */) {
                    let publicPath = ConfigSpecification.getPublicSpecificationPath(spec);
                    if (fs.existsSync(publicPath))
                        newStatus = 1 /* SpecificationStatus.cloned */;
                    else
                        newStatus = 2 /* SpecificationStatus.added */;
                    newPath = ConfigSpecification.getSpecificationPath(spec);
                    newDirectory = 'local';
                    oldPath = ConfigSpecification.getContributedSpecificationPath(spec);
                }
                break;
            default: // contributed
        }
        // first move files, because spec.status must point to oldPath directory before calling it
        // move spec file from oldpath to newpath
        if (newDirectory != 'public') {
            this.renameFilesPath(spec, spec.filename, newDirectory);
            fs.renameSync(oldPath, newPath);
        }
        else {
            if (fs.existsSync(oldPath))
                fs.rmSync(oldPath, { recursive: true }); // public directory was already fetched
            let specDir = path.parse(oldPath).dir;
            let filesDir = (0, path_1.join)(specDir, 'files', spec.filename);
            if (fs.existsSync(filesDir))
                fs.rmSync(filesDir, { recursive: true }); // public directory was already fetched
        }
        // Now change the status in ConfigSpecification.specifications array
        spec = ConfigSpecification.specifications.find((f) => f.filename == filename);
        if (spec) {
            spec.status = newStatus;
            if (newStatus == 4 /* SpecificationStatus.contributed */) {
                ;
                spec.pullNumber = pullNumber;
                this.writeSpecificationFromFileSpec(spec, spec.filename, pullNumber);
            }
        }
    }
    writeSpecificationFromFileSpec(spec, originalFilename, pullNumber) {
        if (spec.filename == '_new') {
            throw new Error('No or invalid filename for specification');
        }
        let publicFilepath = ConfigSpecification.getPublicSpecificationPath(spec);
        let contributedFilepath = ConfigSpecification.getContributedSpecificationPath(spec);
        let filename = ConfigSpecification.getSpecificationPath(spec);
        if (spec) {
            if (spec.status == 3 /* SpecificationStatus.new */) {
                this.renameFilesPath(spec, '_new', 'local');
            }
            else if (originalFilename) {
                if (originalFilename != spec.filename) {
                    if (spec.status == 1 /* SpecificationStatus.cloned */ ||
                        spec.status == 0 /* SpecificationStatus.published */ ||
                        spec.status == 4 /* SpecificationStatus.contributed */)
                        throw new Error('Cannot rename a published file');
                    // delete yaml file and rename files directory
                    let s = spec.filename;
                    spec.filename = originalFilename;
                    let originalFilepath = ConfigSpecification.getSpecificationPath(spec);
                    spec.filename = s;
                    fs.unlinkSync(originalFilepath);
                    this.renameFilesPath(spec, originalFilename, 'local');
                }
            }
            else
                throw new Error(spec.status + ' !=' + 3 /* SpecificationStatus.new */ + ' and no originalfilename');
            if (spec.files && spec.files.length && [0 /* SpecificationStatus.published */].includes(spec.status)) {
                // cloning with attached files
                let filespath = ConfigSpecification.getPublicFilesPath(spec.filename);
                if (4 /* SpecificationStatus.contributed */ == spec.status)
                    filespath = ConfigSpecification.getContributedFilesPath(spec.filename);
                let localFilesPath = ConfigSpecification.getLocalFilesPath(spec.filename);
                if (!fs.existsSync(localFilesPath) && fs.existsSync(filespath)) {
                    fs.cpSync(filespath, localFilesPath, { recursive: true });
                }
            }
            if (pullNumber != undefined) {
                spec.status = 4 /* SpecificationStatus.contributed */;
                filename = contributedFilepath;
            }
            else if (!fs.existsSync(publicFilepath))
                spec.status = 2 /* SpecificationStatus.added */;
            else if (fs.existsSync(contributedFilepath)) {
                spec.status = 4 /* SpecificationStatus.contributed */;
                filename = contributedFilepath;
            }
            else
                spec.status = 1 /* SpecificationStatus.cloned */;
        }
        else
            throw new Error('spec is undefined');
        let dir = path.dirname(filename);
        if (!fs.existsSync(dir))
            fs.mkdirSync(dir, { recursive: true });
        // Update files list add files, which are not in list yet.
        let ns = structuredClone(spec);
        this.cleanSpecForWriting(ns);
        ns.version = specification_shared_1.SPECIFICATION_VERSION;
        delete ns.files;
        let s = (0, yaml_1.stringify)(ns);
        fs.writeFileSync(filename, s, { encoding: 'utf8' });
        let idx = ConfigSpecification.specifications.findIndex((cspec) => {
            return cspec.filename === spec.filename;
        });
        if (idx >= 0)
            ConfigSpecification.specifications[idx] = spec;
        else
            ConfigSpecification.specifications.push(spec);
        return spec;
    }
    writeSpecification(spec, onAfterSave, originalFilename) {
        let fileSpec = ConfigSpecification.toFileSpecification(spec);
        this.writeSpecificationFromFileSpec(fileSpec, originalFilename);
        if (onAfterSave)
            onAfterSave(fileSpec.filename);
        return fileSpec;
    }
    deleteNewSpecificationFiles() {
        let dir = getSpecificationImageOrDocumentUrl((0, path_1.join)(ConfigSpecification.yamlDir, 'local'), '_new', '');
        if (fs.existsSync(dir))
            fs.rmSync(dir, { recursive: true });
    }
    deleteSpecification(specfileName) {
        let found = false;
        for (let idx = 0; idx < ConfigSpecification.specifications.length; idx++) {
            let sp = ConfigSpecification.specifications[idx];
            if (sp.filename === specfileName)
                if (sp.status in [1 /* SpecificationStatus.cloned */, 2 /* SpecificationStatus.added */, 3 /* SpecificationStatus.new */])
                    try {
                        found = true;
                        fs.unlinkSync(ConfigSpecification.getSpecificationPath(sp));
                        fs.rmSync(ConfigSpecification.getLocalFilesPath(sp.filename));
                        log.log(log_1.LogLevelEnum.notice, 'Specification removed: ' + sp.filename);
                        return;
                    }
                    catch (e) {
                        log.log(log_1.LogLevelEnum.error, 'Unable to remove Specification ' + sp.filename + ' ' + e.message);
                    }
                    finally {
                        this.readYaml();
                    }
                else {
                    log.log(log_1.LogLevelEnum.error, 'Unable to remove Specification ' + sp.filename + ': invalid status');
                }
        }
        // if (!found && (!specfileName || specfileName != '_new'))
        //  log.log(LogLevelEnum.notice, 'specification not found for deletion ' + specfileName)
    }
    static getSpecificationByName(name) {
        return structuredClone(ConfigSpecification.specifications.find((spec) => {
            return (0, specification_shared_1.getSpecificationI18nName)(spec, 'en') === name;
        }));
    }
    static clearModbusData(spec) {
        spec.entities.forEach((ent) => {
            delete ent.modbusError;
            delete ent.modbusValue;
            delete ent.mqttValue;
            delete ent.identified;
        });
        delete spec.identified;
    }
    static getSpecificationByFilename(filename) {
        if (filename == '_new') {
            let rc = {
                version: specification_shared_1.SPECIFICATION_VERSION,
                entities: [],
                files: [],
                i18n: [],
                testdata: structuredClone(this.emptyTestData),
                filename: '_new',
                status: 3 /* SpecificationStatus.new */,
            };
            let dir = getSpecificationImageOrDocumentUrl((0, path_1.join)(ConfigSpecification.yamlDir, 'local'), '_new', '');
            if (fs.existsSync(dir)) {
                let files = fs.readdirSync(dir);
                files.forEach((file) => {
                    let url = getSpecificationImageOrDocumentUrl((0, path_1.join)(ConfigSpecification.yamlDir, 'local'), '_new', file);
                    rc.files.push({
                        url: url,
                        fileLocation: specification_shared_1.FileLocation.Local,
                        usage: m2mspecification_1.M2mSpecification.getFileUsage(file),
                    });
                });
            }
            ConfigSpecification.clearModbusData(rc);
            return rc;
        }
        let rc = structuredClone(ConfigSpecification.specifications.find((spec) => {
            return spec.filename === filename;
        }));
        if (rc)
            ConfigSpecification.clearModbusData(rc);
        return rc;
    }
    static getFileNameFromSlaveId(slaveid) {
        return 's' + slaveid;
    }
    static createZipFromSpecification(specfilename, r) {
        let spec = { filename: specfilename };
        let specFilePath = ConfigSpecification.getSpecificationPath(spec);
        let fn = ConfigSpecification.getLocalFilesPath(specfilename);
        if (!fs.existsSync(fn)) {
            ;
            (fn = ConfigSpecification.getContributedFilesPath(specfilename)),
                (specFilePath = ConfigSpecification.getContributedSpecificationPath(spec));
        }
        if (!fs.existsSync(fn)) {
            fn = ConfigSpecification.getPublicFilesPath(specfilename);
            specFilePath = ConfigSpecification.getPublicSpecificationPath(spec);
        }
        if (!fs.existsSync(fn))
            throw new Error('no specificationPath found at ' + fn);
        if (!fs.existsSync(specFilePath))
            throw new Error('no specification found at ' + specFilePath);
        let z = new adm_zip_1.default();
        z.addLocalFile(specFilePath);
        z.addLocalFolder(fn, 'files/' + specfilename);
        r.write(z.toBuffer(), () => {
            r.end();
        });
    }
    static validateSpecificationZip(localSpecDir, zip) {
        let errors = { warnings: '', errors: '' };
        let filesExists = false;
        let specExists = false;
        for (var entry of zip) {
            if (entry.entryName.indexOf('.yaml') > 0)
                if (entry.entryName.indexOf('/files.yaml') > 0)
                    filesExists = true;
                else
                    specExists = true;
            if (fs.existsSync((0, path_1.join)(localSpecDir, entry.entryName)))
                errors.warnings = errors.warnings + 'File cannot be overwritten: ' + entry.entryName + '\n';
        }
        if (!filesExists)
            errors.errors = errors.errors + 'No files.yaml found\n';
        if (!specExists)
            errors.errors = errors.errors + 'No specification yaml file found\n';
        return errors;
    }
    static importSpecificationZip(zipfilename) {
        let localSpecDir = (0, path_1.join)(ConfigSpecification.getLocalDir(), 'specifications');
        try {
            let z = new adm_zip_1.default(zipfilename);
            let errors = this.validateSpecificationZip(localSpecDir, z.getEntries());
            if (errors.errors.length == 0) {
                z.extractAllTo(localSpecDir);
                new ConfigSpecification().readYaml();
                return errors;
            }
        }
        catch (e) {
            return { errors: e.message, warnings: '' };
        }
        // Just to make compiler happy
        return { errors: '', warnings: '' };
    }
}
exports.ConfigSpecification = ConfigSpecification;
function getSpecificationImageOrDocumentUrl(rootUrl, specName, url) {
    let fn = (0, specification_shared_2.getBaseFilename)(url);
    let rc = '';
    if (rootUrl) {
        let append = '/';
        if (rootUrl.endsWith('/'))
            append = '';
        rc = rootUrl + append + (0, path_1.join)(exports.filesUrlPrefix, specName, fn);
    }
    else
        rc = (0, path_1.join)(exports.filesUrlPrefix, specName, fn);
    return rc;
}
//# sourceMappingURL=configspec.js.map