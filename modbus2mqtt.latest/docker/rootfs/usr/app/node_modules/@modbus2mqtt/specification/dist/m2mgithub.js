"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.M2mGitHub = exports.githubPublicNames = void 0;
const tslib_1 = require("tslib");
const rest_1 = require("@octokit/rest");
const log_1 = require("./log");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const fs = tslib_1.__importStar(require("fs"));
const configspec_1 = require("./configspec");
const debug = require('debug')('m2mgithub');
exports.githubPublicNames = {
    publicModbus2mqttOwner: 'modbus2mqtt',
    modbus2mqttRepo: 'modbus2mqtt.config',
    modbus2mqttBranch: 'main',
};
const log = new log_1.Logger('m2mGithub');
class M2mGitHub {
    static { this.forking = false; }
    findOrCreateOwnModbus2MqttRepo() {
        return new Promise((resolve, reject) => {
            debug('findOrCreateOwnModbus2MqttRepo');
            if (this.ownOwner && this.octokit)
                this.octokit.repos
                    .listForUser({
                    username: this.ownOwner,
                    type: 'all',
                })
                    .then((repos) => {
                    let found = repos.data.find((repo) => repo.name == exports.githubPublicNames.modbus2mqttRepo);
                    if (found == null && !M2mGitHub.forking)
                        this.createOwnModbus2MqttRepo().then(resolve).catch(reject);
                    else {
                        if (found != null)
                            M2mGitHub.forking = false;
                        resolve();
                    }
                })
                    .catch(reject);
        });
    }
    hasSpecBranch(branch) {
        return new Promise((resolve, reject) => {
            if (null == this.octokit)
                reject(new Error('No Github token configured'));
            else
                this.octokit.git
                    .getRef({
                    owner: this.ownOwner,
                    repo: exports.githubPublicNames.modbus2mqttRepo,
                    ref: 'heads/' + branch,
                })
                    .then((branches) => {
                    resolve(true);
                })
                    .catch((e) => {
                    debug('get Branch' + e.message);
                    if (e.status == 404)
                        resolve(false);
                    else
                        reject(e);
                });
        });
    }
    deleteSpecBranch(branch) {
        return new Promise((resolve, reject) => {
            if (null == this.octokit)
                reject(new Error('No Github token configured'));
            else
                this.hasSpecBranch(branch)
                    .then((hasBranch) => {
                    if (hasBranch)
                        this.octokit.git.deleteRef({
                            owner: this.ownOwner,
                            repo: exports.githubPublicNames.modbus2mqttRepo,
                            ref: 'heads/' + branch,
                        })
                            .then(() => {
                            resolve();
                        })
                            .catch(reject);
                    else
                        resolve();
                })
                    .catch(reject);
        });
    }
    createOwnModbus2MqttRepo() {
        return new Promise((resolve, reject) => {
            debug('createOwnModbus2MqttRepo');
            M2mGitHub.forking = true;
            if (exports.githubPublicNames.publicModbus2mqttOwner)
                this.octokit.repos.createFork({
                    owner: exports.githubPublicNames.publicModbus2mqttOwner,
                    repo: exports.githubPublicNames.modbus2mqttRepo,
                    default_branch_only: true,
                })
                    .then(() => {
                    resolve();
                })
                    .catch((e) => {
                    M2mGitHub.forking = false;
                    reject(e);
                });
        });
    }
    checkRepo() {
        return new Promise((resolve, reject) => {
            if (null == this.octokit)
                reject(new Error('No Github token configured'));
            else if (this.ownOwner)
                this.octokit.repos
                    .listForUser({
                    username: this.ownOwner,
                    type: 'all',
                })
                    .then((repos) => {
                    let found = repos.data.find((repo) => repo.name == exports.githubPublicNames.modbus2mqttRepo);
                    if (found) {
                        debug('checkRepo: sync fork');
                        M2mGitHub.forking = false;
                        this.octokit.request(`POST /repos/${this.ownOwner}/${exports.githubPublicNames.modbus2mqttRepo}/merge-upstream`, {
                            branch: exports.githubPublicNames.modbus2mqttBranch,
                        })
                            .then((_r) => {
                            resolve(true);
                        })
                            .catch((e) => {
                            let e1 = new Error(e.message);
                            e1.step = e.step;
                            e1.stack = e.stack;
                            if (e.code == 422)
                                e1.message = e.message + '\n Permission denied for the github token. Please sync Repository in github.com.';
                            reject(e1);
                        });
                    }
                });
            else
                resolve(false);
        });
    }
    waitForOwnModbus2MqttRepo() {
        if (this.isRunning) {
            // some other process is waiting already.
            // Just wait until it's done
            return new Promise((resolve) => {
                this.waitFinished.pipe((0, rxjs_1.first)()).subscribe(() => {
                    resolve();
                });
            });
        }
        else {
            return new Promise((resolve, reject) => {
                if (null == this.octokit)
                    reject(new Error('No Github token configured'));
                else {
                    let count = 0;
                    // Once per second for 30 seconds, then once per minute
                    let interval = setInterval(() => {
                        debug('inInterval');
                        if (!this.isRunning && (count > 30 ? Math.floor(count % 60) == 0 : true)) {
                            this.isRunning = true;
                            this.checkRepo()
                                .then((available) => {
                                if (available) {
                                    this.isRunning = false;
                                    this.waitFinished.next();
                                    clearInterval(interval);
                                    resolve();
                                }
                            })
                                .catch((e) => {
                                this.isRunning = false;
                                log.log(log_1.LogLevelEnum.error, 'Validate Repository ' +
                                    this.ownOwner +
                                    '/' +
                                    exports.githubPublicNames.publicModbus2mqttOwner +
                                    ' failed. message: ' +
                                    e.message +
                                    ' Status: ' +
                                    e.status);
                                reject(e);
                            });
                        }
                        count++;
                    }, 1000);
                }
            });
        }
    }
    constructor(personalAccessToken, publicRoot) {
        this.publicRoot = publicRoot;
        this.isRunning = false;
        this.waitFinished = new rxjs_1.Subject();
        this.octokit = null;
        if (personalAccessToken)
            this.octokit = new rest_1.Octokit({
                auth: personalAccessToken,
            });
    }
    fetchPublicFiles() {
        debug('Fetch public files');
        if ((0, fs_1.existsSync)((0, path_1.join)(this.publicRoot, '.git'))) {
            let msg = (0, child_process_1.execSync)('git pull', { cwd: this.publicRoot }).toString();
            // log more than two lines only. Two lines usually means up-to-date 1th line + \n
            if (msg.split(/\r\n|\r|\n/).length > 2)
                log.log(log_1.LogLevelEnum.notice, msg);
        } // creating a repo is worth a notice
        else
            log.log(log_1.LogLevelEnum.notice, (0, child_process_1.execSync)('git clone https://github.com/' +
                exports.githubPublicNames.publicModbus2mqttOwner +
                '/' +
                exports.githubPublicNames.modbus2mqttRepo +
                '.git ' +
                this.publicRoot).toString());
        new configspec_1.ConfigSpecification().readYaml();
    }
    static getPullRequestUrl(pullNumber) {
        return `https://github.com/${exports.githubPublicNames.publicModbus2mqttOwner}/${exports.githubPublicNames.modbus2mqttRepo}/pull/${pullNumber}`;
    }
    createPullrequest(title, content, branchName) {
        return new Promise((resolve, reject) => {
            if (null == this.octokit)
                reject(new Error('No Github token configured'));
            else
                this.octokit.rest.issues
                    .create({
                    owner: exports.githubPublicNames.publicModbus2mqttOwner,
                    repo: exports.githubPublicNames.modbus2mqttRepo,
                    title: title,
                    body: content,
                    labels: ['automerge'],
                })
                    .then((res) => {
                    this.octokit.rest.pulls.create({
                        owner: exports.githubPublicNames.publicModbus2mqttOwner,
                        body: content + '\nCloses #' + res.data.number,
                        repo: exports.githubPublicNames.modbus2mqttRepo,
                        issue: res.data.number,
                        head: this.ownOwner + ':' + branchName,
                        base: exports.githubPublicNames.modbus2mqttBranch,
                    })
                        .then((res) => {
                        resolve(res.data.number);
                    })
                        .catch((e) => {
                        e.step = 'create pull';
                        reject(e);
                    });
                })
                    .catch((e) => {
                    e.step = 'create issue';
                    reject(e);
                });
        });
    }
    getPullRequest(pullNumber) {
        return new Promise((resolve, reject) => {
            if (null == this.octokit)
                reject(new Error('No Github token configured'));
            else
                this.octokit.pulls
                    .get({
                    owner: exports.githubPublicNames.publicModbus2mqttOwner,
                    repo: exports.githubPublicNames.modbus2mqttRepo,
                    pull_number: pullNumber,
                })
                    .then((pull) => {
                    resolve(pull.data);
                })
                    .catch((e) => {
                    if (e.step == undefined)
                        e.step = 'downloadFile';
                    debug(JSON.stringify(e));
                    reject(e);
                });
        });
    }
    getInfoFromError(e) {
        let msg = JSON.stringify(e);
        if (e.message)
            msg = 'ERROR: ' + e.message;
        if (e.status)
            msg += ' status: ' + e.status;
        if (e.message)
            msg += ' message: ' + e.message;
        if (e.step)
            msg += ' in ' + e.step;
        return msg;
    }
    uploadFileAndCreateTreeParameter(root, filename) {
        return new Promise((resolve, reject) => {
            debug('uploadFileAndCreateTreeParameter');
            let encoding = filename.endsWith('.yaml') ? 'utf8' : 'base64';
            let params = {
                owner: this.ownOwner,
                repo: exports.githubPublicNames.modbus2mqttRepo,
                encoding: encoding == 'utf8' ? 'utf-8' : encoding,
                content: fs.readFileSync((0, path_1.join)(root, filename)).toString(encoding),
            };
            if (null == this.octokit)
                reject(new Error('No Github token configured'));
            else
                this.octokit.git
                    .createBlob(params)
                    .then((res) => {
                    resolve({
                        path: filename,
                        mode: '100644',
                        type: 'blob',
                        sha: res.data.sha,
                    });
                })
                    .catch((e) => {
                    e.step = 'createBlob';
                    reject(e);
                });
        });
    }
    init() {
        // checks if fork from public repository is available
        // Otherwise it creates it, but doesn't wait for creation
        // fetches all files from public repo (Works also if no personal repo is available yet)
        return new Promise((resolve, reject) => {
            debug('init');
            try {
                this.fetchPublicFiles();
            }
            catch (e) {
                reject(e);
            }
            if (null == this.octokit)
                resolve(false);
            else if (!this.ownOwner) {
                this.octokit.users
                    .getAuthenticated()
                    .then((user) => {
                    this.ownOwner = user.data.login;
                    this.findOrCreateOwnModbus2MqttRepo()
                        .then(() => {
                        resolve(true);
                    })
                        .catch((e) => {
                        this.ownOwner = undefined;
                        reject(e);
                    });
                })
                    .catch(reject);
            }
            else
                this.findOrCreateOwnModbus2MqttRepo()
                    .then(() => {
                    resolve(true);
                })
                    .catch((e) => {
                    this.ownOwner = undefined;
                    reject(e);
                });
        });
    }
    deleteRepository() {
        return new Promise((resolve, reject) => {
            if (null == this.octokit)
                reject(new Error('No Github token configured'));
            else if (this.ownOwner)
                this.octokit.repos
                    .delete({
                    owner: this.ownOwner,
                    repo: exports.githubPublicNames.modbus2mqttRepo,
                })
                    .then(() => {
                    resolve();
                })
                    .catch(reject);
        });
    }
    checkFiles(root, files) {
        let all = [];
        files.forEach((file) => {
            debug('root: ' + root + ' file: ' + file);
            let fullPath = (0, path_1.join)(root, file);
            if (!fs.existsSync(fullPath)) {
                if (fullPath.indexOf('/files/') != -1 && !fullPath.endsWith('files.yaml')) {
                    // Can be ignored if the files are missing, they have been published already
                    debug('File not found: ' + fullPath);
                }
                else {
                    throw new Error('File not found ' + fullPath);
                }
            }
            else
                all.push(this.uploadFileAndCreateTreeParameter(root, file));
        });
        return all;
    }
    commitFiles(root, branchName, files, title, message) {
        return new Promise((resolve, reject) => {
            this.waitForOwnModbus2MqttRepo()
                .then(() => {
                this.hasSpecBranch(branchName)
                    .then((hasBranch) => {
                    if (hasBranch)
                        reject(new Error('There is already a branch named ' +
                            branchName +
                            ' Please delete it in your github repository ' +
                            this.ownOwner +
                            '/' +
                            exports.githubPublicNames.modbus2mqttRepo +
                            ' at github.com'));
                    else {
                        debug('start committing');
                        let all;
                        try {
                            let all = this.checkFiles(root, files);
                        }
                        catch (e) {
                            reject(e);
                            return;
                        }
                        Promise.all(all)
                            .then((trees) => {
                            debug('get Branch');
                            this.octokit.git.getRef({
                                owner: this.ownOwner,
                                repo: exports.githubPublicNames.modbus2mqttRepo,
                                ref: 'heads/' + exports.githubPublicNames.modbus2mqttBranch,
                            })
                                .then((ref) => {
                                let sha = ref.data.object.sha;
                                // create a new branch
                                this.octokit.git.createRef({
                                    owner: this.ownOwner,
                                    repo: exports.githubPublicNames.modbus2mqttRepo,
                                    ref: 'refs/heads/' + branchName,
                                    sha: ref.data.object.sha,
                                })
                                    .then((branch) => {
                                    branch.data.object.sha;
                                    //this.octokit.git.getTree()
                                    this.octokit.request(`GET /repos/${this.ownOwner}/${exports.githubPublicNames.modbus2mqttRepo}/git/trees/${exports.githubPublicNames.modbus2mqttBranch}`)
                                        .then((tree) => {
                                        debug('createTree');
                                        this.octokit.git.createTree({
                                            owner: this.ownOwner,
                                            repo: exports.githubPublicNames.modbus2mqttRepo,
                                            tree: trees,
                                            base_tree: tree.data.sha,
                                        })
                                            .then((result) => {
                                            debug('createCommit');
                                            this.octokit.git.createCommit({
                                                owner: this.ownOwner,
                                                repo: exports.githubPublicNames.modbus2mqttRepo,
                                                message: title + '\n' + message,
                                                tree: result.data.sha,
                                                parents: [branch.data.object.sha],
                                            })
                                                .then((_result) => {
                                                debug('updateRef');
                                                this.octokit.git.updateRef({
                                                    owner: this.ownOwner,
                                                    repo: exports.githubPublicNames.modbus2mqttRepo,
                                                    ref: 'heads/' + branchName,
                                                    sha: _result.data.sha,
                                                })
                                                    .then(() => {
                                                    debug('updated');
                                                    resolve(_result.data.sha);
                                                })
                                                    .catch((e) => {
                                                    e.step = 'updateRef';
                                                    reject(e);
                                                });
                                            })
                                                .catch((e) => {
                                                e.step = 'createCommit';
                                                reject(e);
                                            });
                                        })
                                            .catch((e) => {
                                            e.step = 'create Tree';
                                            reject(e);
                                        });
                                    })
                                        .catch((e) => {
                                        e.step = 'get base tree';
                                        reject(e);
                                    });
                                })
                                    .catch((e) => {
                                    e.step = 'create branch';
                                    reject(e);
                                });
                            })
                                .catch((e) => {
                                e.step = 'get branch';
                                reject(e);
                            });
                        })
                            .catch((e) => {
                            e.step = 'create blobs';
                            reject(e);
                        });
                    }
                })
                    .catch((e) => {
                    e.step = 'hasSpecBranch';
                    reject(e);
                });
            })
                .catch((e) => {
                e.step = 'waitForOwnModbus2MqttRepo';
                reject(e);
            });
        });
        // commits the given files with message to own repository
        // creates an issue in the public repository
        // creates a pull request to the public repository
        // If there is already a pull request, the new request will be appended
    }
}
exports.M2mGitHub = M2mGitHub;
//# sourceMappingURL=m2mgithub.js.map