"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.M2mSpecification = void 0;
exports.emptyModbusValues = emptyModbusValues;
const tslib_1 = require("tslib");
let path = require('path');
const path_1 = require("path");
const fs = tslib_1.__importStar(require("fs"));
const m2mgithub_1 = require("./m2mgithub");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const specification_shared_2 = require("@modbus2mqtt/specification.shared");
const configspec_1 = require("./configspec");
const convertermap_1 = require("./convertermap");
const log_1 = require("./log");
const rxjs_1 = require("rxjs");
const log = new log_1.Logger('m2mSpecification');
const debug = require('debug')('m2mspecification');
const maxIdentifiedSpecs = 0;
function emptyModbusValues() {
    return {
        holdingRegisters: new Map(),
        coils: new Map(),
        analogInputs: new Map(),
        discreteInputs: new Map(),
    };
}
class M2mSpecification {
    static { this.ghContributions = new Map(); }
    constructor(settings) {
        this.settings = settings;
        this.differentFilename = false;
        this.notBackwardCompatible = false;
        this.ghPollInterval = [5000, 30000, 30000, 60000, 60000, 60000, 5000 * 60, 5000 * 60 * 60, 1000 * 60 * 60 * 24];
        this.ghPollIntervalIndex = 0;
        this.ghPollIntervalIndexCount = 0;
        {
            if (!this.settings.i18n) {
                ;
                this.settings = {
                    filename: '',
                    i18n: [],
                    files: [],
                    status: 3 /* SpecificationStatus.new */,
                    entities: this.settings,
                    identified: specification_shared_2.IdentifiedStates.unknown,
                };
            }
        }
    }
    static messages2Text(spec, msgs) {
        let errors = '';
        msgs.forEach((msg) => {
            if (msg.type != specification_shared_1.MessageTypes.identifiedByOthers)
                errors += M2mSpecification.getMessageString(spec, msg) + '\n';
        });
        return errors;
    }
    contribute(note) {
        return new Promise((resolve, reject) => {
            try {
                let language = configspec_1.ConfigSpecification.mqttdiscoverylanguage;
                let messages = [];
                if (language == undefined)
                    messages.push({ type: specification_shared_1.MessageTypes.noMqttDiscoveryLanguage, category: specification_shared_1.MessageCategories.configuration });
                else
                    messages = this.validate(language);
                let errors = M2mSpecification.messages2Text(this.settings, messages);
                if (errors.length > 0) {
                    throw new Error('Validation failed with errors: ' + errors);
                }
                if (errors.length == 0 && messages.length > 0 && (!note || note.length == 0))
                    throw new Error('Validation failed with warning, but no note text available');
                let fileList = this.getSpecificationsFilesList(configspec_1.ConfigSpecification.getLocalDir());
                let spec = this.settings;
                let title = '';
                let message = '';
                switch (spec.status) {
                    case 2 /* SpecificationStatus.added */:
                        title = 'Add specification ';
                        message = this.generateAddedContributionMessage(note);
                        break;
                    case 1 /* SpecificationStatus.cloned */:
                        title = 'Update specification ';
                        //if (spec.publicSpecification)
                        //  message = this.isEqual(spec.publicSpecification)
                        let pub = spec.publicSpecification;
                        message = this.generateClonedContributionMessage(note, pub);
                        break;
                }
                title = title + (0, specification_shared_2.getSpecificationI18nName)(spec, language);
                if (configspec_1.ConfigSpecification.githubPersonalToken && configspec_1.ConfigSpecification.githubPersonalToken.length) {
                    let github = new m2mgithub_1.M2mGitHub(configspec_1.ConfigSpecification.githubPersonalToken, configspec_1.ConfigSpecification.getPublicDir());
                    let restore = function (spec, github, reject, e) {
                        if (spec.status == 4 /* SpecificationStatus.contributed */)
                            new configspec_1.ConfigSpecification().changeContributionStatus(spec.filename, 2 /* SpecificationStatus.added */);
                        github
                            .deleteSpecBranch(spec.filename)
                            .then(() => {
                            reject(e);
                        })
                            .catch((e1) => {
                            log.log(log_1.LogLevelEnum.error, 'delete branch: ' + e1.message);
                            reject(e);
                        });
                    };
                    github
                        .init()
                        .then(() => {
                        github
                            .commitFiles(configspec_1.ConfigSpecification.getLocalDir(), spec.filename, fileList, title, message)
                            .then(() => {
                            github
                                .createPullrequest(title, message, spec.filename)
                                .then((issue) => {
                                new configspec_1.ConfigSpecification().changeContributionStatus(this.settings.filename, 4 /* SpecificationStatus.contributed */, issue);
                                resolve(issue);
                            })
                                .catch((e) => {
                                restore(this.settings, github, reject, e);
                            });
                        })
                            .catch((e) => {
                            restore(this.settings, github, reject, e);
                        });
                    })
                        .catch((e) => {
                        restore(this.settings, github, reject, e);
                    });
                }
                else
                    throw new Error('Github connection is not configured. Set Github Personal Acces Token in configuration UI first');
            }
            catch (e) {
                reject(e);
            }
        });
    }
    generateAddedContributionMessage(note) {
        // First contribution:
        // Name of Specification(en)
        let spec = this.settings;
        let message = `First contribution of ${(0, specification_shared_2.getSpecificationI18nName)(spec, 'en')}(${spec.filename}) \nEntities:\n`;
        message = `${message}Languages: `;
        spec.i18n.forEach((l) => {
            message = `${message} ${l.lang} `;
        });
        message = `${message}\nEntities:\n`;
        spec.entities.forEach((ent) => {
            message = `${message}\t${(0, specification_shared_2.getSpecificationI18nEntityName)(spec, 'en', ent.id)}\n`;
        });
        message = `${message}\nImages:\n`;
        spec.files.forEach((file) => {
            if (file.usage == "img" /* SpecificationFileUsage.img */)
                message = `${message}\t ${file.url}\n`;
        });
        message = `${message}\nDocumentation:\n`;
        spec.files.forEach((file) => {
            if (file.usage == "doc" /* SpecificationFileUsage.documentation */)
                message = `${message}\t ${file.url}\n`;
        });
        return message;
    }
    generateClonedContributionMessage(note, publicSpecification) {
        let rcmessage = '';
        this.notBackwardCompatible = false;
        this.differentFilename = false;
        if (publicSpecification) {
            rcmessage = rcmessage + 'Changes:\n';
            let messages = this.isEqual(publicSpecification);
            messages.forEach((message) => {
                rcmessage = rcmessage + M2mSpecification.getMessageString(this.settings, message) + '\n';
            });
            // TODO Check backward compatibility
            if (this.notBackwardCompatible) {
                rcmessage = rcmessage + '\n!!! There are changes which are not backward compatible !!';
                if (note == undefined)
                    throw new Error('There are changes which are not backward compatible');
            }
            if (note != undefined)
                rcmessage = rcmessage + '\n' + note;
        }
        return rcmessage;
    }
    static getMessageString(spec, message) {
        switch (message.type) {
            case specification_shared_1.MessageTypes.noDocumentation:
                return `No documenation file or URL`;
            case specification_shared_1.MessageTypes.nameTextMissing:
                return `The specification has no Name`;
            case specification_shared_1.MessageTypes.entityTextMissing:
                return `entity has no name`;
            case specification_shared_1.MessageTypes.translationMissing:
                return `A translation is missing` + ': ' + message.additionalInformation;
            case specification_shared_1.MessageTypes.noEntity:
                return `No entity defined for this specification`;
            case specification_shared_1.MessageTypes.noDocumentation:
                return `No dcoumenation file or URL`;
            case specification_shared_1.MessageTypes.noImage:
                return `No image file or URL`;
            case specification_shared_1.MessageTypes.nonUniqueName:
                return `Specification name is not unique`;
            case specification_shared_1.MessageTypes.identifiedByOthers: {
                let specNames = '';
                message.additionalInformation.forEach((name) => {
                    specNames = specNames + name + ' ';
                });
                return `Test data of this specification matches to the following other public specifications ${specNames}`;
            }
            case specification_shared_1.MessageTypes.nonUniqueName:
                return ` The name is already available in public ` + ': ' + message.additionalInformation;
            case specification_shared_1.MessageTypes.notIdentified:
                return ` The specification can not be identified with it's test data`;
            case specification_shared_1.MessageTypes.differentFilename:
                return M2mSpecification.getMessageLocal(spec, message, 'Filename has been changed. A new public specification will be created');
            case specification_shared_1.MessageTypes.missingEntity:
                return M2mSpecification.getMessageLocal(spec, message, 'Entity has been removed');
            case specification_shared_1.MessageTypes.differentConverter:
                return M2mSpecification.getMessageLocal(spec, message, 'Converter has been changed');
            case specification_shared_1.MessageTypes.addedEntity:
                return M2mSpecification.getMessageLocal(spec, message, 'Entity has been added');
            case specification_shared_1.MessageTypes.differentModbusAddress:
                return M2mSpecification.getMessageLocal(spec, message, 'Modbus address has been changed');
            case specification_shared_1.MessageTypes.differentFunctionCode:
                return M2mSpecification.getMessageLocal(spec, message, 'Function code has been changed');
            case specification_shared_1.MessageTypes.differentIcon:
                return M2mSpecification.getMessageLocal(spec, message, 'Icon has been changed');
            case specification_shared_1.MessageTypes.differentTargetParameter:
                return M2mSpecification.getMessageLocal(spec, message, 'Variable configuration: Target parameter has been changed');
            case specification_shared_1.MessageTypes.differentVariableEntityId:
                return M2mSpecification.getMessageLocal(spec, message, 'Variable configuration: Referenced entity has been changed');
            case specification_shared_1.MessageTypes.differentVariableConfiguration:
                return M2mSpecification.getMessageLocal(spec, message, 'Variable configuration has been changed');
            case specification_shared_1.MessageTypes.differentDeviceClass:
                return M2mSpecification.getMessageLocal(spec, message, 'Device class has been changed');
            case specification_shared_1.MessageTypes.differentIdentificationMax:
                return M2mSpecification.getMessageLocal(spec, message, 'Max value has been changed');
            case specification_shared_1.MessageTypes.differentIdentificationMin:
                return M2mSpecification.getMessageLocal(spec, message, 'Min value has been changed');
            case specification_shared_1.MessageTypes.differentIdentification:
                return M2mSpecification.getMessageLocal(spec, message, 'Identification has been changed');
            case specification_shared_1.MessageTypes.differentMultiplier:
                return M2mSpecification.getMessageLocal(spec, message, 'Multiplier has been changed');
            case specification_shared_1.MessageTypes.differentOffset:
                return M2mSpecification.getMessageLocal(spec, message, 'Offset has been changed');
            case specification_shared_1.MessageTypes.differentOptionTable:
                return M2mSpecification.getMessageLocal(spec, message, 'Options have been changed');
            case specification_shared_1.MessageTypes.differentStringlength:
                return M2mSpecification.getMessageLocal(spec, message, 'String length has been changed');
            case specification_shared_1.MessageTypes.differentManufacturer:
                return M2mSpecification.getMessageLocal(spec, message, 'Manufacturer has been changed');
            case specification_shared_1.MessageTypes.differentModel:
                return M2mSpecification.getMessageLocal(spec, message, 'Model has been changed');
            case specification_shared_1.MessageTypes.differentTranslation:
                return M2mSpecification.getMessageLocal(spec, message, 'Translation has been changed');
            case specification_shared_1.MessageTypes.noMqttDiscoveryLanguage:
                return M2mSpecification.getMessageLocal(spec, message, 'MQTT Discovery Langauge is not configured');
        }
        return 'unknown MessageType : ' + message.type;
    }
    static getMessageLocal(spec, message, messageText, notBackwardCompatible) {
        let msg = structuredClone(messageText);
        if (message.referencedEntity != undefined)
            return msg + ' ' + (0, specification_shared_2.getSpecificationI18nEntityName)(spec, 'en', message.referencedEntity);
        if (message.additionalInformation != undefined)
            return msg + ' ' + message.additionalInformation;
        if (!notBackwardCompatible)
            return ' This will break compatibilty with previous version';
        return msg;
    }
    static handleCloseContributionError(msg, reject) {
        log.log(log_1.LogLevelEnum.error, msg);
        let e = new Error(msg);
        e.step = 'closeContribution';
        reject(e);
    }
    static closeContribution(spec) {
        return new Promise((resolve, reject) => {
            if (undefined == configspec_1.ConfigSpecification.githubPersonalToken) {
                this.handleCloseContributionError('No Github Personal Access Token configured. Unable to close contribution ' + spec.filename, reject);
                return;
            }
            if (spec.pullNumber == undefined) {
                this.handleCloseContributionError('No Pull Number in specification. Unable to close contribution ' + spec.filename, reject);
                return;
            }
            let gh = new m2mgithub_1.M2mGitHub(configspec_1.ConfigSpecification.githubPersonalToken, (0, path_1.join)(configspec_1.ConfigSpecification.yamlDir, 'public'));
            gh.init()
                .then(() => {
                gh.getPullRequest(spec.pullNumber)
                    .then((pullStatus) => {
                    try {
                        let cspec = new configspec_1.ConfigSpecification();
                        if (pullStatus.merged) {
                            cspec.changeContributionStatus(spec.filename, 0 /* SpecificationStatus.published */, undefined);
                        }
                        else if (pullStatus.closed_at != null) {
                            cspec.changeContributionStatus(spec.filename, 2 /* SpecificationStatus.added */, undefined);
                        }
                        spec = configspec_1.ConfigSpecification.getSpecificationByFilename(spec.filename);
                        if (spec.status != 4 /* SpecificationStatus.contributed */)
                            gh.deleteSpecBranch(spec.filename);
                        gh.fetchPublicFiles();
                        resolve({ merged: pullStatus.merged, closed: pullStatus.closed_at != null, pullNumber: spec.pullNumber });
                    }
                    catch (e) {
                        this.handleCloseContributionError('closeContribution: ' + e.message, reject);
                    }
                })
                    .catch((e) => {
                    this.handleCloseContributionError('closeContribution: ' + e.message, reject);
                });
            })
                .catch((e) => {
                this.handleCloseContributionError('closeContribution: ' + e.message, reject);
            });
        });
    }
    getSpecificationsFilesList(localDir) {
        let files = [];
        let spec = this.settings;
        spec.files.forEach((file) => {
            let filePath = file.url.replace(/^\//g, '');
            if (file.fileLocation == specification_shared_2.FileLocation.Local && fs.existsSync((0, path_1.join)(localDir, filePath)))
                files.push(filePath);
            // The file can also be already published. Then it's not neccessary to push it again
            // In this case, it's in the public directory and not in local directory
        });
        if (spec.files.length > 0) {
            let filesName = (0, path_1.join)((0, configspec_1.getSpecificationImageOrDocumentUrl)('', spec.filename, 'files.yaml'));
            files.push(filesName.replace(/^\//g, ''));
        }
        files.push((0, path_1.join)('specifications', spec.filename + '.yaml'));
        return files;
    }
    validate(language) {
        let rc = this.validateSpecification(language, true);
        if (this.settings.entities.length > 0) {
            let mSpec = this.settings;
            if (mSpec.identified == undefined)
                mSpec = M2mSpecification.fileToModbusSpecification(this.settings);
            else
                M2mSpecification.setIdentifiedByEntities(mSpec);
            if (mSpec.identified != specification_shared_2.IdentifiedStates.identified)
                rc.push({ type: specification_shared_1.MessageTypes.notIdentified, category: specification_shared_1.MessageCategories.validateSpecification });
        }
        if (!this.validateUniqueName(language))
            rc.push({ type: specification_shared_1.MessageTypes.nonUniqueName, category: specification_shared_1.MessageCategories.validateSpecification });
        return rc;
    }
    validateUniqueName(language) {
        let name = (0, specification_shared_2.getSpecificationI18nName)(this.settings, language);
        let rc = true;
        new configspec_1.ConfigSpecification().filterAllSpecifications((spec) => {
            if (rc && this.settings.filename != spec.filename) {
                let texts = spec.i18n.find((lang) => lang.lang == language);
                if (texts && texts.texts)
                    if (texts.texts.find((text) => text.textId == 'name' && text.text == name))
                        rc = false;
            }
        });
        return rc;
    }
    static setIdentifiedByEntities(mSpec) {
        mSpec.identified = specification_shared_2.IdentifiedStates.unknown;
        mSpec.entities.forEach((ent) => {
            switch (ent.identified) {
                case specification_shared_2.IdentifiedStates.notIdentified:
                    mSpec.identified = specification_shared_2.IdentifiedStates.notIdentified;
                    break;
                case specification_shared_2.IdentifiedStates.identified:
                    if (mSpec.identified == undefined || mSpec.identified == specification_shared_2.IdentifiedStates.unknown)
                        mSpec.identified = specification_shared_2.IdentifiedStates.identified;
                    break;
            }
        });
    }
    static fileToModbusSpecification(inSpec, values) {
        let valuesLocal = values;
        if (valuesLocal == undefined) {
            valuesLocal = emptyModbusValues();
        }
        configspec_1.ConfigSpecification.clearModbusData(inSpec);
        // copy from test data if there are no values passed
        if (values == undefined &&
            inSpec.testdata &&
            ((inSpec.testdata.analogInputs && inSpec.testdata.analogInputs.length > 0) ||
                (inSpec.testdata.holdingRegisters && inSpec.testdata.holdingRegisters.length > 0) ||
                (inSpec.testdata.coils && inSpec.testdata.coils.length > 0) ||
                (inSpec.testdata.discreteInputs && inSpec.testdata.discreteInputs.length > 0))) {
            M2mSpecification.copyFromTestData(inSpec.testdata.holdingRegisters, valuesLocal.holdingRegisters);
            M2mSpecification.copyFromTestData(inSpec.testdata.analogInputs, valuesLocal.analogInputs);
            M2mSpecification.copyFromTestData(inSpec.testdata.coils, valuesLocal.coils);
            M2mSpecification.copyFromTestData(inSpec.testdata.discreteInputs, valuesLocal.discreteInputs);
        }
        else {
            // No values available neither testdata nor
        }
        let rc = Object.assign(inSpec);
        for (let entityIndex = 0; entityIndex < inSpec.entities.length; entityIndex++) {
            let entity = rc.entities[entityIndex];
            if (entity.modbusAddress != undefined && entity.registerType) {
                let sm = M2mSpecification.copyModbusDataToEntity(rc, entity.id, valuesLocal);
                if (sm) {
                    rc.entities[entityIndex] = sm;
                }
            }
        }
        M2mSpecification.setIdentifiedByEntities(rc);
        return rc;
    }
    static copyModbusDataToEntity(spec, entityId, values) {
        let entity = spec.entities.find((ent) => entityId == ent.id);
        if (entity) {
            let rc = structuredClone(entity);
            let converter = convertermap_1.ConverterMap.getConverter(entity);
            if (converter) {
                if (entity.modbusAddress != undefined) {
                    try {
                        var data = { result: { data: [], buffer: Buffer.from('') } };
                        for (let address = entity.modbusAddress; address < entity.modbusAddress + converter.getModbusLength(entity); address++) {
                            let value = {};
                            switch (entity.registerType) {
                                case specification_shared_1.ModbusRegisterType.AnalogInputs:
                                    value = values.analogInputs.get(address);
                                    break;
                                case specification_shared_1.ModbusRegisterType.HoldingRegister:
                                    value = values.holdingRegisters.get(address);
                                    break;
                                case specification_shared_1.ModbusRegisterType.Coils:
                                    value = values.coils.get(address);
                                    break;
                                case specification_shared_1.ModbusRegisterType.DiscreteInputs:
                                    value = values.discreteInputs.get(address);
                                    break;
                            }
                            if (value && value.result) {
                                data.result.data = data.result.data.concat(value.result.data);
                                if (address == entity.modbusAddress)
                                    data.result.buffer = Buffer.concat([value.result.buffer]);
                                else
                                    data.result.buffer = Buffer.concat([data.result.buffer, value.result.buffer]);
                            }
                            // Only the last error will survive
                            if (value && value.error) {
                                data.error = value.error;
                            }
                        }
                        if (data.result && data.result.data.length > 0) {
                            let mqtt = converter.modbus2mqtt(spec, entity.id, data.result);
                            let identified = specification_shared_2.IdentifiedStates.unknown;
                            if (entity.converterParameters)
                                if (entity.converter.name === 'number') {
                                    if (!entity.converterParameters.identification)
                                        entity.identified = specification_shared_2.IdentifiedStates.unknown;
                                    else {
                                        //Inumber
                                        let mm = entity.converterParameters.identification;
                                        identified =
                                            mm.min <= mqtt && mqtt <= mm.max
                                                ? specification_shared_2.IdentifiedStates.identified
                                                : specification_shared_2.IdentifiedStates.notIdentified;
                                    }
                                }
                                else {
                                    if (!entity.converterParameters.identification) {
                                        if (entity.converterParameters.options ||
                                            entity.converterParameters.optionModbusValues) {
                                            // Iselect
                                            identified = mqtt != null ? specification_shared_2.IdentifiedStates.identified : specification_shared_2.IdentifiedStates.notIdentified;
                                        }
                                        else {
                                            // no Converter parameters
                                            identified = mqtt.length ? specification_shared_2.IdentifiedStates.identified : specification_shared_2.IdentifiedStates.unknown;
                                        }
                                    }
                                    else {
                                        // Itext
                                        let reg = entity.converterParameters.identification;
                                        if (reg) {
                                            let re = new RegExp('^' + reg + '$');
                                            identified = re.test(mqtt) ? specification_shared_2.IdentifiedStates.identified : specification_shared_2.IdentifiedStates.notIdentified;
                                        }
                                    }
                                }
                            rc.identified = identified;
                            rc.mqttValue = mqtt;
                            rc.modbusValue = data.result.data;
                        }
                        else {
                            rc.identified = specification_shared_2.IdentifiedStates.notIdentified;
                            rc.mqttValue = '';
                            rc.modbusValue = [];
                        }
                        if (data.error) {
                            rc.modbusError = data.error?.message;
                        }
                    }
                    catch (error) {
                        log.log(log_1.LogLevelEnum.error, error);
                    }
                }
                else {
                    log.log(log_1.LogLevelEnum.error, 'entity has no modbusaddress: entity id:' + entity.id + ' converter:' + entity.converter);
                    // It remains an Ientity
                }
            }
            else
                log.log(log_1.LogLevelEnum.error, 'Converter not found: ' + spec.filename + ' ' + entity.converter.name + ' entity id: ' + +entity.id);
            return rc;
        }
        else {
            let msg = 'EntityId ' + entityId + ' not found in specifcation ';
            log.log(log_1.LogLevelEnum.error, msg);
            throw new Error(msg);
        }
    }
    static copyFromTestData(testdata, data) {
        if (testdata)
            testdata.forEach((mv) => {
                if (mv.value != undefined)
                    data.set(mv.address, {
                        result: { data: [mv.value], buffer: Buffer.from([mv.value / 256, mv.value % 256]) },
                        error: mv.error ? new Error(mv.error) : undefined,
                    });
                else
                    data.set(mv.address, { error: mv.error ? new Error(mv.error) : undefined });
            });
    }
    validateIdentification(language) {
        let identifiedSpecs = [];
        let values = emptyModbusValues();
        let fSettings;
        if (this.settings.testdata)
            fSettings = this.settings;
        else
            fSettings = configspec_1.ConfigSpecification.toFileSpecification(this.settings);
        if (fSettings.testdata.holdingRegisters)
            M2mSpecification.copyFromTestData(fSettings.testdata.holdingRegisters, values.holdingRegisters);
        if (fSettings.testdata.analogInputs)
            M2mSpecification.copyFromTestData(fSettings.testdata.analogInputs, values.analogInputs);
        if (fSettings.testdata.coils)
            M2mSpecification.copyFromTestData(fSettings.testdata.coils, values.coils);
        if (fSettings.testdata.discreteInputs)
            M2mSpecification.copyFromTestData(fSettings.testdata.discreteInputs, values.discreteInputs);
        new configspec_1.ConfigSpecification().filterAllSpecifications((spec) => {
            if ([1 /* SpecificationStatus.cloned */, 0 /* SpecificationStatus.published */, 4 /* SpecificationStatus.contributed */].includes(spec.status)) {
                var mSpec = undefined;
                var fSpec = spec;
                switch (spec.status) {
                    case 0 /* SpecificationStatus.published */:
                        mSpec = M2mSpecification.fileToModbusSpecification(spec, values);
                        break;
                    case 4 /* SpecificationStatus.contributed */:
                        if (spec.publicSpecification) {
                            mSpec = M2mSpecification.fileToModbusSpecification(spec.publicSpecification, values);
                            fSpec = spec.publicSpecification;
                        }
                        else
                            mSpec = M2mSpecification.fileToModbusSpecification(spec, values);
                        break;
                    case 1 /* SpecificationStatus.cloned */:
                        if (spec.publicSpecification) {
                            mSpec = M2mSpecification.fileToModbusSpecification(spec.publicSpecification, values);
                            fSpec = spec.publicSpecification;
                        }
                        else
                            log.log(log_1.LogLevelEnum.error, 'Cloned Specification with no public Specification ' + spec.filename);
                        break;
                    default:
                        mSpec = M2mSpecification.fileToModbusSpecification(fSpec, values);
                }
                let specName = (0, specification_shared_2.getSpecificationI18nName)(spec, language);
                if (fSettings.filename != spec.filename) {
                    let allMatch = this.allNullValuesMatch(spec, values);
                    if (allMatch && mSpec && mSpec.identified == specification_shared_2.IdentifiedStates.identified) {
                        let ent = mSpec.entities.find((ent) => ent.identified == specification_shared_2.IdentifiedStates.notIdentified);
                        if (specName)
                            identifiedSpecs.push({ specname: specName, referencedEntity: ent?.id });
                        else
                            identifiedSpecs.push({ specname: 'unknown', referencedEntity: ent?.id });
                    }
                }
            }
        });
        return identifiedSpecs;
    }
    allNullDataMatch(datas, values) {
        let rc = true;
        if (datas)
            datas.forEach((data) => {
                if (data.value == null && values.get(data.address) != null)
                    rc = false;
            });
        return rc;
    }
    allNullValuesMatch(spec, values) {
        let rc = this.allNullDataMatch(spec.testdata.holdingRegisters, values.holdingRegisters);
        if (!rc)
            return false;
        rc = this.allNullDataMatch(spec.testdata.analogInputs, values.analogInputs);
        if (!rc)
            return false;
        return this.allNullDataMatch(spec.testdata.coils, values.coils);
    }
    getPropertyFromVariable(entityId, targetParameter) {
        let ent = this.settings.entities.find((e) => e.variableConfiguration &&
            e.variableConfiguration.targetParameter == targetParameter &&
            e.variableConfiguration.entityId &&
            e.variableConfiguration.entityId == entityId);
        if (ent)
            return ent.mqttValue;
        return undefined;
    }
    getEntityFromId(entityId) {
        let ent = this.settings.entities.find((e) => e.id == entityId);
        if (!ent)
            return undefined;
        return ent;
    }
    static getFileUsage(url) {
        let name = url.toLowerCase();
        if (name.endsWith('.pdf'))
            return "doc" /* SpecificationFileUsage.documentation */;
        if (name.endsWith('.jpg') || name.endsWith('.jpeg') || name.endsWith('.png') || name.endsWith('.bmp'))
            return "img" /* SpecificationFileUsage.img */;
        return "doc" /* SpecificationFileUsage.documentation */;
    }
    getUom(entityId) {
        let rc = this.getPropertyFromVariable(entityId, specification_shared_1.VariableTargetParameters.entityUom);
        if (rc)
            return rc;
        let ent = this.getEntityFromId(entityId);
        if (!ent || !ent.converterParameters || !ent.converterParameters.uom)
            return undefined;
        return ent.converterParameters.uom;
    }
    getMultiplier(entityId) {
        let rc = this.getPropertyFromVariable(entityId, specification_shared_1.VariableTargetParameters.entityMultiplier);
        if (rc)
            return rc;
        let ent = this.getEntityFromId(entityId);
        if (!ent || !ent.converterParameters || undefined == ent.converterParameters.multiplier)
            return undefined;
        return ent.converterParameters.multiplier;
    }
    getDecimals(entityId) {
        //    let rc = this.getPropertyFromVariable(entityId, VariableTargetParameters.entityMultiplier)
        //    if (rc) return rc as number | undefined
        let ent = this.getEntityFromId(entityId);
        if (!ent || !ent.converterParameters || undefined == ent.converterParameters.decimals)
            return undefined;
        return ent.converterParameters.decimals;
    }
    getOffset(entityId) {
        let rc = this.getPropertyFromVariable(entityId, specification_shared_1.VariableTargetParameters.entityOffset);
        if (rc)
            return rc;
        let ent = this.getEntityFromId(entityId);
        if (!ent || !ent.converterParameters || ent.converterParameters.offset == undefined)
            return undefined;
        return ent.converterParameters.offset;
    }
    isVariable(checkParameter) {
        let ent = this.settings.entities.find((e) => e.variableConfiguration && e.variableConfiguration.targetParameter == checkParameter);
        return ent != undefined;
    }
    isEqualValue(v1, v2) {
        if (!v1 && !v2)
            return true;
        if (v1 && v2 && v1 == v2)
            return true;
        return false;
    }
    isEqual(other) {
        let rc = [];
        let spec = this.settings;
        if (spec.filename != other.filename)
            rc.push({ type: specification_shared_1.MessageTypes.differentFilename, category: specification_shared_1.MessageCategories.compare });
        spec.entities.forEach((ent) => {
            if (!other.entities.find((oent) => oent.id == ent.id))
                rc.push({ type: specification_shared_1.MessageTypes.addedEntity, category: specification_shared_1.MessageCategories.compareEntity, referencedEntity: ent.id });
        });
        other.entities.forEach((oent) => {
            let ent = spec.entities.find((ent) => oent.id == ent.id);
            if (!ent)
                rc.push({
                    type: specification_shared_1.MessageTypes.missingEntity,
                    category: specification_shared_1.MessageCategories.compare,
                    additionalInformation: (0, specification_shared_2.getSpecificationI18nEntityName)(other, 'en', oent.id),
                });
            else {
                if (!this.isEqualValue(oent.converter.name, ent.converter.name))
                    rc.push({ type: specification_shared_1.MessageTypes.differentConverter, category: specification_shared_1.MessageCategories.compareEntity, referencedEntity: ent.id });
                if (!this.isEqualValue(oent.modbusAddress, ent.modbusAddress))
                    rc.push({
                        type: specification_shared_1.MessageTypes.differentModbusAddress,
                        category: specification_shared_1.MessageCategories.compareEntity,
                        referencedEntity: ent.id,
                    });
                if (!this.isEqualValue(oent.registerType, ent.registerType))
                    rc.push({ type: specification_shared_1.MessageTypes.differentFunctionCode, category: specification_shared_1.MessageCategories.compareEntity, referencedEntity: ent.id });
                if (!this.isEqualValue(oent.icon, ent.icon))
                    rc.push({ type: specification_shared_1.MessageTypes.differentIcon, category: specification_shared_1.MessageCategories.compareEntity, referencedEntity: ent.id });
                if (oent.variableConfiguration && ent.variableConfiguration) {
                    if (!this.isEqualValue(oent.variableConfiguration.targetParameter, ent.variableConfiguration.targetParameter))
                        rc.push({
                            type: specification_shared_1.MessageTypes.differentTargetParameter,
                            category: specification_shared_1.MessageCategories.compareEntity,
                            referencedEntity: ent.id,
                        });
                    else if (!this.isEqualValue(oent.variableConfiguration.entityId, ent.variableConfiguration.entityId))
                        rc.push({
                            type: specification_shared_1.MessageTypes.differentVariableEntityId,
                            category: specification_shared_1.MessageCategories.compareEntity,
                            referencedEntity: ent.id,
                        });
                }
                else if (oent.variableConfiguration || ent.variableConfiguration)
                    rc.push({
                        type: specification_shared_1.MessageTypes.differentVariableConfiguration,
                        category: specification_shared_1.MessageCategories.compareEntity,
                        referencedEntity: ent.id,
                    });
                if (ent.converterParameters && oent.converterParameters)
                    switch ((0, specification_shared_1.getParameterType)(oent.converter)) {
                        case 'Inumber':
                            if (!this.isEqualValue(oent.converterParameters.device_class, ent.converterParameters.device_class))
                                rc.push({
                                    type: specification_shared_1.MessageTypes.differentDeviceClass,
                                    category: specification_shared_1.MessageCategories.compareEntity,
                                    referencedEntity: ent.id,
                                });
                            if (oent.converterParameters.identification && ent.converterParameters.identification) {
                                if (!this.isEqualValue(oent.converterParameters.identification.max, ent.converterParameters.identification.max))
                                    rc.push({
                                        type: specification_shared_1.MessageTypes.differentIdentificationMax,
                                        category: specification_shared_1.MessageCategories.compareEntity,
                                        referencedEntity: ent.id,
                                    });
                                else if (!this.isEqualValue(oent.converterParameters.identification.min, ent.converterParameters.identification.min))
                                    rc.push({
                                        type: specification_shared_1.MessageTypes.differentIdentificationMin,
                                        category: specification_shared_1.MessageCategories.compareEntity,
                                        referencedEntity: ent.id,
                                    });
                            }
                            else if (oent.converterParameters.identification ||
                                ent.converterParameters.identification)
                                rc.push({
                                    type: specification_shared_1.MessageTypes.differentIdentification,
                                    category: specification_shared_1.MessageCategories.compareEntity,
                                    referencedEntity: ent.id,
                                });
                            if (!this.isEqualValue(oent.converterParameters.multiplier, ent.converterParameters.multiplier))
                                rc.push({
                                    type: specification_shared_1.MessageTypes.differentMultiplier,
                                    category: specification_shared_1.MessageCategories.compareEntity,
                                    referencedEntity: ent.id,
                                });
                            if (!this.isEqualValue(oent.converterParameters.offset, ent.converterParameters.offset))
                                rc.push({ type: specification_shared_1.MessageTypes.differentOffset, category: specification_shared_1.MessageCategories.compareEntity, referencedEntity: ent.id });
                            break;
                        case 'Iselect':
                            if (JSON.stringify(oent.converterParameters.optionModbusValues) !=
                                JSON.stringify(ent.converterParameters.optionModbusValues))
                                rc.push({
                                    type: specification_shared_1.MessageTypes.differentOptionTable,
                                    category: specification_shared_1.MessageCategories.compareEntity,
                                    referencedEntity: ent.id,
                                });
                            break;
                        case 'Itext':
                            if (!this.isEqualValue(oent.converterParameters.stringlength, ent.converterParameters.stringlength))
                                rc.push({
                                    type: specification_shared_1.MessageTypes.differentStringlength,
                                    category: specification_shared_1.MessageCategories.compareEntity,
                                    referencedEntity: ent.id,
                                });
                            if (!this.isEqualValue(oent.converterParameters.identification, ent.converterParameters.identification))
                                rc.push({
                                    type: specification_shared_1.MessageTypes.differentIdentification,
                                    category: specification_shared_1.MessageCategories.compareEntity,
                                    referencedEntity: ent.id,
                                });
                            break;
                    }
            }
        });
        if (JSON.stringify(spec.i18n) != JSON.stringify(other.i18n))
            rc.push({ type: specification_shared_1.MessageTypes.differentTranslation, category: specification_shared_1.MessageCategories.compare });
        if (!this.isEqualValue(spec.manufacturer, other.manufacturer))
            rc.push({ type: specification_shared_1.MessageTypes.differentManufacturer, category: specification_shared_1.MessageCategories.compare });
        if (!this.isEqualValue(spec.model, other.model))
            rc.push({ type: specification_shared_1.MessageTypes.differentModel, category: specification_shared_1.MessageCategories.compare });
        if (!this.isEqualValue(spec.identification, other.identification))
            rc.push({ type: specification_shared_1.MessageTypes.differentIdentification, category: specification_shared_1.MessageCategories.compare });
        return rc;
    }
    validateFiles(msgs) {
        let category = specification_shared_1.MessageCategories.validateFiles;
        let spec = this.settings;
        let hasDocumentation = false;
        let hasImage = false;
        spec.files.forEach((f) => {
            if (f.usage == "doc" /* SpecificationFileUsage.documentation */)
                hasDocumentation = true;
            if (f.usage == "img" /* SpecificationFileUsage.img */)
                hasImage = true;
        });
        if (!hasDocumentation)
            msgs.push({ type: specification_shared_1.MessageTypes.noDocumentation, category: category });
        if (!hasImage)
            msgs.push({ type: specification_shared_1.MessageTypes.noImage, category: category });
    }
    validateSpecification(language, forContribution = false) {
        let msgs = [];
        let spec = this.settings;
        this.validateFiles(msgs);
        if (spec.entities.length == 0)
            msgs.push({ type: specification_shared_1.MessageTypes.noEntity, category: specification_shared_1.MessageCategories.validateEntity });
        (0, specification_shared_1.validateTranslation)(spec, language, msgs);
        if (forContribution)
            (0, specification_shared_1.validateTranslation)(spec, 'en', msgs);
        return msgs;
    }
    getBaseFilename(filename) {
        let idx = filename.lastIndexOf('/');
        if (idx >= 0)
            return filename.substring(idx + 1);
        return filename;
    }
    static { this.pollingTimeout = 15 * 1000; }
    static startPolling(specfilename, error) {
        debug('startPolling');
        let spec = configspec_1.ConfigSpecification.getSpecificationByFilename(specfilename);
        let contribution = M2mSpecification.ghContributions.get(specfilename);
        if (contribution == undefined && spec && spec.pullNumber) {
            log.log(log_1.LogLevelEnum.notice, 'startPolling for pull Number ' + spec.pullNumber);
            let mspec = new M2mSpecification(spec);
            let c = {
                pullRequest: spec.pullNumber,
                monitor: new rxjs_1.Subject(),
                pollCount: 0,
                m2mSpecification: mspec,
                interval: setInterval(() => {
                    M2mSpecification.poll(spec.filename, error);
                }, M2mSpecification.pollingTimeout),
            };
            M2mSpecification.ghContributions.set(spec.filename, c);
            return c.monitor;
        }
        return undefined;
    }
    static getNextCheck(specfilename) {
        let c = M2mSpecification.ghContributions.get(specfilename);
        if (c && c.nextCheck)
            return c.nextCheck;
        return '';
    }
    static triggerPoll(specfilename) {
        let c = M2mSpecification.ghContributions.get(specfilename);
        if (c && c.m2mSpecification) {
            c.pollCount = 0;
            c.m2mSpecification.ghPollIntervalIndexCount = 0;
        }
    }
    static msToTime(ms) {
        let seconds = ms / 1000;
        let minutes = ms / (1000 * 60);
        let hours = ms / (1000 * 60 * 60);
        let days = ms / (1000 * 60 * 60 * 24);
        if (seconds < 60)
            return seconds.toFixed(1) + ' Sec';
        else if (minutes < 60)
            return minutes.toFixed(1) + ' Min';
        else if (hours < 24)
            return hours.toFixed(1) + ' Hrs';
        else
            return days.toFixed(1) + ' Days';
    }
    static { this.inCloseContribution = false; }
    static poll(specfilename, error) {
        let contribution = M2mSpecification.ghContributions.get(specfilename);
        let spec = contribution?.m2mSpecification.settings;
        if (configspec_1.ConfigSpecification.githubPersonalToken == undefined ||
            spec.status != 4 /* SpecificationStatus.contributed */ ||
            spec.pullNumber == undefined)
            return;
        if (contribution == undefined) {
            M2mSpecification.handleCloseContributionError('Unexpected undefined contribution', error);
        }
        else {
            if (contribution.pollCount >
                contribution.m2mSpecification.ghPollInterval[contribution.m2mSpecification.ghPollIntervalIndex] / 100)
                contribution.pollCount = 0;
            else {
                let interval = contribution.m2mSpecification.ghPollInterval[contribution.m2mSpecification.ghPollIntervalIndex] / 100;
                let nextCheckTotalMs = (interval - contribution.pollCount) * 100;
                contribution.nextCheck = M2mSpecification.msToTime(nextCheckTotalMs);
            }
            if (contribution.pollCount == 0) {
                // Set ghPollIntervalIndex (Intervall duration)
                // 10 * every 5 second, 10 * every 5 minutes, 10 * every 5 hours, then once a day
                if (contribution.m2mSpecification.ghPollIntervalIndexCount++ >= 10 &&
                    contribution.m2mSpecification.ghPollIntervalIndex < contribution.m2mSpecification.ghPollInterval.length - 1) {
                    contribution.m2mSpecification.ghPollIntervalIndex++;
                    contribution.m2mSpecification.ghPollIntervalIndexCount = 0;
                }
                if (!M2mSpecification.inCloseContribution) {
                    M2mSpecification.inCloseContribution = true;
                    M2mSpecification.closeContribution(spec)
                        .then((pullStatus) => {
                        debug('contribution closed for pull Number ' + spec.pullNumber);
                        if (contribution) {
                            contribution.monitor.next(pullStatus);
                            if (pullStatus.closed || pullStatus.merged) {
                                clearInterval(contribution.interval);
                                M2mSpecification.ghContributions.delete(spec.filename);
                                contribution.monitor.complete();
                            }
                        }
                    })
                        .catch(error)
                        .finally(() => {
                        M2mSpecification.inCloseContribution = false;
                    });
                }
            }
            contribution.pollCount++;
        }
    }
}
exports.M2mSpecification = M2mSpecification;
//# sourceMappingURL=m2mspecification.js.map