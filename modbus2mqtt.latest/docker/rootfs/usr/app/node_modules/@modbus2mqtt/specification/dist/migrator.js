"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migrator = void 0;
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const log_1 = require("./log");
let log = new log_1.Logger('migrator');
var ModbusFunctionCodes;
(function (ModbusFunctionCodes) {
    ModbusFunctionCodes[ModbusFunctionCodes["readHoldingRegisters"] = 3] = "readHoldingRegisters";
    ModbusFunctionCodes[ModbusFunctionCodes["readCoils"] = 1] = "readCoils";
    ModbusFunctionCodes[ModbusFunctionCodes["readAnalogInputs"] = 4] = "readAnalogInputs";
    ModbusFunctionCodes[ModbusFunctionCodes["writeCoils"] = 15] = "writeCoils";
    ModbusFunctionCodes[ModbusFunctionCodes["writeAnalogOutput"] = 6] = "writeAnalogOutput";
    ModbusFunctionCodes[ModbusFunctionCodes["readWriteHoldingRegisters"] = 21] = "readWriteHoldingRegisters";
    ModbusFunctionCodes[ModbusFunctionCodes["readAnalogs"] = 22] = "readAnalogs";
    ModbusFunctionCodes[ModbusFunctionCodes["readWriteCoils"] = 20] = "readWriteCoils";
    ModbusFunctionCodes[ModbusFunctionCodes["writeHoldingRegisters"] = 16] = "writeHoldingRegisters";
    ModbusFunctionCodes[ModbusFunctionCodes["IllegalFunctionCode"] = 0] = "IllegalFunctionCode";
})(ModbusFunctionCodes || (ModbusFunctionCodes = {}));
var FCOffset = 100000;
class Migrator {
    constructor() { }
    migrate(filecontent) {
        let rc;
        let count = 0;
        let maxCount = 4;
        while (filecontent.version != undefined && count < maxCount) {
            count++;
            switch (filecontent.version) {
                case '0.1':
                    filecontent = this.migrate0_1to0_2(filecontent);
                    break;
                case '0.2':
                    filecontent = this.migrate0_2to0_3(filecontent);
                    break;
                case specification_shared_1.SPECIFICATION_VERSION:
                    return filecontent;
                default:
                    log.log(log_1.LogLevelEnum.error, 'Migration: Specification Version ' + filecontent.version + ' is unknown');
                    throw new Error('Specification Version ' + filecontent.version + ' is unknown');
            }
        }
        return filecontent;
    }
    fc2registerType(functioncode) {
        switch (functioncode) {
            case ModbusFunctionCodes.readHoldingRegisters:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.HoldingRegister,
                    readonly: true,
                };
            case ModbusFunctionCodes.readCoils:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.Coils,
                    readonly: true,
                };
            case ModbusFunctionCodes.readAnalogInputs:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.AnalogInputs,
                    readonly: true,
                };
            case ModbusFunctionCodes.writeCoils:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.Coils,
                    readonly: false,
                };
            case ModbusFunctionCodes.writeAnalogOutput:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.AnalogInputs,
                    readonly: false,
                };
            case ModbusFunctionCodes.readWriteHoldingRegisters:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.HoldingRegister,
                    readonly: false,
                };
            case ModbusFunctionCodes.readAnalogs:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.AnalogInputs,
                    readonly: true,
                };
            case ModbusFunctionCodes.readWriteCoils:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.Coils,
                    readonly: false,
                };
            case ModbusFunctionCodes.writeHoldingRegisters:
                return {
                    registerType: specification_shared_1.ModbusRegisterType.HoldingRegister,
                    readonly: false,
                };
            case ModbusFunctionCodes.IllegalFunctionCode:
                log.log(log_1.LogLevelEnum.error, 'Function Code' + functioncode + ' is unknown');
        }
        return undefined;
    }
    migrate0_1to0_2(filecontent) {
        filecontent.version = '0.2';
        // functioncode to registerType
        if (filecontent.entities)
            filecontent.entities.forEach((entity) => {
                delete entity.converter.functionCodes;
                entity.converter.name = this.getConvertername0_1(entity.converter.name);
                entity.converter.registerTypes = [];
                let rt = this.fc2registerType(entity.functionCode);
                if (rt) {
                    entity.registerType = rt.registerType;
                    entity.readonly = rt.readonly;
                    delete entity.functionCode;
                }
            });
        let td = {
            coils: [],
            analogInputs: [],
            holdingRegisters: [],
        };
        if (filecontent.testdata) {
            filecontent.testdata.forEach((data) => {
                let fc = Math.floor(data.address / FCOffset);
                let address = data.address % FCOffset;
                let value = data.value;
                let rt = this.fc2registerType(fc);
                if (rt)
                    switch (rt.registerType) {
                        case specification_shared_1.ModbusRegisterType.AnalogInputs:
                            td.analogInputs.push({ address: address, value: value });
                            break;
                        case specification_shared_1.ModbusRegisterType.HoldingRegister:
                            td.holdingRegisters.push({ address: address, value: value });
                            break;
                        case specification_shared_1.ModbusRegisterType.Coils:
                            td.coils.push({ address: address, value: value });
                            break;
                    }
            });
        }
        if (td.analogInputs.length == 0)
            delete td.analogInputs;
        if (td.holdingRegisters.length == 0)
            delete td.holdingRegisters;
        if (td.coils.length == 0)
            delete td.coils;
        filecontent.testdata = td;
        return filecontent;
    }
    convertTestData0_2to0_3(data) {
        if (data)
            data.forEach((data) => {
                if (data?.value == null) {
                    delete data.value;
                    data.error = new Error('No data available');
                }
            });
    }
    migrate0_2to0_3(filecontent) {
        filecontent.version = '0.3';
        if (filecontent.testdata) {
            this.convertTestData0_2to0_3(filecontent.testdata.analogInputs);
            this.convertTestData0_2to0_3(filecontent.testdata.holdingRegisters);
            this.convertTestData0_2to0_3(filecontent.testdata.coils);
        }
        return filecontent;
    }
    getConvertername0_1(converter) {
        switch (converter) {
            case 'sensor':
                return 'number';
            case 'number':
            case 'select':
            case 'text':
            case 'button':
            case 'value':
                return converter;
            case 'text_sensor':
            case 'select_sensor':
            case 'binary_sensor':
            case 'value_sensor':
                return converter.replaceAll('_sensor', '');
        }
        log.log(log_1.LogLevelEnum.error, 'Unable to convert converter to registerType ' + converter);
        return converter;
    }
    migrateFiles(fileContent) {
        if (fileContent.length) {
            fileContent.forEach((fc) => {
                if (fc.fileLocation == specification_shared_1.FileLocation.Local && fc.url.startsWith('/'))
                    fc.url = fc.url.substring(1); // Remove trailing  '/'
            });
            return { version: specification_shared_1.SPECIFICATION_FILES_VERSION, files: fileContent };
        }
        return fileContent;
    }
}
exports.Migrator = Migrator;
//# sourceMappingURL=migrator.js.map