"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberConverter = void 0;
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const converter_1 = require("./converter");
const specification_shared_2 = require("@modbus2mqtt/specification.shared");
const m2mspecification_1 = require("./m2mspecification");
class NumberConverter extends converter_1.Converter {
    constructor(component) {
        if (!component)
            component = 'number';
        super(component);
    }
    modbus2mqtt(spec, entityid, value) {
        let entity = spec.entities.find((e) => e.id == entityid);
        let mspec = new m2mspecification_1.M2mSpecification(spec.entities);
        if (entity) {
            if (value.data.length == 0)
                throw new Error('NumberConverter.modbus2mqtt: No value in array');
            let numberFormat = entity.converterParameters != undefined && entity.converterParameters.numberFormat != undefined
                ? entity.converterParameters.numberFormat
                : specification_shared_2.EnumNumberFormat.default;
            let v = value.data[0];
            switch (numberFormat) {
                case specification_shared_2.EnumNumberFormat.float32:
                    if (value.buffer && value.buffer.length >= 4)
                        v = value.buffer.readFloatBE();
                    else
                        new Error('NumberConverter.modbus2mqtt: Invalid buffer to convert to Float entityid = ' + entityid);
                    break;
                case specification_shared_2.EnumNumberFormat.signedInt16:
                    if (value.buffer && value.buffer.length >= 2)
                        v = value.buffer.readInt16BE();
                    else
                        new Error('NumberConverter.modbus2mqtt: Invalid buffer to convert to Signed16 int entityid = ' + entityid);
                    break;
                case specification_shared_2.EnumNumberFormat.unsignedInt32:
                    if (value.buffer && value.buffer.length >= 4)
                        v = value.buffer.readUint32BE();
                    else
                        new Error('NumberConverter.modbus2mqtt: Invalid buffer to convert to Unsigned32 entityid = ' + entityid);
                    break;
                case specification_shared_2.EnumNumberFormat.signedInt32:
                    if (value.buffer && value.buffer.length >= 4)
                        v = value.buffer.readInt32BE();
                    else
                        new Error('NumberConverter.modbus2mqtt: Invalid buffer to convert to Signed32 entityid = ' + entityid);
                    break;
            }
            let multiplier = mspec.getMultiplier(entityid);
            let offset = mspec.getOffset(entityid);
            if (!multiplier)
                multiplier = 1;
            if (!offset)
                offset = 0;
            let dec = mspec.getDecimals(entityid);
            v = v * multiplier + offset;
            return v;
            return v;
        }
        else
            throw new Error('entityid not found in entities');
    }
    mqtt2modbus(spec, entityid, value) {
        let mspec = new m2mspecification_1.M2mSpecification(spec.entities);
        let multiplier = mspec.getMultiplier(entityid);
        let offset = mspec.getOffset(entityid);
        if (!multiplier)
            multiplier = 1;
        if (!offset)
            offset = 0;
        let entity = spec.entities.find((e) => e.id == entityid);
        if (entity) {
            let numberFormat = entity.converterParameters != undefined && entity.converterParameters.numberFormat != undefined
                ? entity.converterParameters.numberFormat
                : specification_shared_2.EnumNumberFormat.default;
            let buf = Buffer.allocUnsafe(4);
            value = (value - offset) / multiplier;
            let v = value;
            switch (numberFormat) {
                case specification_shared_2.EnumNumberFormat.float32:
                    buf.writeFloatBE(v);
                    break;
                case specification_shared_2.EnumNumberFormat.signedInt16:
                    buf.writeInt16BE(v);
                    v = buf.readUInt16BE();
                    break;
                case specification_shared_2.EnumNumberFormat.unsignedInt32:
                    buf.writeUint32BE(v);
                    v = buf.readUint32BE();
                    break;
                case specification_shared_2.EnumNumberFormat.signedInt32:
                    buf.writeInt32BE(v);
                    v = buf.readInt32BE();
                    break;
                default:
                    buf = Buffer.allocUnsafe(2);
                    buf.writeUInt16BE(v);
            }
            let r = {
                data: [v],
                buffer: buf,
            };
            return r;
        }
        throw new Error('entityid not found in entities');
    }
    getParameterType(_entity) {
        return 'Inumber';
    }
    getModbusLength(entity) {
        if (entity.converterParameters == undefined || entity.converterParameters.numberFormat == undefined)
            return 1;
        switch (entity.converterParameters.numberFormat) {
            case specification_shared_2.EnumNumberFormat.float32:
            case specification_shared_2.EnumNumberFormat.signedInt32:
            case specification_shared_2.EnumNumberFormat.unsignedInt32:
                return 2;
            case specification_shared_2.EnumNumberFormat.signedInt16:
            default:
                return 1;
        }
    }
    getModbusRegisterTypes() {
        return [specification_shared_1.ModbusRegisterType.HoldingRegister, specification_shared_1.ModbusRegisterType.AnalogInputs];
    }
}
exports.NumberConverter = NumberConverter;
//# sourceMappingURL=numberConverter.js.map