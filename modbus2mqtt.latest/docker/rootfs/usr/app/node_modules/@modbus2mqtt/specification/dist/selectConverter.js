"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectConverter = void 0;
const converter_1 = require("./converter");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const log_1 = require("./log");
const configspec_1 = require("./configspec");
const debug = require('debug')('selectConverter');
const log = new log_1.Logger('selectconverter');
class SelectConverter extends converter_1.Converter {
    constructor(component) {
        if (!component)
            component = 'select';
        super(component);
        this.length = 1;
    }
    getOptions(spec, entityid) {
        let entity = spec.entities.find((e) => e.id == entityid);
        if (entity && entity.converterParameters) {
            if ('options' in entity.converterParameters && entity.converterParameters.options) {
                return entity.converterParameters.options;
            }
            else if ('optionModbusValues' in entity.converterParameters && entity.converterParameters.optionModbusValues) {
                let options = [];
                entity.converterParameters.optionModbusValues.forEach((option) => {
                    let name = (0, specification_shared_1.getSpecificationI18nEntityOptionName)(spec, configspec_1.ConfigSpecification.mqttdiscoverylanguage, entityid, option);
                    options.push({ key: option, name: name ? name : '' });
                });
                return options;
            }
        }
        debug('No options available for entity id: ' + entityid);
        return [];
    }
    publishModbusValues() {
        return true;
    }
    modbus2mqtt(spec, entityid, value) {
        let entity = spec.entities.find((e) => e.id == entityid);
        var msg = '';
        if (entity) {
            let opts = entity.converterParameters.options;
            if (opts && opts.length > 0) {
                let opt = entity.converterParameters.options.find((opt) => opt.key == value.data[0]);
                return opt && opt.name ? opt.name : '';
            }
            else {
                var rc = (0, specification_shared_1.getSpecificationI18nEntityOptionName)(spec, configspec_1.ConfigSpecification.mqttdiscoverylanguage, entityid, value.data[0]);
                if (rc)
                    return rc;
            }
            let options = this.getOptions(spec, entityid);
            var msg = 'option not found spec: ' +
                spec.filename +
                ' entity id: "' +
                entity.id +
                '" key:' +
                value.data[0] +
                ' options: ' +
                JSON.stringify(options);
        }
        else
            msg = 'entityid not in entities list: "' + entityid + '" key:' + value.data[0];
        return msg;
    }
    mqtt2modbus(spec, entityid, name) {
        let entity = spec.entities.find((e) => e.id == entityid);
        if (!entity)
            throw new Error('entity not found in entities');
        if (this.component === 'binary')
            return {
                data: [],
                buffer: Buffer.from(''),
            };
        let val = (0, specification_shared_1.getSpecificationI18nEntityOptionId)(spec, configspec_1.ConfigSpecification.mqttdiscoverylanguage, entityid, name);
        if (val) {
            let buf = Buffer.alloc(2);
            buf.writeInt16BE(val[0]);
            return {
                data: val,
                buffer: buf,
            };
        }
        let options = this.getOptions(spec, entityid);
        var msg = 'unknown option  entity id: ' + entity.id + '(assuming: name = 0)' + name + 'options: ' + options;
        log.log(log_1.LogLevelEnum.error, msg);
        return {
            data: [],
            buffer: Buffer.from(''),
        };
    }
    getParameterType(_entity) {
        switch (this.component) {
            case 'binary':
                return 'Ibinary_sensor';
            default:
                return 'Iselect';
        }
    }
    getModbusRegisterTypes() {
        return [specification_shared_1.ModbusRegisterType.HoldingRegister, specification_shared_1.ModbusRegisterType.AnalogInputs, specification_shared_1.ModbusRegisterType.Coils];
    }
}
exports.SelectConverter = SelectConverter;
//# sourceMappingURL=selectConverter.js.map