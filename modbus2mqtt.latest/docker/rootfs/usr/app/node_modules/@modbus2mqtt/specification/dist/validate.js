"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const specification_shared_1 = require("@modbus2mqtt/specification.shared");
const log_1 = require("./log");
const commander_1 = require("commander");
const configspec_1 = require("./configspec");
const fs = tslib_1.__importStar(require("fs"));
const m2mGithubValidate_1 = require("./m2mGithubValidate");
const m2mspecification_1 = require("./m2mspecification");
let cli = new commander_1.Command();
let yamlDir = './validate-yaml';
cli.version(specification_shared_1.SPECIFICATION_VERSION);
cli.usage('[--yaml <yaml-dir>] [--pr_number <pull request number>');
cli.option('-p, --pr_number <number>', 'pr_number of commit which triggered the pull request');
cli.option('-o, --pr_owner <owner>', 'Creator of the pull request');
cli.parse(process.argv);
let pr_number;
let pr_owner;
let options = cli.opts();
if (options['yaml']) {
    yamlDir = options['yaml'];
}
else
    yamlDir = '.';
if (options['pr_number']) {
    pr_number = Number.parseInt(options['pr_number']);
}
if (options['pr_owner']) {
    pr_owner = options['pr_owner'];
}
configspec_1.ConfigSpecification.yamlDir = yamlDir;
let log = new log_1.Logger('validate');
function logAndExit(e) {
    let step = '';
    if (e.step)
        step = e.step;
    log.log(log_1.LogLevelEnum.error, step + ' ' + e.message);
    process.exit(5);
}
function validate() {
    if (!fs.existsSync(yamlDir))
        fs.mkdirSync(yamlDir, { recursive: true });
    if (pr_number == undefined) {
        log.log(log_1.LogLevelEnum.error, 'No Pull Request number passed in command line');
        process.exit(2);
    }
    if (pr_owner == undefined) {
        log.log(log_1.LogLevelEnum.error, 'No Pull Creator passed in command line');
        process.exit(2);
    }
    if (!process.env.GITHUB_TOKEN) {
        log.log(log_1.LogLevelEnum.error, 'No Github Access Token passed to environment variable GITHUB_TOKEN');
        process.exit(2);
    }
    log.log(log_1.LogLevelEnum.notice, 'pull request: ' + pr_number);
    let gh = new m2mGithubValidate_1.M2mGithubValidate(process.env.GITHUB_TOKEN);
    gh.listPullRequestFiles(pr_owner, pr_number)
        .then((data) => {
        let pr_number = data.pr_number;
        configspec_1.ConfigSpecification.yamlDir = yamlDir;
        let s = new configspec_1.ConfigSpecification();
        s.readYaml();
        let messages = [];
        let specnames = '';
        let lastSpec;
        let specsOnly = true;
        data.files.forEach((fname) => {
            if (!fname.startsWith('specifications/')) {
                specsOnly = false;
            }
            else if (!fname.startsWith('specifications/files/')) {
                let specname = fname.substring('specifications/'.length);
                specnames = specnames + ', ' + specname;
                let fs = configspec_1.ConfigSpecification.getSpecificationByFilename(specname);
                if (fs) {
                    let m2mSpec = new m2mspecification_1.M2mSpecification(fs);
                    lastSpec = fs;
                    messages.concat(m2mSpec.validate('en'));
                }
            }
        });
        if (specsOnly)
            fs.appendFileSync(process.env.GITHUB_OUTPUT, 'SPECS_ONLY=true\n');
        if (specsOnly && specnames.length > 0) {
            specnames = specnames.substring(2);
            if (messages.length == 0) {
                log.log(log_1.LogLevelEnum.notice, 'specifications ' + specnames + ' are valid');
                gh.addIssueComment(pr_number, "**$${\\color{green}\\space ' + specnames + '\\space validated\\space successfully}$$**\nSpecifications '" +
                    specnames +
                    "' have no issues")
                    .then(() => {
                    log.log(log_1.LogLevelEnum.notice, 'Issue Comment added');
                    process.exit(0);
                })
                    .catch((e) => {
                    logAndExit(e);
                });
            }
            else if (lastSpec) {
                let m = '';
                let errors = m2mspecification_1.M2mSpecification.messages2Text(lastSpec, messages);
                log.log(log_1.LogLevelEnum.error, 'not all specifications of \\space ' + specnames + '\\space are valid\\space Proceed manually');
                gh.addIssueComment(pr_number, "**$${\\color{red}Proceed\\space manually}$$**\nSpecification '" + specnames + "'\\space are not valid.\n" + errors)
                    .then((e) => {
                    logAndExit(e);
                })
                    .catch((e) => {
                    logAndExit(e);
                });
            }
            else {
                logAndExit(new Error('No specification found'));
            }
        }
    })
        .catch((e) => {
        logAndExit(e);
    });
}
validate();
//# sourceMappingURL=validate.js.map